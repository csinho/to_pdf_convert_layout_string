<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Editor Visual</title>
  
  <!-- pdfmake (client-side) requires pdfmake + vfs_fonts + teste -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.12/pdfmake.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.12/vfs_fonts.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #f3f4f6;
      height: 100vh;
      overflow: hidden;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    /* Header */
    .header {
      background: white;
      border-bottom: 1px solid #e5e7eb;
      padding: 1rem 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .header-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .header-left h1 {
      font-size: 1.25rem;
      font-weight: bold;
      color: #111827;
    }

    .header-left p {
      font-size: 0.875rem;
      color: #6b7280;
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .orientation-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .orientation-group label {
      font-size: 0.875rem;
      font-weight: 500;
      color: #374151;
    }

    .button-group {
      display: flex;
      gap: 0.5rem;
    }

    button {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 0.375rem;
      cursor: pointer;
      font-size: 0.875rem;
      font-weight: 500;
      transition: all 0.2s;
    }

    .btn-portrait, .btn-landscape {
      background: #d1d5db;
      color: #374151;
    }

    .btn-portrait.active, .btn-landscape.active {
      background: #2563eb;
      color: white;
    }

    .btn-portrait:hover, .btn-landscape:hover {
      background: #9ca3af;
    }

    .btn-portrait.active:hover, .btn-landscape.active:hover {
      background: #1d4ed8;
    }

    .btn-clear {
      background: #fee2e2;
      color: #991b1b;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .btn-clear:hover {
      background: #fecaca;
    }

    /* Toolbar */
    .toolbar {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: flex-end;
      padding-top: 0.5rem;
    }

    .chip {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 8px 12px;
      border: 1px solid #d1d5db;
      background: #f9fafb;
      border-radius: 999px;
      color: #374151;
      font-size: 12px;
    }

    .chip span {
      font-weight: 500;
      color: #6b7280;
    }

    .chip select,
    .chip input {
      background: transparent;
      color: #111827;
      border: none;
      outline: none;
      font-size: 12px;
      width: auto;
      font-family: inherit;
    }

    .chip select {
      cursor: pointer;
    }

    .chip input {
      width: 64px;
      text-align: center;
      padding: 2px 4px;
    }

    .btn {
      padding: 10px 16px;
      border-radius: 8px;
      border: 1px solid #d1d5db;
      background: white;
      color: #374151;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.875rem;
    }

    .btn:hover {
      background: #f3f4f6;
      border-color: #9ca3af;
    }

    .btn:active {
      transform: translateY(1px);
    }

    .btn.primary {
      border-color: #2563eb;
      background: #2563eb;
      color: white;
    }

    .btn.primary:hover {
      background: #1d4ed8;
      border-color: #1d4ed8;
    }

    .btn.good {
      border-color: #10b981;
      background: #10b981;
      color: white;
    }

    .btn.good:hover {
      background: #059669;
      border-color: #059669;
    }

    /* Main Layout */
    .main {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* Sidebar */
    .sidebar {
      width: 16rem;
      background: white;
      border-right: 1px solid #e5e7eb;
      padding: 1rem;
      overflow-y: auto;
    }

    .sidebar h2 {
      font-size: 1.125rem;
      font-weight: bold;
      margin-bottom: 1rem;
      color: #111827;
    }

    .elements-grid {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .element-btn {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem;
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
      cursor: move;
      transition: all 0.2s;
      font-size: 0.875rem;
      font-weight: 500;
      color: #374151;
    }

    .element-btn:hover {
      background: #f3f4f6;
      border-color: #d1d5db;
    }

    .element-icon {
      width: 2rem;
      height: 2rem;
      border-radius: 0.375rem;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 1.125rem;
    }

    .icon-text { background: #3b82f6; }
    .icon-header { background: #a855f7; }
    .icon-image { background: #10b981; }
    .icon-table { background: #f97316; }
    .icon-columns { background: #ec4899; }
    .icon-list { background: #06b6d4; }
    .icon-margin { background: #6b7280; }
    .icon-pagebreak { background: #ef4444; }
    .icon-group { background: #8b5cf6; }

    .info-box {
      margin-top: 1.5rem;
      padding: 1rem;
      background: #dbeafe;
      border-radius: 0.5rem;
      border: 1px solid #93c5fd;
    }

    .info-box h3 {
      font-size: 0.875rem;
      font-weight: 600;
      color: #1e3a8a;
      margin-bottom: 0.5rem;
    }

    .info-box ol {
      font-size: 0.75rem;
      color: #1e40af;
      list-style-position: inside;
    }

    .info-box li {
      margin-bottom: 0.25rem;
    }

    /* Canvas */
    .canvas-area {
      flex: 1;
      background: #f3f4f6;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .canvas-tools {
      display: flex;
      gap: 10px;
      align-items: center;
      padding: 10px 12px;
      border-bottom: 1px solid #e5e7eb;
      background: white;
    }

    .zoom {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 8px 12px;
      border: 1px solid #d1d5db;
      border-radius: 999px;
      color: #6b7280;
      font-size: 12px;
      background: #f9fafb;
    }

    .zoom span:first-child {
      font-weight: 500;
      color: #374151;
    }

    .zoom input[type="range"] {
      width: 120px;
      cursor: pointer;
    }

    .zoom span:last-child {
      min-width: 40px;
      text-align: center;
      font-weight: 600;
      color: #111827;
    }

    .canvas-wrapper {
      flex: 1;
      overflow: auto;
      padding: 1.5rem;
      display: flex;
      align-items: flex-start;
      justify-content: center;
    }

    .canvas-wrapper::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    .canvas-wrapper::-webkit-scrollbar-track {
      background: #f3f4f6;
    }

    .canvas-wrapper::-webkit-scrollbar-thumb {
      background: #d1d5db;
      border-radius: 4px;
    }

    .canvas {
      background: white;
      border: 1px solid #d1d5db;
      border-radius: 0.5rem;
      padding: 2rem;
      /* width e max-width s√£o controlados dinamicamente via JavaScript (adjustCanvasSize) */
      /* Removido aspect-ratio fixo para permitir crescimento din√¢mico */
      overflow: visible;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      min-height: 842px; /* Altura m√≠nima inicial (tamanho A4 portrait) */
      min-width: 595px; /* Largura m√≠nima inicial (tamanho A4 portrait) */
      /* Altura e largura m√°ximas n√£o definidas - canvas cresce conforme necess√°rio */
      transition: border-color 0.2s, transform 0.2s;
      position: relative;
    }

    .canvas.drag-over {
      border: 4px dashed #2563eb;
    }

    .canvas-empty {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: #9ca3af;
      text-align: center;
      pointer-events: none;
      width: 100%;
    }

    .canvas-empty p:first-child {
      font-size: 1.125rem;
      margin-bottom: 0.5rem;
    }

    .canvas-empty p:last-child {
      font-size: 0.875rem;
    }

    .elements-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .element-item {
      position: relative;
      padding: 1rem;
      border: 2px solid #e5e7eb;
      border-radius: 0.375rem;
      transition: all 0.2s;
      background: white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      cursor: move;
      width: 100%;
    }

    .element-item:hover {
      border-color: #d1d5db;
    }

    .element-item.dragging {
      opacity: 0.7;
      cursor: grabbing;
    }

    .element-group {
      background: rgba(139, 92, 246, 0.05) !important;
      min-height: 200px;
      padding: 0;
      box-sizing: border-box;
      width: 100% !important;
    }

    .element-group.drag-over {
      border-color: #6366f1 !important;
      background: rgba(99, 102, 241, 0.15) !important;
    }

    /* Elemento de imagem - container invis√≠vel (j√° aplicado acima com .element-item.element-image) */
    .element-image {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: auto !important;
      margin: 0;
    }

    .element-image .element-preview {
      padding: 0 !important;
      margin: 0 !important;
      width: 100%;
      height: 100%;
      background: transparent !important;
      border: none !important;
      box-shadow: none !important;
      border-radius: 0 !important;
      min-height: 0 !important;
      min-width: 0 !important;
      line-height: 0 !important;
      font-size: 0 !important;
      color: transparent !important;
      overflow: hidden;
    }

    .group-children {
      display: flex;
      gap: 10px;
      width: 100%;     /* Sempre ocupa 100% da largura */
      height: auto;
      min-height: 120px;
      box-sizing: border-box;
      align-items: flex-start;
    }

    .group-children.orientation-row {
      flex-direction: row;
      align-items: flex-start;
      flex-wrap: nowrap;
      width: 100%;
      box-sizing: border-box;
    }

    .group-children.orientation-column {
      flex-direction: column;
      align-items: flex-start;
    }

    .group-child-item {
      padding: 0.5rem;
      border: 1px solid #d1d5db;
      border-radius: 0.5rem;
      background: white;
      position: relative;
      cursor: pointer;
      transition: all 0.2s;
      box-sizing: border-box;
    }

    .group-children.orientation-column .group-child-item {
      width: 100%;
    }

    .group-children.orientation-row .group-child-item {
      /* Largura ser√° definida inline via style baseado em child.width */
      min-width: 0; /* Permite que elementos encolham abaixo do conte√∫do m√≠nimo */
      box-sizing: border-box;
      overflow: hidden; /* Previne que conte√∫do ultrapasse o container */
    }

    .group-child-item:hover {
      border-color: #9ca3af;
    }

    .group-child-item.selected {
      border-color: #2563eb;
      background: #eff6ff;
    }

    /* Quando group-child-item cont√©m uma imagem, tornar invis√≠vel */
    .group-child-item.group-child-sem-abas {
      padding: 50 !important;
      border: none !important;
      border-radius: 0 !important;
      background: transparent !important;
      box-shadow: none !important;
      margin: 0 !important;
    }

    .group-child-item.group-child-sem-abas:hover {
      border: none !important;
      background: transparent !important;
    }

    .group-child-item.group-child-sem-abas.selected {
      border: none !important;
      background: transparent !important;
    }

    .group-placeholder {
      color: #9ca3af;
      text-align: center;
      padding: 2rem;
      width: 100%;
      border-radius: 0.75rem;
      box-sizing: border-box;
    }

    /* Bot√£o de remover removido - agora est√° no editor */

    .smallNote {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 0.5rem;
      line-height: 1.4;
    }

    .element-item:hover {
      border-color: #d1d5db;
    }

    .element-item.selected {
      border-color: #2563eb;
      background: #eff6ff;
    }

    /* Sobrescrever estilos do .element-item quando for imagem */
    .element-item.element-image {
      padding: 0 !important;
      border: none !important;
      border-radius: 0 !important;
      background: transparent !important;
      box-shadow: none !important;
      width: auto !important;
      margin: 0 !important;
      min-width: 0 !important;
      min-height: 0 !important;
      display: inline-block;
      line-height: 0 !important;
      font-size: 0 !important;
    }

    /* Quando imagem est√° em posi√ß√£o absoluta, garantir que n√£o interfira com outros elementos */
    .element-item.element-image[style*="position: absolute"],
    .element-item.element-image[style*="position:absolute"] {
      z-index: 10;
    }

    .element-item.element-image:hover {
      border: none !important;
      background: transparent !important;
      box-shadow: none !important;
    }

    .element-item.element-image.selected {
      border: none !important;
      background: transparent !important;
      box-shadow: none !important;
      outline: 2px dashed #2563eb;
      outline-offset: 2px;
    }

    /* Garantir que nenhum estilo de sele√ß√£o padr√£o seja aplicado */
    .element-item.element-image.selected::before,
    .element-item.element-image.selected::after {
      display: none !important;
    }

    .element-item.element-image.dragging {
      opacity: 0.7;
      cursor: grabbing;
    }

    .element-item {
      cursor: pointer;
    }

    .element-controls {
      position: absolute;
      top: -0.75rem;
      right: 0.5rem;
      display: none !important;
      gap: 0.25rem;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 10;
    }

    .element-btn-small {
      width: 1.75rem;
      height: 1.75rem;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 0.25rem;
      border: none;
      cursor: pointer;
      color: white;
      font-size: 0.875rem;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      padding: 0;
      z-index: 11;
      position: relative;
    }

    .btn-config {
      background: #2563eb;
    }

    .btn-config:hover {
      background: #1d4ed8;
    }

    .btn-up, .btn-down {
      background: #4b5563;
    }

    .btn-up:hover, .btn-down:hover {
      background: #374151;
    }

    .btn-remove {
      background: #ef4444;
    }

    .btn-remove:hover {
      background: #dc2626;
    }

    .element-preview {
      font-size: 0.875rem;
      color: #111827;
    }

    /* Para imagens, remover qualquer espa√ßo de texto */
    .element-image .element-preview {
      font-size: 0 !important;
      line-height: 0 !important;
      color: transparent !important;
    }

    .preview-text {
      color: #374151;
    }

    .preview-header {
      font-size: 1.25rem;
      font-weight: bold;
      text-align: center;
      color: #111827;
    }

    .preview-image {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 0 !important;
      padding: 0 !important;
      min-height: 0 !important;
      width: 100%;
      height: 100%;
      background: transparent !important;
      border: none !important;
      box-shadow: none !important;
      line-height: 0 !important;
      font-size: 0 !important;
    }

    .preview-image img {
      display: block;
      object-fit: contain;
      border-radius: 0.25rem;
      box-shadow: none;
      max-width: 100%;
      max-height: 100%;
      margin: 0;
      padding: 0;
    }

    .preview-image-box {
      background: #e5e7eb;
      border: 2px dashed #9ca3af;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #6b7280;
      font-size: 0.75rem;
    }

    /* Quando a imagem est√° dentro de um elemento-image, tornar o preview-image-box tamb√©m invis√≠vel se necess√°rio */
    .element-image .preview-image-box {
      background: transparent;
      border: 2px dashed #9ca3af;
    }

    .preview-table {
      /* width controlado dinamicamente - pode crescer al√©m de 100% se necess√°rio */
      border-collapse: collapse;
      margin: 0.5rem 0;
      /* Permitir que a tabela tenha largura natural quando necess√°rio */
      min-width: 100%;
      width: auto;
    }

    .preview-table th,
    .preview-table td {
      /* Bordas padr√£o - ser√£o sobrescritas pelo layout customizado se aplic√°vel */
      border: 1px solid #d1d5db;
      padding: 0.5rem;
      font-size: 0.75rem;
    }

    .preview-table th {
      background: #f3f4f6;
      font-weight: 600;
    }

    .preview-columns {
      display: flex;
      gap: 1rem;
      margin: 0.5rem 0;
    }

    .preview-column {
      flex: 1;
      padding: 0.5rem;
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 0.25rem;
      font-size: 0.875rem;
    }

    .preview-list {
      margin-left: 1.5rem;
      font-size: 0.875rem;
    }

    .preview-list li {
      margin-bottom: 0.25rem;
      cursor: pointer;
      transition: background-color 0.2s, border-color 0.2s;
    }
    
    .preview-list li:hover {
      background-color: #f3f4f6;
    }

    .preview-margin {
      text-align: center;
      color: #9ca3af;
      font-size: 0.875rem;
      font-style: italic;
    }

    .preview-pagebreak {
      text-align: center;
      color: #9ca3af;
      font-size: 0.875rem;
      font-style: italic;
      border-top: 2px dashed #d1d5db;
      padding-top: 0.5rem;
      margin-top: 0.5rem;
    }

    /* Code Panel */
    .code-panel {
      width: 24rem;
      background: #111827;
      color: white;
      padding: 1rem;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }

    .code-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 1rem;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .code-header h2 {
      font-size: 1.125rem;
      font-weight: bold;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 0.25rem;
      flex: 1;
    }

    .tab-btn {
      flex: 1;
      padding: 0.5rem 0.75rem;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.7);
      border-radius: 0.375rem;
      cursor: pointer;
      font-size: 0.875rem;
      transition: all 0.2s;
    }

    .tab-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.9);
    }

    .tab-btn.active {
      background: #2563eb;
      border-color: #2563eb;
      color: white;
    }

    .tab-content {
      display: none;
      flex: 1;
      overflow-y: auto;
      min-height: 0;
    }

    .tab-content.active {
      display: flex;
      flex-direction: column;
    }

    /* Inspector */
    .inspector {
      flex: 1;
      overflow-y: auto;
      padding: 0.5rem;
    }

    .inspector .muted {
      color: rgba(255, 255, 255, 0.6);
      font-size: 0.875rem;
    }

    .inspector-field {
      margin-bottom: 1rem;
    }

    .inspector-field label {
      display: block;
      font-size: 0.875rem;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.9);
      margin-bottom: 0.5rem;
    }

    .inspector-field .smallNote {
      font-size: 0.75rem;
      color: rgba(255, 255, 255, 0.6);
      margin-top: 0.25rem;
    }

    .inspector-field input,
    .inspector-field select,
    .inspector-field textarea {
      width: 100%;
      padding: 0.5rem 0.75rem;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 0.375rem;
      color: white;
      font-size: 0.875rem;
      font-family: inherit;
    }

    .inspector-field input:focus,
    .inspector-field select:focus,
    .inspector-field textarea:focus {
      outline: none;
      border-color: #2563eb;
      background: rgba(255, 255, 255, 0.15);
    }

    .inspector-field textarea {
      resize: vertical;
      min-height: 80px;
    }

    .inspector-field .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .inspector-field .row > div {
      display: flex;
      flex-direction: column;
    }

    .btn-copy {
      background: #2563eb;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      border: none;
      cursor: pointer;
      transition: background 0.2s;
      font-weight: 500;
    }

    .btn-copy:hover {
      background: #1d4ed8;
    }

    .btn-copy.copied {
      background: #16a34a;
    }

    .btn-remove-large {
      background: #ef4444;
      color: white;
      border: none;
      border-radius: 0.5rem;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s;
    }

    .btn-remove-large:hover {
      background: #dc2626;
    }

    /* Modal personalizado */
    .custom-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10000;
      align-items: center;
      justify-content: center;
    }

    .custom-modal.active {
      display: flex;
    }

    .custom-modal-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(2px);
    }

    .custom-modal-content {
      position: relative;
      background: white;
      border-radius: 0.75rem;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      max-width: 500px;
      width: 90%;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      z-index: 10001;
    }

    .custom-modal-header {
      padding: 1.5rem;
      border-bottom: 1px solid #e5e7eb;
    }

    .custom-modal-header h3 {
      margin: 0;
      font-size: 1.25rem;
      font-weight: 600;
      color: #111827;
    }

    .custom-modal-body {
      padding: 1.5rem;
      flex: 1;
      overflow-y: auto;
    }

    .custom-modal-body p {
      margin: 0;
      font-size: 1rem;
      color: #374151;
      line-height: 1.5;
    }

    .custom-modal-footer {
      padding: 1rem 1.5rem;
      border-top: 1px solid #e5e7eb;
      display: flex;
      gap: 0.75rem;
      justify-content: flex-end;
    }

    .custom-modal-btn {
      padding: 0.625rem 1.25rem;
      border-radius: 0.5rem;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      border: none;
      transition: all 0.2s;
    }

    .custom-modal-btn-cancel {
      background: #f3f4f6;
      color: #374151;
    }

    .custom-modal-btn-cancel:hover {
      background: #e5e7eb;
    }

    .custom-modal-btn-confirm {
      background: #2563eb;
      color: white;
    }

    .custom-modal-btn-confirm:hover {
      background: #1d4ed8;
    }

    /* Modal de Preview do PDF */
    .preview-modal-content {
      position: relative;
      background: white;
      border-radius: 0.75rem;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      max-width: 95%;
      width: 95%;
      max-height: 95vh;
      height: 95vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      z-index: 10001;
    }

    .preview-modal-header {
      padding: 1.5rem;
      border-bottom: 1px solid #e5e7eb;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
    }

    .preview-modal-header h3 {
      margin: 0;
      font-size: 1.25rem;
      font-weight: 600;
      color: #111827;
    }

    .preview-modal-close {
      background: #f3f4f6;
      color: #374151;
      border: none;
      border-radius: 0.5rem;
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .preview-modal-close:hover {
      background: #e5e7eb;
    }

    .preview-modal-body {
      flex: 1;
      overflow: hidden;
      position: relative;
      padding: 0;
    }

    .preview-modal-iframe {
      width: 100%;
      height: 100%;
      border: none;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }

    .code-editor {
      flex: 1;
      background: #1f2937;
      border-radius: 0.375rem;
      padding: 1rem;
      overflow: auto;
      margin-bottom: 1rem;
      font-family: 'Courier New', monospace;
      font-size: 0.75rem;
      line-height: 1.5;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .code-instructions {
      background: #1f2937;
      border-radius: 0.375rem;
      padding: 0.75rem;
      font-size: 0.75rem;
    }

    .code-instructions p {
      color: #9ca3af;
      margin-bottom: 0.5rem;
    }

    .code-instructions ol {
      list-style-position: inside;
      color: #d1d5db;
    }

    .code-instructions li {
      margin-bottom: 0.25rem;
    }

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 50;
      align-items: center;
      justify-content: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: white;
      border-radius: 0.5rem;
      box-shadow: 0 20px 25px rgba(0, 0, 0, 0.15);
      width: 100%;
      max-width: 28rem;
      max-height: 80vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem;
      border-bottom: 1px solid #e5e7eb;
    }

    .modal-header h3 {
      font-size: 1.125rem;
      font-weight: 600;
    }

    .btn-close {
      background: none;
      border: none;
      color: #6b7280;
      cursor: pointer;
      font-size: 1.25rem;
      padding: 0;
      width: auto;
      height: auto;
    }

    .btn-close:hover {
      color: #374151;
    }

    .modal-body {
      padding: 1rem;
      overflow-y: auto;
      flex: 1;
    }

    .form-group {
      margin-bottom: 1rem;
    }

    .form-group label {
      display: block;
      font-size: 0.875rem;
      font-weight: 500;
      margin-bottom: 0.25rem;
      color: #374151;
    }

    .form-group input,
    .form-group select,
    .form-group textarea {
      width: 100%;
      padding: 0.5rem 0.75rem;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
      font-size: 0.875rem;
      font-family: inherit;
    }

    .form-group textarea {
      resize: vertical;
      min-height: 100px;
    }

    .form-group input:focus,
    .form-group select:focus,
    .form-group textarea:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
    }

    .checkbox-group {
      display: flex;
      gap: 1rem;
      margin-top: 0.5rem;
    }

    .checkbox-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .checkbox-item input[type="checkbox"] {
      width: auto;
      margin: 0;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
    }

    .image-preview-container {
      margin-top: 1rem;
      padding: 1rem;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
      background: #f9fafb;
      text-align: center;
    }

    .image-preview-container img {
      max-width: 100%;
      max-height: 200px;
      border-radius: 0.25rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .image-preview-container .no-preview {
      color: #9ca3af;
      font-size: 0.875rem;
      padding: 2rem;
    }

    .file-input-wrapper {
      position: relative;
      display: inline-block;
      width: 100%;
    }

    .file-input-wrapper input[type="file"] {
      width: 100%;
      padding: 0.5rem 0.75rem;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
      font-size: 0.875rem;
      cursor: pointer;
    }

    .file-input-wrapper input[type="file"]:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
    }

    .divider-text {
      text-align: center;
      margin: 1rem 0;
      color: #9ca3af;
      font-size: 0.75rem;
      position: relative;
    }

    .divider-text::before,
    .divider-text::after {
      content: '';
      position: absolute;
      top: 50%;
      width: 40%;
      height: 1px;
      background: #e5e7eb;
    }

    .divider-text::before {
      left: 0;
    }

    .divider-text::after {
      right: 0;
    }

    .modal-footer {
      padding: 1rem;
      border-top: 1px solid #e5e7eb;
      display: flex;
      justify-content: flex-end;
    }

    .btn-apply {
      background: #2563eb;
      color: white;
      padding: 0.5rem 1rem;
    }

    .btn-apply:hover {
      background: #1d4ed8;
    }

    /* Utilities */
    .flex-center {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: #f3f4f6;
    }

    ::-webkit-scrollbar-thumb {
      background: #d1d5db;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #9ca3af;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <div class="header-top">
        <div class="header-left">
          <div style="font-size: 1.5rem;">üìÑ</div>
          <div>
            <h1>Editor Visual</h1>
            <p>Crie PDFs de forma visual e intuitiva</p>
          </div>
        </div>
        <div class="toolbar">
            <div class="chip">
              <span>Formato</span>
              <select id="pageSize">
                <option value="A4" selected>A4</option>
                <option value="A3">A3</option>
                <option value="A5">A5</option>
                <option value="LETTER">LETTER</option>
                <option value="LEGAL">LEGAL</option>
                <option value="TABLOID">TABLOID</option>
              </select>
            </div>
    
            <div class="chip">
              <span>Orienta√ß√£o</span>
              <select id="orientation">
                <option value="portrait" selected>Retrato</option>
                <option value="landscape">Paisagem</option>
              </select>
            </div>
    
            <div class="chip" title="pageMargins: [left, top, right, bottom]">
              <span>Margens</span>
              <input id="mL" type="number" value="40" min="0" />
              <input id="mT" type="number" value="60" min="0" />
              <input id="mR" type="number" value="40" min="0" />
              <input id="mB" type="number" value="60" min="0" />
            </div>
    
            <button class="btn primary" id="previewBtn">Pr√©-visualizar PDF</button>
            <button class="btn primary" id="bubbleTestBtn">Teste Bubble</button>
            <button class="btn" id="clearBtn">Limpar</button>
          </div>
      </div>
    </div>

    <!-- Main Content -->
    <div class="main">
      <!-- Sidebar -->
      <div class="sidebar">
        <h2>Container</h2>
        <div class="elements-grid">
          <div class="element-btn" draggable="true" ondragstart="startDrag('group', event)">
            <div class="element-icon icon-group">‚äû</div>
            <span>Grupo</span>
          </div>

          <div class="element-btn" draggable="true" ondragstart="startDrag('table', event)">
            <div class="element-icon icon-table">‚äû</div>
            <span>Tabela</span>
          </div>
          <div class="element-btn" draggable="true" ondragstart="startDrag('columns', event)">
            <div class="element-icon icon-columns">‚àø</div>
            <span>Colunas</span>
          </div>
          <div class="element-btn" draggable="true" ondragstart="startDrag('list', event)">
            <div class="element-icon icon-list">‚â°</div>
            <span>Lista</span>
          </div>
        </div>

        <h2 style="margin-top: 2rem;">Elementos</h2>
        <div class="elements-grid">
          <div class="element-btn" draggable="true" ondragstart="startDrag('header', event)">
            <div class="element-icon icon-header">H</div>
            <span>Cabe√ßalho</span>
          </div>
          <div class="element-btn" draggable="true" ondragstart="startDrag('text', event)">
            <div class="element-icon icon-text">T</div>
            <span>Texto</span>
          </div>
          <div class="element-btn" draggable="true" ondragstart="startDrag('image', event)">
            <div class="element-icon icon-image">üñº</div>
            <span>Imagem</span>
          </div>
          <div class="element-btn" draggable="true" ondragstart="startDrag('margin', event)">
            <div class="element-icon icon-margin">‚ñ¶</div>
            <span>Espa√ßo</span>
          </div>
          <div class="element-btn" draggable="true" ondragstart="startDrag('pageBreak', event)">
            <div class="element-icon icon-pagebreak">‚úÇ</div>
            <span>Quebra P√°gina</span>
          </div>
          <div class="element-btn" draggable="true" ondragstart="startDrag('qr', event)">
            <div class="element-icon icon-qr">üì±</div>
            <span>QR Code</span>
          </div>
          <div class="element-btn" draggable="true" ondragstart="startDrag('svg', event)">
            <div class="element-icon icon-svg">üé®</div>
            <span>SVG</span>
          </div>
        </div>

        <div class="info-box">
          <h3>Como usar:</h3>
          <ol>
            <li>Arraste os elementos</li>
            <li>Configure as propriedades</li>
            <li>Copie e use</li>
          </ol>
        </div>
      </div>

      <!-- Canvas -->
      <div class="canvas-area">
        <div class="canvas-tools">
          <div class="zoom">
            <span>Zoom</span>
            <input id="zoomRange" type="range" min="55" max="140" value="100" />
            <span id="zoomLabel">100%</span>
          </div>
        </div>
        <div class="canvas-wrapper">
          <div class="canvas" id="canvas" ondrop="handleDrop(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
            <div class="canvas-empty" id="canvasEmpty">
              <div>
                <p>Arraste um grupo aqui</p>
                <p>para come√ßar a criar seu PDF</p>
              </div>
            </div>
            <div class="elements-list" id="elementsList" style="display: none;"></div>
          </div>
        </div>
      </div>

      <!-- Code Panel -->
      <div class="code-panel">
        <div class="code-header">
          <div class="tabs">
            <button class="tab-btn active" id="tabEditor" onclick="switchTab('editor')">‚öôÔ∏è Editor</button>
            <button class="tab-btn" id="tabPage" onclick="switchTab('page')">üìÑ P√°gina</button>
            <button class="tab-btn" id="tabCode" onclick="switchTab('code')">üíª C√≥digo</button>
          </div>
        </div>
        
        <!-- Editor Tab -->
        <div class="tab-content active" id="tabContentEditor">
          <div class="inspector" id="inspector">
            <div class="muted" style="padding: 1rem; text-align: center;">
              Selecione um elemento no canvas para editar suas propriedades.
            </div>
          </div>
        </div>
        
        <!-- Page Tab (combines TOC, Header/Footer, and Watermark) -->
        <div class="tab-content" id="tabContentPage">
          <div class="inspector" id="pageInspector" style="padding: 1rem;">
            <!-- Ser√° preenchido dinamicamente pela fun√ß√£o renderPageInspector -->
          </div>
        </div>
        
        <!-- Code Tab -->
        <div class="tab-content" id="tabContentCode">
          <div style="padding: 1rem; border-bottom: 1px solid #e5e7eb;">
            <button class="btn-copy" id="copyBtn" onclick="copyCode()" style="width: 100%; padding: 0.75rem 1rem; font-size: 1rem; border-radius: 0.5rem;">üìã Copiar</button>
        </div>
        <div class="code-editor" id="codeEditor">// Adicione elementos para gerar o c√≥digo</div>
        <div class="code-instructions">
          <p>Para usar este c√≥digo:</p>
          <ol>
            <li>Copie o c√≥digo acima</li>
            <li>Cole em seu projeto</li>
            <li>Execute para gerar</li>
          </ol>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal -->
  <div class="modal" id="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Configurar Elemento</h3>
        <button class="btn-close" onclick="closeModal()">‚úï</button>
      </div>
      <div class="modal-body" id="modalBody"></div>
      <div class="modal-footer">
        <button class="btn-apply" onclick="closeModal()">Aplicar</button>
      </div>
    </div>
  </div>


  <script>
    /****************************************************
     * PDFMake Visual Editor (Nested containers)
     * - Mant√©m o layout do gerador_atualizado.html
     * - Adiciona suporte a "elementos dentro de elementos"
     *   (Group / Columns / List / Table) como no index.html
     ****************************************************/

    // -----------------------
    // State
    // -----------------------
    let draggedType = null;

    // Estrutura em √°rvore:
    // elements = [ rootGroup ]
    let elements = [];
    let selectedElementId = null;

    let orientation = 'portrait';
    let pageSize = 'A4';
    let pageMargins = [40, 60, 40, 60];
    let zoom = 0.95;
    // IMPORTANTE: use a origem exata do Bubble
    const BUBBLE_ORIGIN = "https://mentions-20237.bubbleapps.io";
    
    // Headers & Footers - Agora como containers visuais no canvas
    let documentHeader = {
      enabled: false,
      root: null, // Container group com children (como elements)
      height: 60 // Altura estimada para c√°lculo de margins
    };
    let documentFooter = {
      enabled: false,
      root: null, // Container group com children (como elements)
      height: 60 // Altura estimada para c√°lculo de margins
    };
    
    // Watermark (apenas texto - PDFMake n√£o suporta imagens)
    let documentWatermark = null; // { text: '', fontSize: 48, color: '#cccccc', opacity: 0.3, angle: -45 }
    
    // TOC (Table of Contents)
    let documentTOC = null; // { title: '√çndice', titleStyle: {}, itemStyle: {}, textStyle: {}, numberStyle: {} }
    
    // Security
    let documentSecurity = null; // { userPassword: '', ownerPassword: '', permissions: { printing: true, modifying: true, copying: true, annotating: true } }
    
    // Page Info (Metadados) e Compress
    let documentPageInfo = null; // { author: '', title: '', subject: '', keywords: '' }
    let documentCompress = false; // true/false
    
    // -----------------------
    // LocalStorage - Auto-save
    // -----------------------
    const STORAGE_KEY = 'pdfmake_editor_state';
    const STORAGE_CODE_KEY = 'pdfmake_editor_code';
    
    // Salvar estado completo no localStorage
    // Fun√ß√£o para remover propriedades internas (como _base64Preview) antes de salvar
    function cleanElementsForStorage(elements) {
      if (!elements || !Array.isArray(elements)) return elements;
      
      return elements.map(el => {
        const cleaned = { ...el };
        if (cleaned.properties) {
          cleaned.properties = { ...cleaned.properties };
          // Remover _base64Preview (apenas para preview visual)
          delete cleaned.properties._base64Preview;
          
          // Limpar recursivamente se houver children
          if (cleaned.properties.children && Array.isArray(cleaned.properties.children)) {
            cleaned.properties.children = cleanElementsForStorage(cleaned.properties.children);
          }
          
          // Limpar recursivamente se houver columns
          if (cleaned.properties.columns && Array.isArray(cleaned.properties.columns)) {
            cleaned.properties.columns = cleaned.properties.columns.map(col => {
              if (col.children && Array.isArray(col.children)) {
                return { ...col, children: cleanElementsForStorage(col.children) };
              }
              return col;
            });
          }
          
          // Limpar recursivamente se houver items (listas)
          if (cleaned.properties.items && Array.isArray(cleaned.properties.items)) {
            cleaned.properties.items = cleaned.properties.items.map(item => {
              if (item.kind === 'node' && item.node) {
                return { ...item, node: cleanElementsForStorage([item.node])[0] };
              }
              return item;
            });
          }
          
          // Limpar recursivamente se houver body (tabelas)
          if (cleaned.properties.body && Array.isArray(cleaned.properties.body)) {
            cleaned.properties.body = cleaned.properties.body.map(row => {
              return row.map(cell => {
                if (cell && cell.children && Array.isArray(cell.children)) {
                  return { ...cell, children: cleanElementsForStorage(cell.children) };
                }
                return cell;
              });
            });
          }
        }
        return cleaned;
      });
    }
    
    function saveState() {
      try {
        // Limpar elementos removendo propriedades internas antes de salvar
        const cleanedElements = cleanElementsForStorage(elements);
        
        const state = {
          elements: cleanedElements,
          selectedElementId: selectedElementId,
          orientation: orientation,
          pageSize: pageSize,
          pageMargins: pageMargins,
          zoom: zoom,
          documentHeader: documentHeader,
          documentFooter: documentFooter,
          documentWatermark: documentWatermark,
          documentTOC: documentTOC,
          documentSecurity: documentSecurity,
          documentPageInfo: documentPageInfo,
          documentCompress: documentCompress,
          timestamp: Date.now()
        };
        
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        
        // Salvar tamb√©m o c√≥digo gerado
        if (codeEditor && codeEditor.textContent) {
          localStorage.setItem(STORAGE_CODE_KEY, codeEditor.textContent);
        }
      } catch (e) {
        console.warn('Erro ao salvar estado no localStorage:', e);
      }
    }
    
    // Carregar estado do localStorage
    function loadState() {
      try {
        const savedState = localStorage.getItem(STORAGE_KEY);
        if (!savedState) return false;
        
        const state = JSON.parse(savedState);
        
        // Verificar se o estado foi limpo (elementos vazios)
        if (!state.elements || !Array.isArray(state.elements) || state.elements.length === 0) {
          // Se elementos est√£o vazios, limpar estado salvo e n√£o carregar
          clearSavedState();
          return false;
        }
        
        // Restaurar elementos (deep clone para evitar refer√™ncias compartilhadas)
        elements = deepClone(state.elements);
        
        // Restaurar configura√ß√µes globais
        if (state.selectedElementId) selectedElementId = state.selectedElementId;
        else selectedElementId = null;
        if (state.orientation) orientation = state.orientation;
        if (state.pageSize) pageSize = state.pageSize;
        if (state.pageMargins) pageMargins = state.pageMargins;
        if (state.zoom !== undefined) zoom = state.zoom;
        
        // Restaurar header/footer
        if (state.documentHeader) {
          documentHeader = state.documentHeader;
          // Garantir que root existe
          if (!documentHeader.root) {
            documentHeader.root = createHeaderFooterRoot();
          }
          // Se enabled mas n√£o tem children, desabilitar
          if (documentHeader.enabled && (!documentHeader.root.properties.children || documentHeader.root.properties.children.length === 0)) {
            documentHeader.enabled = false;
          }
        }
        if (state.documentFooter) {
          documentFooter = state.documentFooter;
          // Garantir que root existe
          if (!documentFooter.root) {
            documentFooter.root = createHeaderFooterRoot();
          }
          // Se enabled mas n√£o tem children, desabilitar
          if (documentFooter.enabled && (!documentFooter.root.properties.children || documentFooter.root.properties.children.length === 0)) {
            documentFooter.enabled = false;
          }
        }
        
        // Restaurar watermark
        if (state.documentWatermark) documentWatermark = state.documentWatermark;
        
        // Restaurar TOC
        if (state.documentTOC) documentTOC = state.documentTOC;
        
        // Restaurar Security
        if (state.documentSecurity) documentSecurity = state.documentSecurity;
        
        // Restaurar Page Info
        if (state.documentPageInfo) documentPageInfo = state.documentPageInfo;
        
        // Restaurar Compress
        if (state.documentCompress !== undefined) documentCompress = state.documentCompress;
        
        // Restaurar valores nos inputs do DOM
        if (pageSizeSel && state.pageSize) pageSizeSel.value = state.pageSize;
        if (orientationSel && state.orientation) orientationSel.value = state.orientation;
        if (mL && state.pageMargins) mL.value = state.pageMargins[0];
        if (mT && state.pageMargins) mT.value = state.pageMargins[1];
        if (mR && state.pageMargins) mR.value = state.pageMargins[2];
        if (mB && state.pageMargins) mB.value = state.pageMargins[3];
        if (zoomRange && state.zoom !== undefined) {
          zoomRange.value = Math.round(state.zoom * 100);
          if (zoomLabel) zoomLabel.textContent = Math.round(state.zoom * 100) + '%';
        }
        
        return true;
      } catch (e) {
        console.warn('Erro ao carregar estado do localStorage:', e);
        return false;
      }
    }
    
    // Limpar estado salvo
    function clearSavedState() {
      try {
        localStorage.removeItem(STORAGE_KEY);
        localStorage.removeItem(STORAGE_CODE_KEY);
      } catch (e) {
        console.warn('Erro ao limpar estado do localStorage:', e);
      }
    }

    // Get DOM elements
    const pageSizeSel = document.getElementById("pageSize");
    const orientationSel = document.getElementById("orientation");
    const mL = document.getElementById("mL");
    const mT = document.getElementById("mT");
    const mR = document.getElementById("mR");
    const mB = document.getElementById("mB");
    const zoomRange = document.getElementById("zoomRange");
    const zoomLabel = document.getElementById("zoomLabel");
    const previewBtn = document.getElementById("previewBtn");
    const bubbleTestBtn = document.getElementById("bubbleTestBtn");
    const clearBtn = document.getElementById("clearBtn");
    const canvas = document.getElementById("canvas");
    const canvasEmpty = document.getElementById("canvasEmpty");
    const elementsList = document.getElementById("elementsList");

    // Code panel
    const codeEditor = document.getElementById("codeEditor");
    const copyBtn = document.getElementById("copyBtn");
    const inspector = document.getElementById("inspector");

    // -----------------------
    // Helpers
    // -----------------------
    const uid = () => "id_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
    
    // Fun√ß√£o para criar root container de header/footer
    function createHeaderFooterRoot() {
      return {
        id: uid(),
        type: 'group',
        properties: {
          orientation: 'row',
          children: []
        },
        _ui: {}
      };
    }
    
    // Inicializar roots de header/footer se n√£o existirem
    if (!documentHeader.root) {
      documentHeader.root = createHeaderFooterRoot();
    }
    if (!documentFooter.root) {
      documentFooter.root = createHeaderFooterRoot();
    }
    
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }

    function clamp(n, a, b) {
      return Math.max(a, Math.min(b, n));
    }

    function getRootGroup() {
      return elements.find(e => e.type === 'group') || null;
    }

    function isContainerType(type) {
      return ['group', 'columns', 'list', 'table'].includes(type);
    }

    function defaultElement(type) {
      const id = uid();
      const base = { id, type, properties: {}, _ui: {} };

      if (type === 'group') {
        return {
          ...base,
          properties: {
            orientation: 'column', // no editor visual (layout)
            gap: 10,
            children: []
          }
        };
      }

      if (type === 'header') {
        return {
          ...base,
          properties: {
            text: 'Cabe√ßalho',
            fontSize: 18,
            bold: true,
            alignment: 'center',
            margin: [0, 0, 0, 10]
          }
        };
      }

      if (type === 'text') {
        return {
          ...base,
          properties: {
            text: 'Texto...',
            fontSize: 14,
            alignment: 'left',
            margin: [0, 0, 0, 10]
          }
        };
      }

      if (type === 'image') {
        return {
          ...base,
          properties: {
            url: '',
            width: 200,
            height: 150,
            margin: [0, 0, 0, 10]
          }
        };
      }

      if (type === 'columns') {
        const count = 3;
        return {
          ...base,
          properties: {
            columnsCount: count,
            gap: 10,
            // cada coluna tem children
            columns: Array.from({ length: count }).map(() => ({ width: '*', children: [] })),
            margin: [0, 0, 0, 10]
          }
        };
      }

      if (type === 'list') {
        return {
          ...base,
          properties: {
            listType: 'ul', // ul|ol
            // items: array de {kind:'text', text} OU {kind:'node', node:<element>}
            items: [
              { kind: 'text', text: 'Item 1' },
              { kind: 'text', text: 'Item 2' }
            ],
            margin: [0, 0, 0, 10]
          }
        };
      }

      if (type === 'table') {
        const rows = 2, cols = 2; // 1 linha de header + 1 linha de dados
        return {
          ...base,
          properties: {
            widths: Array.from({ length: cols }).map(() => '*'),
            body: Array.from({ length: rows }).map((_, rowIdx) =>
              Array.from({ length: cols }).map(() => ({ children: [] }))
            ),
            layout: 'custom', // Layout customizado por padr√£o para ter controle total
            customLayout: {
              // Linhas horizontais habilitadas por padr√£o
              hLineWidth: 1,
              hLineColor: '#000000',
              // Linhas verticais habilitadas por padr√£o
              vLineWidth: 1,
              vLineColor: '#000000',
              // Padding padr√£o
              paddingLeft: 5,
              paddingRight: 5,
              paddingTop: 5,
              paddingBottom: 5
            },
            margin: [0, 0, 0, 10]
          }
        };
      }

      if (type === 'margin') {
        return { ...base, properties: { size: 20 } };
      }

      if (type === 'pageBreak') {
        return { ...base, properties: {} };
      }

      if (type === 'qr') {
        return {
          ...base,
          properties: {
            text: 'https://exemplo.com',
            fit: 100,
            eccLevel: 'M',
            foreground: '#000000',
            background: '#ffffff',
            alignment: 'center',
            margin: [0, 0, 0, 10]
          }
        };
      }

      if (type === 'svg') {
      return {
          ...base,
          properties: {
            svg: '<svg width="100" height="100"><circle cx="50" cy="50" r="40" fill="blue"/></svg>',
            width: 100,
            height: 100,
            color: '#000000',
            alignment: 'center',
            margin: [0, 0, 0, 10]
          }
        };
      }

      return base;
    }

    // -----------------------
    // Tree traversal
    // -----------------------
    function walk(node, fn) {
      if (!node) return;
      fn(node);

      if (node.type === 'group') {
        (node.properties.children || []).forEach(ch => walk(ch, fn));
      }

      if (node.type === 'columns') {
        (node.properties.columns || []).forEach(col => (col.children || []).forEach(ch => walk(ch, fn)));
      }

      if (node.type === 'list') {
        (node.properties.items || []).forEach(it => {
          if (it && it.kind === 'node' && it.node) walk(it.node, fn);
        });
      }

      if (node.type === 'table') {
        (node.properties.body || []).forEach(row => row.forEach(cell => (cell.children || []).forEach(ch => walk(ch, fn))));
      }
    }

    function findNodeById(id) {
      // Verificar header/footer primeiro
      if (documentHeader.root && documentHeader.root.id === id) return documentHeader.root;
      if (documentFooter.root && documentFooter.root.id === id) return documentFooter.root;
      
      // Verificar filhos do header
      if (documentHeader.root) {
        let found = null;
        walk(documentHeader.root, (n) => {
          if (n.id === id) found = n;
        });
        if (found) return found;
      }
      
      // Verificar filhos do footer
      if (documentFooter.root) {
        let found = null;
        walk(documentFooter.root, (n) => {
          if (n.id === id) found = n;
        });
        if (found) return found;
      }
      
      // Verificar conte√∫do principal
      const root = getRootGroup();
      if (!root) return null;
      let found = null;
      walk(root, (n) => {
        if (n.id === id) found = n;
      });
      return found;
    }

    // Retorna: { node, parent, ctx }
    // ctx descreve onde o node vive no parent:
    // - { kind:'groupChildren', index }
    // - { kind:'columns', colIndex, index }
    // - { kind:'listItems', index }
    // - { kind:'tableCell', row, col, index }
    function findNodeWithParent(id) {
      function rec(node, parent) {
        if (!node) return null;

        // group children
        if (node.type === 'group') {
          const arr = node.properties.children || [];
          for (let i = 0; i < arr.length; i++) {
            const ch = arr[i];
            if (ch.id === id) return { node: ch, parent: node, ctx: { kind: 'groupChildren', index: i } };
            const r = rec(ch, node);
            if (r) return r;
          }
        }

        // columns
        if (node.type === 'columns') {
          const cols = node.properties.columns || [];
          for (let c = 0; c < cols.length; c++) {
            const children = cols[c].children || [];
            for (let i = 0; i < children.length; i++) {
              const ch = children[i];
              if (ch.id === id) return { node: ch, parent: node, ctx: { kind: 'columns', colIndex: c, index: i } };
              const r = rec(ch, node);
              if (r) return r;
            }
          }
        }

        // list
        if (node.type === 'list') {
          const items = node.properties.items || [];
          for (let i = 0; i < items.length; i++) {
            const it = items[i];
            if (it && it.kind === 'node' && it.node) {
              if (it.node.id === id) return { node: it.node, parent: node, ctx: { kind: 'listItems', index: i } };
              const r = rec(it.node, node);
              if (r) return r;
            }
          }
        }

        // table
        if (node.type === 'table') {
          const body = node.properties.body || [];
          for (let r = 0; r < body.length; r++) {
            for (let c = 0; c < body[r].length; c++) {
              const cell = body[r][c];
              const children = (cell && cell.children) ? cell.children : [];
              for (let i = 0; i < children.length; i++) {
                const ch = children[i];
                if (ch.id === id) return { node: ch, parent: node, ctx: { kind: 'tableCell', row: r, col: c, index: i } };
                const rr = rec(ch, node);
                if (rr) return rr;
              }
            }
          }
        }
        
        return null;
      }
      
      // Verificar header
      if (documentHeader.root) {
        if (documentHeader.root.id === id) {
          return { node: documentHeader.root, parent: null, ctx: { kind: 'headerRoot' } };
        }
        const headerResult = rec(documentHeader.root, null);
        if (headerResult) return headerResult;
      }
      
      // Verificar footer
      if (documentFooter.root) {
        if (documentFooter.root.id === id) {
          return { node: documentFooter.root, parent: null, ctx: { kind: 'footerRoot' } };
        }
        const footerResult = rec(documentFooter.root, null);
        if (footerResult) return footerResult;
      }
      
      // Verificar conte√∫do principal
      const root = getRootGroup();
      if (!root) return null;
      if (root.id === id) return { node: root, parent: null, ctx: null };
      
      return rec(root, null);
    }

    function deleteSelected() {
      if (!selectedElementId) return;
      resetCanvasSizeCache(); // Resetar cache quando conte√∫do muda
      const info = findNodeWithParent(selectedElementId);
      if (!info || !info.parent) {
        // N√£o deleta root do header/footer nem root principal
        if (info && (info.ctx?.kind === 'headerRoot' || info.ctx?.kind === 'footerRoot')) {
          return;
        }
        return;
      }

      const { parent, ctx } = info;
      if (!ctx) return;

      if (ctx.kind === 'groupChildren') {
        parent.properties.children.splice(ctx.index, 1);
      } else if (ctx.kind === 'columns') {
        parent.properties.columns[ctx.colIndex].children.splice(ctx.index, 1);
      } else if (ctx.kind === 'listItems') {
        parent.properties.items.splice(ctx.index, 1);
      } else if (ctx.kind === 'tableCell') {
        parent.properties.body[ctx.row][ctx.col].children.splice(ctx.index, 1);
      }

      selectedElementId = parent.id;
      renderAll();
      saveState();
    }

    function moveNodeUpDown(nodeId, dir) {
      const info = findNodeWithParent(nodeId);
      if (!info || !info.parent || !info.ctx) return;
      const ctx = info.ctx;

      function swap(arr, i, j) {
        if (i < 0 || j < 0 || i >= arr.length || j >= arr.length) return;
        const tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }

      if (ctx.kind === 'groupChildren') {
        swap(info.parent.properties.children, ctx.index, ctx.index + dir);
      } else if (ctx.kind === 'columns') {
        swap(info.parent.properties.columns[ctx.colIndex].children, ctx.index, ctx.index + dir);
      } else if (ctx.kind === 'listItems') {
        swap(info.parent.properties.items, ctx.index, ctx.index + dir);
      } else if (ctx.kind === 'tableCell') {
        swap(info.parent.properties.body[ctx.row][ctx.col].children, ctx.index, ctx.index + dir);
      }

      renderAll();
    }

    // -----------------------
    // Drag and Drop
    // -----------------------
    // Fun√ß√µes de drag-and-drop - devem estar dispon√≠veis globalmente ANTES do HTML
    // Definir imediatamente no window para garantir disponibilidade
    window.startDrag = function(type, event) {
      if (typeof draggedType !== 'undefined') {
        draggedType = type;
      }
      if (event && event.dataTransfer) {
        event.dataTransfer.setData("text/plain", type);
        event.dataTransfer.effectAllowed = "move";
      }
    };

    window.handleDragOver = function(e) {
      e.preventDefault();
      e.stopPropagation();
      const canvasEl = document.getElementById("canvas");
      if (canvasEl) canvasEl.classList.add('drag-over');
    };

    window.handleDragLeave = function(e) {
      const canvasEl = document.getElementById("canvas");
      if (canvasEl && e.target === canvasEl) canvasEl.classList.remove('drag-over');
    };
    
    // Manter refer√™ncias locais tamb√©m
    function startDrag(type, event) {
      window.startDrag(type, event);
    }
    
    function handleDragOver(e) {
      window.handleDragOver(e);
    }
    
    function handleDragLeave(e) {
      window.handleDragLeave(e);
    }

    function handleDrop(e) {
      e.preventDefault();
      e.stopPropagation();
      if (canvas) canvas.classList.remove('drag-over');

      const type = (e.dataTransfer && e.dataTransfer.getData("text/plain")) || draggedType;
      if (!type) return;

      // Primeiro elemento TEM que ser group, como antes
      if (!getRootGroup()) {
        if (type !== 'group') return;
        resetCanvasSizeCache(); // Resetar cache quando conte√∫do muda
        const g = defaultElement('group');
        elements = [g];
        selectedElementId = g.id;
        renderAll();
          return;
        }

      // Se caiu no canvas (fora de qualquer dropzone), insere no group root
      insertIntoTarget({ kind: 'groupChildren', targetId: getRootGroup().id }, type);
    }
    window.handleDrop = handleDrop;

    function insertIntoTarget(target, type) {
      resetCanvasSizeCache(); // Resetar cache quando conte√∫do muda
      const root = getRootGroup();
      const newEl = defaultElement(type);

      // Verificar se √© header ou footer
      if (target.targetId === documentHeader.root?.id) {
        if (!documentHeader.root.properties.children) {
          documentHeader.root.properties.children = [];
        }
        documentHeader.root.properties.children.push(newEl);
        selectedElementId = newEl.id;
        renderAll();
        saveState();
          return;
        }
      
      if (target.targetId === documentFooter.root?.id) {
        if (!documentFooter.root.properties.children) {
          documentFooter.root.properties.children = [];
        }
        documentFooter.root.properties.children.push(newEl);
        selectedElementId = newEl.id;
        renderAll();
        saveState();
        return;
      }

      // Regras: se target for um elemento n√£o-container, tenta usar o pai dele como container
      // Aqui target j√° vem como "dropzone" de container, ent√£o √© seguro.
      if (!root) return;

      if (target.kind === 'groupChildren') {
        const group = findNodeById(target.targetId);
        if (!group || group.type !== 'group') return;
        group.properties.children.push(newEl);
        selectedElementId = newEl.id;
      }

      if (target.kind === 'columnsCol') {
        const columnsNode = findNodeById(target.targetId);
        if (!columnsNode || columnsNode.type !== 'columns') return;
        const colIndex = clamp(Number(target.colIndex || 0), 0, (columnsNode.properties.columns || []).length - 1);
        columnsNode.properties.columns[colIndex].children.push(newEl);
        selectedElementId = newEl.id;
      }

      if (target.kind === 'listItems') {
        // Adicionar novo item √† lista (quando solto no container, n√£o em um item espec√≠fico)
        const listNode = findNodeById(target.targetId);
        if (!listNode || listNode.type !== 'list') return;
        listNode.properties.items.push({ kind: 'node', node: newEl });
        selectedElementId = newEl.id;
      }

      if (target.kind === 'listItemReplace') {
        // Substituir item existente na lista (quando solto em um item espec√≠fico)
        const listNode = findNodeById(target.targetId);
        if (!listNode || listNode.type !== 'list') return;
        const itemIndex = target.itemIndex !== undefined ? Number(target.itemIndex) : -1;
        if (itemIndex >= 0 && itemIndex < listNode.properties.items.length) {
          // Substituir o item existente
          listNode.properties.items[itemIndex] = { kind: 'node', node: newEl };
          selectedElementId = newEl.id;
      } else {
          // Fallback: adicionar novo item se √≠ndice inv√°lido
          listNode.properties.items.push({ kind: 'node', node: newEl });
          selectedElementId = newEl.id;
        }
      }

      if (target.kind === 'tableCell') {
        const tableNode = findNodeById(target.targetId);
        if (!tableNode || tableNode.type !== 'table') return;
        const r = clamp(Number(target.row || 0), 0, (tableNode.properties.body || []).length - 1);
        const c = clamp(Number(target.col || 0), 0, (tableNode.properties.body[r] || []).length - 1);
        tableNode.properties.body[r][c].children.push(newEl);
        selectedElementId = newEl.id;
      }

      renderAll();
    }

    // dropzone handlers (delega√ß√£o)
    function onDropZoneOver(e) {
      e.preventDefault();
      e.stopPropagation();
      const dz = e.currentTarget;
      dz.classList.add('drag-over');
    }
    function onDropZoneLeave(e) {
      e.preventDefault();
      const dz = e.currentTarget;
      dz.classList.remove('drag-over');
    }
    function onDropZoneDrop(e) {
      e.preventDefault();
      e.stopPropagation();
      const dz = e.currentTarget;
      dz.classList.remove('drag-over');
      
      // Remover feedback visual se for um item de lista
      if (dz.tagName === 'LI' && dz.style.backgroundColor) {
        dz.style.backgroundColor = '';
        dz.style.borderColor = '#9ca3af';
      }

      const type = (e.dataTransfer && e.dataTransfer.getData("text/plain")) || draggedType;
      if (!type) return;

      const kind = dz.getAttribute('data-drop-kind');
      const targetId = dz.getAttribute('data-target-id');
      const colIndex = dz.getAttribute('data-col-index');
      const row = dz.getAttribute('data-row');
      const col = dz.getAttribute('data-col');
      const itemIndex = dz.getAttribute('data-item-index'); // Para substituir item de lista

      insertIntoTarget({ kind, targetId, colIndex, row, col, itemIndex }, type);
    }

    // -----------------------
    // Rendering
    // -----------------------
    
    // Fun√ß√£o para converter URL de imagem para base64 (apenas para preview visual)
    async function convertImageUrlToBase64(url) {
      try {
        // Se j√° for base64, retornar como est√°
        if (url.startsWith('data:image/')) {
          return url;
        }
        
        // Fazer fetch da imagem
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const blob = await response.blob();
        
        // Converter blob para base64
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => {
            resolve(reader.result);
          };
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      } catch (error) {
        console.warn('Erro ao converter imagem para base64:', error);
        return null;
      }
    }
    
    function applyZoom() {
      const z = zoom;
      elementsList.style.transformOrigin = 'top center';
      elementsList.style.transform = `scale(${z})`;
    }

    function elementLabel(el) {
      const map = {
        group: 'Grupo',
        header: 'Cabe√ßalho',
        text: 'Texto',
        image: 'Imagem',
        table: 'Tabela',
        columns: 'Colunas',
        list: 'Lista',
        margin: 'Espa√ßo',
        pageBreak: 'Quebra P√°gina'
      };
      return map[el.type] || el.type;
    }

    function createControls(el) {
      const controls = document.createElement('div');
      controls.className = 'element-controls';
      controls.style.display = 'none';
      return controls;
    }
function renderElementRecursive(el) {
      const wrapper = document.createElement('div');
      wrapper.className = 'element-item';
      wrapper.setAttribute('data-id', el.id);
      wrapper.draggable = false;

      if (el.type === 'group') wrapper.classList.add('element-group');
      if (el.type === 'image') {
        wrapper.classList.add('element-image');
        // Aplicar posicionamento absoluto/relativo no wrapper principal se existir
        if (el.properties.absolutePosition) {
          wrapper.style.position = 'absolute';
          wrapper.style.left = `${el.properties.absolutePosition.x || 0}px`;
          wrapper.style.top = `${el.properties.absolutePosition.y || 0}px`;
          wrapper.style.zIndex = '10';
        } else if (el.properties.relativePosition) {
          wrapper.style.position = 'relative';
          wrapper.style.left = `${el.properties.relativePosition.x || 0}px`;
          wrapper.style.top = `${el.properties.relativePosition.y || 0}px`;
        }
      }

      if (el.id === selectedElementId) wrapper.classList.add('selected');

      wrapper.addEventListener('click', (ev) => {
        ev.stopPropagation();
        selectElement(el.id);
      });

      // (UI) controles inline desabilitados: edi√ß√£o/remo√ß√£o apenas via painel Editor
// Preview content
      const preview = document.createElement('div');
      preview.className = 'element-preview';

      // --- Types ---
      if (el.type === 'group') {
        const childWrap = document.createElement('div');
        childWrap.className = 'group-children ' + (el.properties.orientation === 'row' ? 'orientation-row' : 'orientation-column');

        // dropzone do group (children)
        childWrap.setAttribute('data-drop-kind', 'groupChildren');
        childWrap.setAttribute('data-target-id', el.id);
        childWrap.addEventListener('dragover', onDropZoneOver);
        childWrap.addEventListener('dragleave', onDropZoneLeave);
        childWrap.addEventListener('drop', onDropZoneDrop);

        const children = el.properties.children || [];
        if (children.length === 0) {
          const ph = document.createElement('div');
          ph.className = 'group-placeholder';
          ph.textContent = 'Arraste elementos aqui';
          childWrap.appendChild(ph);
        } else {
          children.forEach(ch => {
            const childBox = document.createElement('div');
            //childBox.className = 'group-child-item';

            childBox.className = 'group-child-sem-abas';
            // no modo row, evita "estourar" e respeita a p√°gina
            if (el.properties.orientation === 'row') {
              childBox.style.flex = '1 1 0';
              childBox.style.minWidth = '0';
            } else {
              childBox.style.width = '100%';
            }
            childBox.appendChild(renderElementRecursive(ch));
            childWrap.appendChild(childBox);
          });
        }

        preview.appendChild(childWrap);
      }
      else if (el.type === 'header') {
        const div = document.createElement('div');
        div.className = 'preview-header';
        div.textContent = el.properties.text || 'Cabe√ßalho';
        div.style.textAlign = (el.properties.alignment || 'center');
        if (el.properties.color) div.style.color = el.properties.color;
        if (el.properties.background) div.style.backgroundColor = el.properties.background;
        if (el.properties.fontSize) div.style.fontSize = `${el.properties.fontSize}px`;
        if (el.properties.bold) div.style.fontWeight = 'bold';
        if (el.properties.decoration === 'underline') div.style.textDecoration = 'underline';
        if (el.properties.decoration === 'lineThrough') div.style.textDecoration = 'line-through';
        if (el.properties.decoration === 'overline') div.style.textDecoration = 'overline';
        if (el.properties.link) {
          div.style.cursor = 'pointer';
          div.style.textDecoration = 'underline';
          div.style.color = el.properties.color || '#0066cc';
          div.title = `Link: ${el.properties.link}`;
        }
        preview.appendChild(div);
      }
      else if (el.type === 'text') {
        const div = document.createElement('div');
        div.className = 'preview-text';
        let textContent = el.properties.text || 'Texto...';
        // Se estiver em header/footer e tiver placeholders, mostrar exemplo no preview
        const isInHeader = isElementInHeader(el.id);
        const isInFooter = isElementInFooter(el.id);
        if ((isInHeader || isInFooter) && textContent.includes('{{')) {
          textContent = textContent
            .replace(/\{\{pageNumber\}\}/g, '1')
            .replace(/\{\{totalPages\}\}/g, '10');
        }
        div.textContent = textContent;
        div.style.textAlign = (el.properties.alignment || 'left');
        if (el.properties.color) div.style.color = el.properties.color;
        if (el.properties.background) div.style.backgroundColor = el.properties.background;
        if (el.properties.fontSize) div.style.fontSize = `${el.properties.fontSize}px`;
        if (el.properties.bold) div.style.fontWeight = 'bold';
        if (el.properties.italics) div.style.fontStyle = 'italic';
        if (el.properties.decoration === 'underline') div.style.textDecoration = 'underline';
        if (el.properties.decoration === 'lineThrough') div.style.textDecoration = 'line-through';
        if (el.properties.decoration === 'overline') div.style.textDecoration = 'overline';
        if (el.properties.link) {
          div.style.cursor = 'pointer';
          div.style.textDecoration = 'underline';
          div.style.color = el.properties.color || '#0066cc';
          div.title = `Link: ${el.properties.link}`;
        }
        preview.appendChild(div);
      }
      else if (el.type === 'image') {
        const box = document.createElement('div');
        box.className = 'preview-image';
        const url = el.properties.url || '';
        const borderRadius = el.properties.borderRadius || 0;
        const opacity = el.properties.opacity !== undefined ? el.properties.opacity : 1;
        
        // Determinar dimens√µes para preview
        let previewWidth = '200px';
        let previewHeight = 'auto';
        if (el.properties.fit && Array.isArray(el.properties.fit)) {
          previewWidth = `${el.properties.fit[0]}px`;
          previewHeight = `${el.properties.fit[1]}px`;
        } else if (el.properties.cover) {
          previewWidth = `${el.properties.cover.width || 300}px`;
          previewHeight = `${el.properties.cover.height || 150}px`;
        } else {
          if (el.properties.width) previewWidth = `${el.properties.width}px`;
          if (el.properties.height) previewHeight = `${el.properties.height}px`;
        }
        
        // Aplicar dimens√µes ao box tamb√©m para garantir que o wrapper tenha o tamanho correto
        box.style.width = previewWidth;
        if (previewHeight !== 'auto') {
          box.style.height = previewHeight;
        }
        
        if (url) {
          const img = document.createElement('img');
          // Usar base64 para preview se dispon√≠vel, sen√£o usar URL original
          const imageSrc = el.properties._base64Preview || url;
          img.src = imageSrc;
          img.style.width = previewWidth;
          img.style.height = previewHeight;
          img.style.opacity = opacity;
          
          // Aplicar object-fit baseado no modo
          if (el.properties.fit) {
            img.style.objectFit = 'contain';
          } else if (el.properties.cover) {
            img.style.objectFit = 'cover';
          } else {
            img.style.objectFit = 'contain';
          }
          
          if (borderRadius > 0) {
            img.style.borderRadius = `${borderRadius}px`;
          }
          
          // Se n√£o h√° base64 e √© uma URL HTTP/HTTPS, tentar converter em background
          if (!el.properties._base64Preview && (url.startsWith('http://') || url.startsWith('https://'))) {
            // Tentar converter para base64 em background (n√£o bloqueia a renderiza√ß√£o)
            convertImageUrlToBase64(url).then(base64 => {
              if (base64 && el.properties.url === url) {
                el.properties._base64Preview = base64;
                img.src = base64;
              }
            }).catch(() => {
              // Silenciosamente falhar - manter URL original
            });
          }
          
          img.onerror = () => {
            img.style.display = 'none';
            const ph = document.createElement('div');
            ph.className = 'preview-image-box';
            ph.style.width = previewWidth;
            ph.style.height = previewHeight === 'auto' ? '150px' : previewHeight;
            ph.textContent = 'Erro ao carregar';
            box.appendChild(ph);
          };
          box.appendChild(img);
        } else {
          const ph = document.createElement('div');
          ph.className = 'preview-image-box';
          ph.style.width = previewWidth;
          ph.style.height = previewHeight === 'auto' ? '150px' : previewHeight;
          ph.textContent = 'Imagem';
          box.appendChild(ph);
        }
        
        // Posicionamento j√° aplicado no wrapper principal, n√£o precisa aplicar aqui novamente
        // Apenas garantir que o box n√£o tenha posicionamento pr√≥prio
        box.style.position = 'static';
        
        preview.appendChild(box);
      }
      else if (el.type === 'columns') {
        const colsWrap = document.createElement('div');
        colsWrap.className = 'preview-columns';
        colsWrap.style.gap = (Number(el.properties.gap || 10)) + 'px';
        
        // Aplicar alinhamento vertical se configurado
        if (el.properties.valign) {
          if (el.properties.valign === 'center') {
            colsWrap.style.alignItems = 'center';
          } else if (el.properties.valign === 'bottom') {
            colsWrap.style.alignItems = 'flex-end';
          } else {
            colsWrap.style.alignItems = 'flex-start';
          }
        }

        const cols = el.properties.columns || [];
        cols.forEach((col, idx) => {
          const colDiv = document.createElement('div');
          colDiv.className = 'preview-column';
          
          // Aplicar largura da coluna
          const width = col.width || '*';
          if (width === '*' || width === 'auto') {
            colDiv.style.flex = '1 1 0';
          } else if (typeof width === 'number') {
            colDiv.style.width = `${width}px`;
            colDiv.style.flex = '0 0 auto';
          } else if (typeof width === 'string' && width.endsWith('%')) {
            const percent = parseFloat(width.replace('%', '')) || 0;
            colDiv.style.width = `${percent}%`;
            colDiv.style.flex = '0 0 auto';
          } else {
            colDiv.style.flex = '1 1 0';
          }

          // dropzone por coluna
          colDiv.setAttribute('data-drop-kind', 'columnsCol');
          colDiv.setAttribute('data-target-id', el.id);
          colDiv.setAttribute('data-col-index', String(idx));
          colDiv.addEventListener('dragover', onDropZoneOver);
          colDiv.addEventListener('dragleave', onDropZoneLeave);
          colDiv.addEventListener('drop', onDropZoneDrop);

          const kids = col.children || [];
          if (kids.length === 0) {
            const ph = document.createElement('div');
            ph.className = 'smallNote';
            ph.textContent = `Coluna ${idx + 1}: arraste aqui`;
            colDiv.appendChild(ph);
          } else {
            kids.forEach(k => colDiv.appendChild(renderElementRecursive(k)));
          }
          colsWrap.appendChild(colDiv);
        });

        preview.appendChild(colsWrap);
      }
      else if (el.type === 'list') {
        const list = document.createElement(el.properties.listType === 'ol' ? 'ol' : 'ul');
        list.className = 'preview-list';

        // dropzone no container da lista (para adicionar novos itens quando solto fora dos itens existentes)
        list.setAttribute('data-drop-kind', 'listItems');
        list.setAttribute('data-target-id', el.id);
        list.addEventListener('dragover', onDropZoneOver);
        list.addEventListener('dragleave', onDropZoneLeave);
        list.addEventListener('drop', onDropZoneDrop);

        const items = el.properties.items || [];
        if (items.length === 0) {
          const li = document.createElement('li');
          li.textContent = 'Arraste aqui para adicionar item';
          list.appendChild(li);
        } else {
          items.forEach((it, idx) => {
            const li = document.createElement('li');
            li.style.border = '1px dashed #9ca3af';
            li.style.borderRadius = '0.5rem';
            li.style.padding = '0.5rem';
            li.style.marginBottom = '0.5rem';
            li.style.minHeight = '2rem';
            li.style.position = 'relative';
            
            // Dropzone individual para cada item (permite substituir o conte√∫do)
            li.setAttribute('data-drop-kind', 'listItemReplace');
            li.setAttribute('data-target-id', el.id);
            li.setAttribute('data-item-index', String(idx));
            
            // Handlers separados para garantir que o item tenha prioridade sobre o container
            li.addEventListener('dragover', (e) => {
              e.preventDefault();
              e.stopPropagation(); // Impede que o evento chegue ao container da lista
              li.classList.add('drag-over');
              li.style.backgroundColor = '#e0f2fe';
              li.style.borderColor = '#0284c7';
            });
            
            li.addEventListener('dragleave', (e) => {
              e.stopPropagation();
              li.classList.remove('drag-over');
              li.style.backgroundColor = '';
              li.style.borderColor = '#9ca3af';
            });
            
            li.addEventListener('drop', (e) => {
              e.preventDefault();
              e.stopPropagation(); // CR√çTICO: impede que o evento chegue ao container da lista
              li.classList.remove('drag-over');
              li.style.backgroundColor = '';
              li.style.borderColor = '#9ca3af';
              
              const type = (e.dataTransfer && e.dataTransfer.getData("text/plain")) || draggedType;
              if (!type) return;
              
              // Chamar insertIntoTarget diretamente para substituir o item
              insertIntoTarget({ 
                kind: 'listItemReplace', 
                targetId: el.id, 
                itemIndex: idx 
              }, type);
            });
            
            if (it.kind === 'text') {
              li.textContent = it.text || '';
            } else if (it.kind === 'node' && it.node) {
              li.appendChild(renderElementRecursive(it.node));
            }
            list.appendChild(li);
          });
        }
        preview.appendChild(list);
      }
      else if (el.type === 'table') {
        const tbl = document.createElement('table');
        tbl.className = 'preview-table';

        const body = el.properties.body || [];
        const heights = el.properties.heights;
        const customLayout = el.properties.customLayout || {};
        
        // Aplicar bordas da tabela baseado no layout customizado
        // Se hLineWidth ou vLineWidth estiverem definidos, aplicar bordas
        const hLineWidth = customLayout.hLineWidth !== undefined ? Number(customLayout.hLineWidth) : null;
        const vLineWidth = customLayout.vLineWidth !== undefined ? Number(customLayout.vLineWidth) : null;
        const hLineColor = customLayout.hLineColor || '#000000';
        const vLineColor = customLayout.vLineColor || '#000000';
        
        // Se layout for customizado, aplicar bordas dinamicamente
        if (el.properties.layout === 'custom' && (hLineWidth !== null || vLineWidth !== null)) {
          // Aplicar bordas baseadas nas configura√ß√µes
          if (hLineWidth !== null && hLineWidth > 0) {
            tbl.style.borderTop = `${hLineWidth}px solid ${hLineColor}`;
            tbl.style.borderBottom = `${hLineWidth}px solid ${hLineColor}`;
          }
          if (vLineWidth !== null && vLineWidth > 0) {
            tbl.style.borderLeft = `${vLineWidth}px solid ${vLineColor}`;
            tbl.style.borderRight = `${vLineWidth}px solid ${vLineColor}`;
          }
        }
        
        for (let r = 0; r < body.length; r++) {
          const tr = document.createElement('tr');
          const isHeaderRow = r === 0; // Primeira linha √© o cabe√ßalho
          
          // Aplicar altura da linha (heights)
          if (heights) {
            if (typeof heights === 'number') {
              tr.style.height = heights + 'px';
            } else if (Array.isArray(heights) && heights[r] !== undefined) {
              tr.style.height = heights[r] + 'px';
            }
          }
          
          // Aplicar bordas horizontais baseadas no layout customizado
          if (el.properties.layout === 'custom' && hLineWidth !== null && hLineWidth > 0) {
            // Aplicar borda inferior em todas as linhas
            tr.style.borderBottom = `${hLineWidth}px solid ${hLineColor}`;
            // Aplicar borda superior na primeira linha
            if (r === 0) {
              tr.style.borderTop = `${hLineWidth}px solid ${hLineColor}`;
            }
          } else if (isHeaderRow) {
            // Layout padr√£o - apenas borda no cabe√ßalho
            tr.style.backgroundColor = '#f3f4f6';
            tr.style.fontWeight = 'bold';
            tr.style.borderBottom = '2px solid #d1d5db';
          }
          
          // Rastrear c√©lulas j√° cobertas por rowSpan/colSpan
          const coveredCells = new Set();
          
          for (let c = 0; c < body[r].length; c++) {
            // Pular c√©lulas j√° cobertas por colSpan
            if (coveredCells.has(`${r}-${c}`)) {
              continue;
            }
            
            const td = document.createElement('td');
            td.style.verticalAlign = 'top';
            const cell = body[r][c];
            
            // Se layout customizado estiver ativo, remover bordas padr√£o do CSS
            if (el.properties.layout === 'custom') {
              td.style.border = 'none'; // Remover borda padr√£o
            }
            
            // Aplicar bordas verticais baseadas no layout customizado
            if (el.properties.layout === 'custom' && vLineWidth !== null && vLineWidth > 0) {
              // Aplicar borda direita em todas as c√©lulas (exceto a √∫ltima coluna)
              if (c < body[r].length - 1) {
                td.style.borderRight = `${vLineWidth}px solid ${vLineColor}`;
              }
              // Aplicar borda esquerda na primeira coluna
              if (c === 0) {
                td.style.borderLeft = `${vLineWidth}px solid ${vLineColor}`;
              }
            }
            
            // Aplicar bordas horizontais baseadas no layout customizado (nas c√©lulas)
            if (el.properties.layout === 'custom' && hLineWidth !== null && hLineWidth > 0) {
              // Aplicar borda superior na primeira linha
              if (r === 0) {
                td.style.borderTop = `${hLineWidth}px solid ${hLineColor}`;
              }
              // Aplicar borda inferior em todas as linhas
              td.style.borderBottom = `${hLineWidth}px solid ${hLineColor}`;
            }
            
            // Verificar se esta c√©lula est√° vazia (string vazia ou null)
            if (!cell || (typeof cell === 'string' && cell === '')) {
              // C√©lula vazia - renderizar como vazia mas ainda adicionar √† linha
              tr.appendChild(td);
              continue;
            }
            
            // Se n√£o for objeto, tratar como string simples
            const cellObj = (typeof cell === 'object' && cell !== null) ? cell : { children: [] };
            
            // Aplicar rowSpan e colSpan
            if (cellObj.rowSpan && cellObj.rowSpan > 1) {
              td.setAttribute('rowspan', cellObj.rowSpan);
              // Marcar c√©lulas abaixo como cobertas
              for (let sr = 1; sr < cellObj.rowSpan; sr++) {
                coveredCells.add(`${r + sr}-${c}`);
              }
            }
            if (cellObj.colSpan && cellObj.colSpan > 1) {
              td.setAttribute('colspan', cellObj.colSpan);
              // Marcar c√©lulas √† direita como cobertas
              for (let sc = 1; sc < cellObj.colSpan; sc++) {
                coveredCells.add(`${r}-${c + sc}`);
              }
            }
            
            // Aplicar border (array de 4 booleanos) - sobrescreve bordas do layout customizado se definido
            if (cellObj.border && Array.isArray(cellObj.border)) {
              if (!cellObj.border[0]) td.style.borderLeft = 'none';
              if (!cellObj.border[1]) td.style.borderTop = 'none';
              if (!cellObj.border[2]) td.style.borderRight = 'none';
              if (!cellObj.border[3]) td.style.borderBottom = 'none';
            }
            
            // Aplicar borderColor (array de 4 cores) - sobrescreve cores do layout customizado se definido
            if (cellObj.borderColor && Array.isArray(cellObj.borderColor)) {
              if (cellObj.borderColor[0]) td.style.borderLeftColor = cellObj.borderColor[0];
              if (cellObj.borderColor[1]) td.style.borderTopColor = cellObj.borderColor[1];
              if (cellObj.borderColor[2]) td.style.borderRightColor = cellObj.borderColor[2];
              if (cellObj.borderColor[3]) td.style.borderBottomColor = cellObj.borderColor[3];
            }
            
            // Aplicar estilos da c√©lula (fillColor, color, fillOpacity)
            // Tabela zebrada tem prioridade sobre fillColor individual
            if (el.properties.zebraEnabled && el.properties.zebraColor) {
              // Aplicar zebra seguindo o padr√£o do exemplo: linhas pares (0, 2, 4...) = cor, linhas √≠mpares (1, 3, 5...) = null
              // Mas cabe√ßalho (r=0) n√£o recebe zebra
              if (!isHeaderRow && r % 2 === 0) {
                const baseColor = el.properties.zebraColor;
                td.style.backgroundColor = baseColor;
              } else if (!isHeaderRow) {
                // Linhas √≠mpares = transparente (null no PDF)
                td.style.backgroundColor = 'transparent';
              }
            } else if (cellObj.fillColor) {
              const opacity = cellObj.fillOpacity !== undefined ? cellObj.fillOpacity : 1;
              td.style.backgroundColor = cellObj.fillColor;
              td.style.opacity = opacity;
            } else if (isHeaderRow) {
              td.style.backgroundColor = '#f9fafb';
            }
            
            if (cellObj.color) {
              td.style.color = cellObj.color;
            }
            
            // Padding padr√£o ou customizado
            if (el.properties.customLayout) {
              const cl = el.properties.customLayout;
              td.style.paddingLeft = (cl.paddingLeft || 5) + 'px';
              td.style.paddingRight = (cl.paddingRight || 5) + 'px';
              td.style.paddingTop = (cl.paddingTop || 5) + 'px';
              td.style.paddingBottom = (cl.paddingBottom || 5) + 'px';
            } else if (isHeaderRow) {
              td.style.padding = '0.5rem';
            }

            // dropzone por c√©lula
            td.setAttribute('data-drop-kind', 'tableCell');
            td.setAttribute('data-target-id', el.id);
            td.setAttribute('data-row', String(r));
            td.setAttribute('data-col', String(c));
            td.addEventListener('dragover', onDropZoneOver);
            td.addEventListener('dragleave', onDropZoneLeave);
            td.addEventListener('drop', onDropZoneDrop);

            const kids = (cellObj.children || []);
            if (kids.length === 0) {
              const placeholderColor = cellObj.color || (isHeaderRow ? '#6b7280' : '#9ca3af');
              if (isHeaderRow) {
                td.innerHTML = `<span style="color:${placeholderColor};font-size:12px;font-weight:bold;">Cabe√ßalho ${c + 1} - Arraste aqui</span>`;
              } else {
                td.innerHTML = `<span style="color:${placeholderColor};font-size:12px">Arraste aqui</span>`;
              }
            } else {
              kids.forEach(k => td.appendChild(renderElementRecursive(k)));
            }
            tr.appendChild(td);
          }
          tbl.appendChild(tr);
        }
        preview.appendChild(tbl);
      }
      else if (el.type === 'margin') {
        const div = document.createElement('div');
        div.className = 'preview-margin';
        const marginSize = Number(el.properties.size || 20);
        div.style.height = `${marginSize}px`;
        div.style.minHeight = `${marginSize}px`;
        div.style.display = 'flex';
        div.style.alignItems = 'center';
        div.style.justifyContent = 'center';
        div.textContent = `Espa√ßo (${marginSize}px)`;
        preview.appendChild(div);
      }
      else if (el.type === 'pageBreak') {
        const div = document.createElement('div');
        div.className = 'preview-pagebreak';
        div.textContent = 'Quebra de p√°gina';
        preview.appendChild(div);
      }
      else if (el.type === 'qr') {
        const box = document.createElement('div');
        box.className = 'preview-qr';
        box.style.width = `${el.properties.fit || 100}px`;
        box.style.height = `${el.properties.fit || 100}px`;
        box.style.border = `2px solid ${el.properties.foreground || '#000000'}`;
        box.style.display = 'flex';
        box.style.alignItems = 'center';
        box.style.justifyContent = 'center';
        box.style.background = el.properties.background || '#ffffff';
        const foregroundColor = el.properties.foreground || '#000000';
        box.innerHTML = `<div style="font-size: 0.75rem; color: ${foregroundColor}; font-weight: bold;">QR Code</div>`;
        preview.appendChild(box);
      }
      else if (el.type === 'svg') {
        const box = document.createElement('div');
        box.className = 'preview-svg';
        box.style.width = `${el.properties.width || 100}px`;
        box.style.height = `${el.properties.height || 100}px`;
        box.style.border = '1px solid #d1d5db';
        box.style.display = 'flex';
        box.style.alignItems = 'center';
        box.style.justifyContent = 'center';
        try {
          // Tentar renderizar o SVG
          const parser = new DOMParser();
          const svgDoc = parser.parseFromString(el.properties.svg || '', 'image/svg+xml');
          const svgElement = svgDoc.documentElement;
          if (svgElement && svgElement.tagName === 'svg') {
            svgElement.setAttribute('width', el.properties.width || 100);
            svgElement.setAttribute('height', el.properties.height || 100);
            if (el.properties.color) {
              svgElement.setAttribute('fill', el.properties.color);
            }
            box.appendChild(svgElement);
          } else {
            box.innerHTML = '<div style="font-size: 0.75rem; color: #6b7280;">SVG</div>';
          }
        } catch (e) {
          box.innerHTML = '<div style="font-size: 0.75rem; color: #ef4444;">Erro no SVG</div>';
        }
        preview.appendChild(box);
      }
      else {
        preview.textContent = elementLabel(el);
      }

      wrapper.appendChild(preview);
      return wrapper;
    }

    function renderCanvas(shouldAdjustSize = true) {
      const root = getRootGroup();
      
      // Limpar canvas
      elementsList.innerHTML = '';
      
      // Renderizar Header se ativado
      if (documentHeader.enabled && documentHeader.root) {
        const headerContainer = document.createElement('div');
        headerContainer.className = 'header-container';
        headerContainer.setAttribute('data-header-container', 'true');
        headerContainer.style.position = 'sticky';
        headerContainer.style.top = '0';
        headerContainer.style.zIndex = '100';
        headerContainer.style.background = '#f9fafb';
        headerContainer.style.borderBottom = '2px solid #2563eb';
        headerContainer.style.padding = '1rem';
        headerContainer.style.marginBottom = '1rem';
        headerContainer.style.minHeight = `${documentHeader.height}px`;
        
        const headerLabel = document.createElement('div');
        headerLabel.style.fontSize = '0.75rem';
        headerLabel.style.fontWeight = '600';
        headerLabel.style.color = '#2563eb';
        headerLabel.style.marginBottom = '0.5rem';
        headerLabel.textContent = 'üìÑ CABE√áALHO';
        headerContainer.appendChild(headerLabel);
        
        const headerContent = document.createElement('div');
        headerContent.className = 'header-content';
        headerContent.setAttribute('data-drop-kind', 'groupChildren');
        headerContent.setAttribute('data-target-id', documentHeader.root.id);
        headerContent.addEventListener('dragover', onDropZoneOver);
        headerContent.addEventListener('dragleave', onDropZoneLeave);
        headerContent.addEventListener('drop', onDropZoneDrop);
        
        const headerChildren = documentHeader.root.properties.children || [];
        if (headerChildren.length === 0) {
          const ph = document.createElement('div');
          ph.className = 'group-placeholder';
          ph.textContent = 'Arraste elementos aqui para o cabe√ßalho';
          headerContent.appendChild(ph);
        } else {
          headerChildren.forEach(ch => {
            headerContent.appendChild(renderElementRecursive(ch));
          });
        }
        
        headerContainer.appendChild(headerContent);
        elementsList.appendChild(headerContainer);
      }
      
      // Renderizar conte√∫do principal
      if (!root) {
        canvasEmpty.style.display = 'flex';
        elementsList.style.display = 'none';
        // Resetar altura do canvas quando vazio
        canvas.style.height = 'auto';
        canvas.style.minHeight = '842px';
        return;
      }
      canvasEmpty.style.display = 'none';
      elementsList.style.display = 'flex';
      
      elementsList.appendChild(renderElementRecursive(root));
      
      // Renderizar Footer se ativado
      if (documentFooter.enabled && documentFooter.root) {
        const footerContainer = document.createElement('div');
        footerContainer.className = 'footer-container';
        footerContainer.setAttribute('data-footer-container', 'true');
        footerContainer.style.position = 'sticky';
        footerContainer.style.bottom = '0';
        footerContainer.style.zIndex = '100';
        footerContainer.style.background = '#f9fafb';
        footerContainer.style.borderTop = '2px solid #2563eb';
        footerContainer.style.padding = '1rem';
        footerContainer.style.marginTop = '1rem';
        footerContainer.style.minHeight = `${documentFooter.height}px`;
        
        const footerLabel = document.createElement('div');
        footerLabel.style.fontSize = '0.75rem';
        footerLabel.style.fontWeight = '600';
        footerLabel.style.color = '#2563eb';
        footerLabel.style.marginBottom = '0.5rem';
        footerLabel.textContent = 'üìÑ RODAP√â';
        footerContainer.appendChild(footerLabel);
        
        const footerContent = document.createElement('div');
        footerContent.className = 'footer-content';
        footerContent.setAttribute('data-drop-kind', 'groupChildren');
        footerContent.setAttribute('data-target-id', documentFooter.root.id);
        footerContent.addEventListener('dragover', onDropZoneOver);
        footerContent.addEventListener('dragleave', onDropZoneLeave);
        footerContent.addEventListener('drop', onDropZoneDrop);
        
        const footerChildren = documentFooter.root.properties.children || [];
        if (footerChildren.length === 0) {
          const ph = document.createElement('div');
          ph.className = 'group-placeholder';
          ph.textContent = 'Arraste elementos aqui para o rodap√©';
          footerContent.appendChild(ph);
        } else {
          footerChildren.forEach(ch => {
            footerContent.appendChild(renderElementRecursive(ch));
          });
        }
        
        footerContainer.appendChild(footerContent);
        elementsList.appendChild(footerContainer);
      }
      
      applyZoom();
      
      // Ajustar altura e largura do canvas dinamicamente baseado no conte√∫do
      // IMPORTANTE: S√≥ ajustar se solicitado (n√£o ajustar quando apenas selecionamos um elemento)
      if (shouldAdjustSize) {
        adjustCanvasSize();
      }
    }
    
    /**
     * Fun√ß√£o central para auto-redimensionar a p√°gina/canvas baseado no conte√∫do real
     * Ajusta tanto ALTURA quanto LARGURA dinamicamente, sem impor limites artificiais
     * 
     * Comportamento:
     * - Mede o conte√∫do REAL usando scrollWidth/scrollHeight
     * - Aplica o tamanho calculado no canvas
     * - N√£o altera layout visual, apenas tamanho do container
     * - N√£o afeta o output do PDF (apenas visual do editor)
     */
    let isAdjustingCanvasSize = false; // Flag para evitar chamadas recursivas
    let lastCanvasWidth = 0; // Armazenar √∫ltima largura aplicada para evitar rec√°lculos desnecess√°rios
    let lastCanvasHeight = 0; // Armazenar √∫ltima altura aplicada para evitar rec√°lculos desnecess√°rios
    
    // Fun√ß√£o auxiliar para resetar cache de tamanho do canvas quando conte√∫do muda
    function resetCanvasSizeCache() {
      lastCanvasWidth = 0;
      lastCanvasHeight = 0;
    }
    
    function adjustCanvasSize() {
      // Evitar chamadas recursivas que podem causar crescimento infinito
      if (isAdjustingCanvasSize) return;
      isAdjustingCanvasSize = true;
      
      // Aguardar m√∫ltiplos frames para garantir que o DOM foi completamente atualizado
      // Isso √© importante para elementos aninhados e transi√ß√µes CSS
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          if (!elementsList || !canvas) {
            isAdjustingCanvasSize = false;
            return;
          }
          
          // ==========================================
          // AJUSTAR ALTURA (j√° funcionando, manter l√≥gica)
          // ==========================================
          if (elementsList.children.length === 0) {
            // Se n√£o h√° elementos, manter altura m√≠nima
            canvas.style.height = 'auto';
            canvas.style.minHeight = '842px';
          } else {
            // Calcular altura total do conte√∫do
            // Padding do canvas: 2rem top + 2rem bottom = 64px total
            const canvasPaddingTop = 32; // 2rem
            const canvasPaddingBottom = 32; // 2rem
            
            // Obter altura total da lista de elementos
            // Usar scrollHeight para pegar a altura real incluindo elementos que podem estar fora da viewport
            const elementsListHeight = elementsList.scrollHeight;
            
            // Calcular altura total: altura dos elementos + padding do canvas
            const totalHeight = elementsListHeight + canvasPaddingTop + canvasPaddingBottom;
            
            // Altura m√≠nima √© 842px (tamanho A4 portrait em pixels a 96dpi)
            const minHeight = 842;
            
            // Definir altura do canvas (m√≠nimo ou altura calculada, o que for maior)
            // Adicionar uma pequena margem de seguran√ßa (20px) para evitar cortes
            const newHeight = Math.max(minHeight, totalHeight + 20);
            
            // S√≥ aplicar se a diferen√ßa for significativa (mais de 15px)
            const currentHeight = lastCanvasHeight > 0 ? lastCanvasHeight : (parseInt(canvas.style.height) || canvas.offsetHeight || minHeight);
            const heightDifference = Math.abs(newHeight - currentHeight);
            
            if (heightDifference > 15) {
              canvas.style.height = newHeight + 'px';
              canvas.style.minHeight = minHeight + 'px';
              lastCanvasHeight = newHeight;
            } else {
              if (lastCanvasHeight === 0) {
                lastCanvasHeight = currentHeight;
              }
            }
          }
          
          // ==========================================
          // AJUSTAR LARGURA (nova implementa√ß√£o)
          // ==========================================
          // IMPORTANTE: Fazer TODAS as medi√ß√µes ANTES de alterar qualquer estilo
          // Isso evita reflows que causam crescimento incremental
          
          const canvasPaddingLeft = 32; // 2rem
          const canvasPaddingRight = 32; // 2rem
          const minWidth = 595; // Largura m√≠nima A4 portrait
          
          // 1. Obter largura atual do canvas ANTES de qualquer medi√ß√£o
          // Isso garante que n√£o estamos comparando com valores j√° alterados
          // Usar a √∫ltima largura aplicada se dispon√≠vel, sen√£o usar o valor atual
          const currentCanvasWidth = lastCanvasWidth > 0 ? lastCanvasWidth : (parseInt(canvas.style.width) || canvas.offsetWidth || minWidth);
          
          // 2. Medir o scrollWidth do elementsList SEM alterar o DOM
          // IMPORTANTE: N√£o alterar temporariamente o width do elementsList para evitar reflows que causam loops
          let contentWidth = elementsList.scrollWidth || elementsList.offsetWidth || 0;
          
          // 3. Verificar elementos raiz diretamente para garantir que capturamos tudo
          // Elementos raiz s√£o os .element-item que est√£o diretamente dentro de .elements-list
          const rootElements = Array.from(elementsList.children).filter(
            child => child.classList.contains('element-item') || 
                     child.classList.contains('header-container') || 
                     child.classList.contains('footer-container')
          );
          
          rootElements.forEach(rootEl => {
            // Para cada elemento raiz, medir sua largura real
            const rootScrollWidth = rootEl.scrollWidth || 0;
            const rootOffsetWidth = rootEl.offsetWidth || 0;
            const rootWidth = Math.max(rootScrollWidth, rootOffsetWidth);
            
            if (rootWidth > contentWidth) {
              contentWidth = rootWidth;
            }
            
            // Verificar tamb√©m elementos dentro deste root (tabelas, grupos, etc.)
            // Buscar todas as tabelas dentro deste elemento
            const tablesInRoot = rootEl.querySelectorAll('table, .preview-table');
            tablesInRoot.forEach(table => {
              // Para tabelas, calcular largura real somando c√©lulas
              // Estrat√©gia: somar a largura de todas as c√©lulas da primeira linha
              let tableWidth = 0;
              const firstRow = table.querySelector('tr');
              
              if (firstRow) {
                const cells = firstRow.querySelectorAll('td, th');
                cells.forEach(cell => {
                  // scrollWidth captura a largura real do conte√∫do, mesmo que esteja cortado
                  const cellScrollWidth = cell.scrollWidth || 0;
                  const cellOffsetWidth = cell.offsetWidth || 0;
                  const cellRect = cell.getBoundingClientRect();
                  // Usar o maior valor para garantir que capturamos a largura real
                  const cellWidth = Math.max(cellScrollWidth, cellOffsetWidth, cellRect.width);
                  tableWidth += cellWidth;
                });
              }
              
              // Se n√£o conseguiu calcular pelas c√©lulas, usar scrollWidth da tabela
              if (tableWidth === 0) {
                tableWidth = table.scrollWidth || table.offsetWidth || table.getBoundingClientRect().width;
              }
              
              // Considerar padding e bordas da tabela (getBoundingClientRect inclui isso)
              const tableRect = table.getBoundingClientRect();
              if (tableRect.width > tableWidth) {
                tableWidth = tableRect.width;
              }
              
              if (tableWidth > contentWidth) {
                contentWidth = tableWidth;
              }
            });
          });
          
          // 4. Calcular largura total necess√°ria: largura do conte√∫do + padding do canvas
          const totalWidth = contentWidth + canvasPaddingLeft + canvasPaddingRight;
          
          // 5. Definir largura do canvas (m√≠nimo ou largura calculada, o que for maior)
          // Adicionar margem de seguran√ßa (30px) para evitar cortes de bordas/padding
          const newWidth = Math.max(minWidth, totalWidth + 30);
          
          // 6. Comparar com a largura atual ANTES de aplicar qualquer altera√ß√£o
          // S√≥ aplicar se a diferen√ßa for significativa (mais de 15px para evitar ajustes infinitos)
          // Isso evita ajustes infinitos por diferen√ßas m√≠nimas de arredondamento ou medi√ß√µes inconsistentes
          const widthDifference = Math.abs(newWidth - currentCanvasWidth);
          
          if (widthDifference > 15) {
            // 7. Aplicar largura no canvas APENAS se realmente necess√°rio
            canvas.style.width = newWidth + 'px';
            canvas.style.minWidth = minWidth + 'px';
            canvas.style.maxWidth = 'none'; // Remover qualquer limite m√°ximo
            
            // Armazenar a largura aplicada para evitar rec√°lculos desnecess√°rios
            lastCanvasWidth = newWidth;
            
            // 8. Garantir que containers pais n√£o limitem o crescimento
            // O canvas-wrapper deve permitir que o canvas cres√ßa
            // IMPORTANTE: S√≥ alterar se realmente necess√°rio para evitar reflows desnecess√°rios
            const canvasWrapper = canvas.parentElement;
            if (canvasWrapper && canvasWrapper.classList.contains('canvas-wrapper')) {
              // Verificar se j√° est√° configurado corretamente antes de alterar
              if (canvasWrapper.style.maxWidth !== 'none') {
                canvasWrapper.style.width = 'auto';
                canvasWrapper.style.minWidth = '0';
                canvasWrapper.style.maxWidth = 'none';
              }
            }
            
            // 9. Garantir que elements-list tamb√©m n√£o limite o crescimento
            // elements-list deve poder crescer horizontalmente
            // IMPORTANTE: S√≥ alterar se realmente necess√°rio para evitar reflows desnecess√°rios
            if (elementsList && elementsList.style.maxWidth !== 'none') {
              elementsList.style.width = 'auto';
              elementsList.style.minWidth = '0';
              elementsList.style.maxWidth = 'none';
            }
          } else {
            // Se n√£o houve altera√ß√£o, manter a √∫ltima largura conhecida
            if (lastCanvasWidth === 0) {
              lastCanvasWidth = currentCanvasWidth;
            }
          }
          
          // 10. Liberar flag ap√≥s completar o ajuste (importante para evitar loops infinitos)
          isAdjustingCanvasSize = false;
        });
      });
    }

    function selectElement(id) {
      // Evitar re-renderiza√ß√£o desnecess√°ria se o elemento j√° est√° selecionado
      if (selectedElementId === id) {
        return; // J√° est√° selecionado, n√£o precisa fazer nada
      }
      
      // Atualizar sele√ß√£o visual sem recriar o DOM inteiro
      // Isso evita reflows desnecess√°rios que causam crescimento infinito
      const prevSelected = selectedElementId ? document.querySelector(`[data-id="${selectedElementId}"]`) : null;
      if (prevSelected) {
        prevSelected.classList.remove('selected');
      }
      
      const newSelected = document.querySelector(`[data-id="${id}"]`);
      if (newSelected) {
        newSelected.classList.add('selected');
      }
      
      selectedElementId = id;
      // IMPORTANTE: N√£o recriar o DOM quando apenas selecionamos
      // Apenas atualizar o inspector e c√≥digo
      renderInspector();
      updateCode();
      // Salvar estado ap√≥s sele√ß√£o
      saveState();
    }

    // -----------------------
    // Inspector (Right panel)
    // -----------------------
    function fieldWrap(labelText) {
      const wrap = document.createElement('div');
      wrap.className = 'inspector-field';
      const label = document.createElement('label');
      label.textContent = labelText;
      wrap.appendChild(label);
      return wrap;
    }

    function addInput(wrap, value, onChange, opts = {}) {
      const input = document.createElement('input');
      input.type = opts.type || 'text';
      if (opts.min != null) input.min = opts.min;
      if (opts.max != null) input.max = opts.max;
      if (opts.step != null) input.step = opts.step;
      input.value = value ?? '';
      input.oninput = () => onChange(input.value);
      wrap.appendChild(input);
      return input;
    }

    function addSelect(wrap, value, options, onChange) {
      const sel = document.createElement('select');
      options.forEach(o => {
        const opt = document.createElement('option');
        opt.value = o.value;
        opt.textContent = o.label;
        if (o.value === value) opt.selected = true;
        sel.appendChild(opt);
      });
      sel.onchange = () => onChange(sel.value);
      wrap.appendChild(sel);
      return sel;
    }

    function addTextarea(wrap, value, onChange) {
      const ta = document.createElement('textarea');
      ta.value = value ?? '';
      ta.oninput = () => onChange(ta.value);
      wrap.appendChild(ta);
      return ta;
    }

    // Fun√ß√µes auxiliares para o editor (do gerador_atualizado_v2.html)
    function findElementByIdRecursive(id, elementsArray) {
      for (const el of elementsArray) {
        if (el.id === id) return el;
        
        // Buscar em grupos
        if (el.type === 'group' && el.properties && el.properties.children) {
          const found = findElementByIdRecursive(id, el.properties.children);
          if (found) return found;
        }
        
        // Buscar em columns
        if (el.type === 'columns' && el.properties && el.properties.columns) {
          for (const col of el.properties.columns) {
            if (col.children) {
              const found = findElementByIdRecursive(id, col.children);
              if (found) return found;
            }
          }
        }
        
        // Buscar em list items (quando item √© um node)
        if (el.type === 'list' && el.properties && el.properties.items) {
          for (const item of el.properties.items) {
            if (item.kind === 'node' && item.node) {
              if (item.node.id === id) return item.node;
              // Buscar recursivamente no node
              const found = findElementByIdRecursive(id, [item.node]);
              if (found) return found;
            }
          }
        }
        
        // Buscar em table cells
        if (el.type === 'table' && el.properties && el.properties.body) {
          for (const row of el.properties.body) {
            for (const cell of row) {
              if (cell && typeof cell === 'object' && cell.children) {
                const found = findElementByIdRecursive(id, cell.children);
                if (found) return found;
              }
            }
          }
        }
      }
      return null;
    }

    function findElementById(id) {
      if (!id) return null;
      // Primeiro tentar usar findNodeById se existir
      if (typeof findNodeById === 'function') {
        const node = findNodeById(id);
        if (node) return node;
      }
      // Depois buscar recursivamente nos elements
      return findElementByIdRecursive(id, elements);
    }

    // Find parent container of an element (group, columns, list, table)
    // Verificar se elemento est√° dentro de header
    function isElementInHeader(elementId) {
      if (!elementId || !documentHeader.root) return false;
      let found = false;
      walk(documentHeader.root, (n) => {
        if (n.id === elementId) found = true;
      });
      return found;
    }
    
    // Verificar se elemento est√° dentro de footer
    function isElementInFooter(elementId) {
      if (!elementId || !documentFooter.root) return false;
      let found = false;
      walk(documentFooter.root, (n) => {
        if (n.id === elementId) found = true;
      });
      return found;
    }
    
    function findParentGroup(elementId) {
      if (!elementId) return null;
      
      // Buscar em grupos do root
      for (const group of elements) {
        if (group.type === 'group' && group.properties && group.properties.children) {
          const childIndex = group.properties.children.findIndex(c => c && c.id === elementId);
          if (childIndex !== -1) {
            return { group, child: group.properties.children[childIndex], index: childIndex };
          }
          
          // Buscar recursivamente em grupos aninhados
          for (const childGroup of group.properties.children) {
            if (childGroup && childGroup.type === 'group' && childGroup.properties && childGroup.properties.children) {
              const nestedChildIndex = childGroup.properties.children.findIndex(c => c && c.id === elementId);
              if (nestedChildIndex !== -1) {
                return { 
                  group: childGroup, 
                  child: childGroup.properties.children[nestedChildIndex], 
                  index: nestedChildIndex 
                };
              }
            }
          }
        }
        
        // Buscar em columns
        if (group.type === 'columns' && group.properties && group.properties.columns) {
          for (let colIdx = 0; colIdx < group.properties.columns.length; colIdx++) {
            const col = group.properties.columns[colIdx];
            if (col.children) {
              const childIndex = col.children.findIndex(c => c && c.id === elementId);
              if (childIndex !== -1) {
                return { group, child: col.children[childIndex], index: childIndex, colIndex: colIdx };
              }
            }
          }
        }
        
        // Buscar em list items
        if (group.type === 'list' && group.properties && group.properties.items) {
          for (let itemIdx = 0; itemIdx < group.properties.items.length; itemIdx++) {
            const item = group.properties.items[itemIdx];
            if (item.kind === 'node' && item.node && item.node.id === elementId) {
              return { group, child: item.node, index: itemIdx };
            }
          }
        }
        
        // Buscar em table cells
        if (group.type === 'table' && group.properties && group.properties.body) {
          for (let rowIdx = 0; rowIdx < group.properties.body.length; rowIdx++) {
            const row = group.properties.body[rowIdx];
            for (let colIdx = 0; colIdx < row.length; colIdx++) {
              const cell = row[colIdx];
              if (cell && typeof cell === 'object' && cell.children) {
                const childIndex = cell.children.findIndex(c => c && c.id === elementId);
                if (childIndex !== -1) {
                  return { group, child: cell.children[childIndex], index: childIndex, rowIndex: rowIdx, colIndex: colIdx };
                }
              }
            }
          }
        }
      }
      return null;
    }

    // Mover elemento dentro de um container (grupo, columns, table)
    function moveElementInContainer(direction) {
      if (!selectedElementId) return;
      
      const nodeWithParent = findNodeWithParent(selectedElementId);
      if (!nodeWithParent || !nodeWithParent.parent || !nodeWithParent.ctx) return;
      
      const { parent, ctx } = nodeWithParent;
      let children = [];
      let index = -1;
      
      // Determinar array de children e √≠ndice baseado no tipo de container
      if (ctx.kind === 'groupChildren') {
        children = parent.properties.children || [];
        index = ctx.index;
      } else if (ctx.kind === 'columns') {
        const col = parent.properties.columns[ctx.colIndex];
        children = col.children || [];
        index = ctx.index;
      } else if (ctx.kind === 'tableCell') {
        const cell = parent.properties.body[ctx.row][ctx.col];
        children = cell.children || [];
        index = ctx.index;
      } else {
        return; // N√£o suportado
      }
      
      if (children.length <= 1) return;
      
      let newIndex = index;
      
      switch (direction) {
        case 'first':
          if (index === 0) return;
          newIndex = 0;
          break;
        case 'prev':
          if (index === 0) return;
          newIndex = index - 1;
          break;
        case 'next':
          if (index === children.length - 1) return;
          newIndex = index + 1;
          break;
        case 'last':
          if (index === children.length - 1) return;
          newIndex = children.length - 1;
          break;
      }
      
      // Mover elemento
      const [movedElement] = children.splice(index, 1);
      children.splice(newIndex, 0, movedElement);
      
      // Se for grupo, recalcular larguras se for horizontal
      if (ctx.kind === 'groupChildren' && parent.properties.orientation === 'row' && typeof updateGroupChildrenWidths === 'function') {
        updateGroupChildrenWidths(parent);
      }
      
      // Atualizar dimens√µes do grupo se aplic√°vel
      if (ctx.kind === 'groupChildren' && typeof updateGroupDimensions === 'function') {
        updateGroupDimensions(parent);
      }
      
      // Re-renderizar imediatamente
      if (typeof renderAll === 'function') {
        renderAll();
      } else if (typeof render === 'function') {
            render();
      }
      // Atualizar inspector para refletir a nova posi√ß√£o
      setTimeout(() => {
        if (typeof renderInspector === 'function') renderInspector();
      }, 0);
    }
    
    // Mover elemento dentro de um grupo (mantido para compatibilidade)
    function moveElementInGroup(direction) {
      moveElementInContainer(direction);
    }
    
    // Mover coluna dentro de columns
    function moveColumnInColumns(elementId, colIndex, direction) {
      const element = findElementById(elementId);
      if (!element || element.type !== 'columns') return;
      
      const cols = element.properties.columns || [];
      if (cols.length <= 1) return;
      
      let newIndex = colIndex;
      
      switch (direction) {
        case 'first':
          if (colIndex === 0) return;
          newIndex = 0;
          break;
        case 'prev':
          if (colIndex === 0) return;
          newIndex = colIndex - 1;
          break;
        case 'next':
          if (colIndex === cols.length - 1) return;
          newIndex = colIndex + 1;
          break;
        case 'last':
          if (colIndex === cols.length - 1) return;
          newIndex = cols.length - 1;
          break;
      }
      
      // Mover coluna
      const [movedCol] = cols.splice(colIndex, 1);
      cols.splice(newIndex, 0, movedCol);
      
      // Re-renderizar
      if (typeof renderAll === 'function') {
        renderAll();
      } else if (typeof render === 'function') {
        render();
      }
      // Atualizar inspector
      setTimeout(() => {
        if (typeof renderInspector === 'function') renderInspector();
      }, 0);
    }
    
    // Mover coluna dentro de table
    function moveColumnInTable(elementId, colIndex, direction) {
      const element = findElementById(elementId);
      if (!element || element.type !== 'table') return;
      
      const body = element.properties.body || [];
      if (body.length === 0) return;
      
      const numCols = body[0].length;
      if (numCols <= 1) return;
      
      let newIndex = colIndex;
      
      switch (direction) {
        case 'first':
          if (colIndex === 0) return;
          newIndex = 0;
          break;
        case 'prev':
          if (colIndex === 0) return;
          newIndex = colIndex - 1;
          break;
        case 'next':
          if (colIndex === numCols - 1) return;
          newIndex = colIndex + 1;
          break;
        case 'last':
          if (colIndex === numCols - 1) return;
          newIndex = numCols - 1;
          break;
      }
      
      // Mover coluna em todas as linhas
      body.forEach(row => {
        const [movedCell] = row.splice(colIndex, 1);
        row.splice(newIndex, 0, movedCell);
      });
      
      // Mover width correspondente se existir
      if (element.properties.widths && element.properties.widths.length === numCols) {
        const [movedWidth] = element.properties.widths.splice(colIndex, 1);
        element.properties.widths.splice(newIndex, 0, movedWidth);
      }
      
      // Re-renderizar
      if (typeof renderAll === 'function') {
        renderAll();
      } else if (typeof render === 'function') {
      render();
      }
      // Atualizar inspector
      setTimeout(() => {
        if (typeof renderInspector === 'function') renderInspector();
      }, 0);
    }
    
    // Deletar coluna espec√≠fica de columns
    function deleteColumnFromColumns(elementId, colIndex) {
      const element = findElementById(elementId);
      if (!element || element.type !== 'columns') return;
      
      const cols = element.properties.columns || [];
      if (cols.length <= 1) {
        if (typeof showAlertModal === 'function') {
          showAlertModal('Aviso', '√â necess√°rio manter pelo menos uma coluna.');
        }
        return;
      }

      if (typeof showConfirmModal === 'function') {
        showConfirmModal(
          'Deletar Coluna',
          `Tem certeza que deseja deletar a Coluna ${colIndex + 1}? Todos os elementos dentro desta coluna ser√£o removidos.`,
          () => {
            // Deletar a coluna
            cols.splice(colIndex, 1);
            
            // Atualizar o n√∫mero de colunas no input se existir
            const colCountInput = document.getElementById('insp-colCount');
            if (colCountInput) {
              colCountInput.value = cols.length;
            }
            
            // Re-renderizar
            if (typeof renderAll === 'function') {
              renderAll();
            } else if (typeof render === 'function') {
      render();
            }
            // Atualizar inspector
            setTimeout(() => {
              if (typeof renderInspector === 'function') renderInspector();
            }, 0);
          }
        );
      }
    }
    
    // Deletar coluna espec√≠fica de table
    function deleteColumnFromTable(elementId, colIndex) {
      const element = findElementById(elementId);
      if (!element || element.type !== 'table') return;
      
      const body = element.properties.body || [];
      if (body.length === 0) return;
      
      const numCols = body[0].length;
      if (numCols <= 1) {
        if (typeof showAlertModal === 'function') {
          showAlertModal('Aviso', '√â necess√°rio manter pelo menos uma coluna.');
        }
        return;
      }
      
      if (typeof showConfirmModal === 'function') {
        showConfirmModal(
          'Deletar Coluna',
          `Tem certeza que deseja deletar a Coluna ${colIndex + 1}? Todos os dados desta coluna em todas as linhas ser√£o removidos.`,
          () => {
            // Deletar coluna de todas as linhas
            body.forEach(row => {
              row.splice(colIndex, 1);
            });
            
            // Deletar width correspondente se existir
            if (element.properties.widths && element.properties.widths.length === numCols) {
              element.properties.widths.splice(colIndex, 1);
            }
            
            // Atualizar n√∫mero de colunas no input se existir
            const tableColsInput = document.getElementById('insp-tableCols');
            if (tableColsInput) {
              tableColsInput.value = numCols - 1;
            }
            
            // Re-renderizar
            if (typeof renderAll === 'function') {
              renderAll();
            } else if (typeof render === 'function') {
              render();
            }
            // Atualizar inspector
            setTimeout(() => {
              if (typeof renderInspector === 'function') renderInspector();
            }, 0);
          }
        );
      }
    }
    
    // Processar imagem com border-radius usando Canvas (adaptado do script Node.js fornecido)
    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function updateParentGroupsDimensions(childId) {
      if (!childId) return;
      elements.forEach(group => {
        if (group.type === 'group' && group.properties && group.properties.children) {
          const hasChild = group.properties.children.some(child => child && child.id === childId);
          if (hasChild && typeof updateGroupDimensions === 'function') {
            updateGroupDimensions(group);
          }
        }
      });
    }

    // Remover elemento selecionado
    function removeSelectedElement() {
      if (!selectedElementId) return;
      
      showConfirmModal(
        'Remover elemento',
        'Tem certeza que deseja remover este elemento?',
        () => {
          // Usar deleteSelected que j√° existe e funciona corretamente
          deleteSelected();
          // Atualizar inspector ap√≥s remo√ß√£o
          renderInspector();
        }
      );
    }
    window.removeSelectedElement = removeSelectedElement; // Tornar global para uso no onclick

    // Get element type name for display
    function getElementTypeName(type) {
      const names = {
        text: 'Texto',
        header: 'Cabe√ßalho',
        image: 'Imagem',
        table: 'Tabela',
        columns: 'Colunas',
        list: 'Lista',
        margin: 'Espa√ßo',
        pageBreak: 'Quebra de P√°gina',
        group: 'Grupo'
      };
      return names[type] || type;
    }

    function renderInspector() {
      const inspector = document.getElementById('inspector');
      const element = findElementById(selectedElementId);

      if (!element) {
        inspector.innerHTML = `
          <div class="muted" style="padding: 1rem; text-align: center;">
            Selecione um elemento no canvas para editar suas propriedades.
          </div>
        `;
        return;
      }

      let html = `<div class="inspector-field">
        <label>Tipo: <strong>${getElementTypeName(element.type)}</strong></label>
      </div>`;

      // Check if element is inside a container (group, columns, table)
      const parentGroupInfo = findParentGroup(element.id);
      const nodeWithParent = findNodeWithParent(element.id);
      
      if (parentGroupInfo || (nodeWithParent && nodeWithParent.parent && nodeWithParent.ctx)) {
        let children = [];
        let childIndex = -1;
        let isFirst = false;
        let isLast = false;
        let showReorder = false;
        
        // Se encontrou via findParentGroup (grupos)
        if (parentGroupInfo) {
          const parentGroup = parentGroupInfo.group;
          childIndex = parentGroupInfo.index;
          children = parentGroup.properties.children || [];
          isFirst = childIndex === 0;
          isLast = childIndex === children.length - 1;
          showReorder = true;
        }
        // Se encontrou via findNodeWithParent (columns, table)
        else if (nodeWithParent && nodeWithParent.parent && nodeWithParent.ctx) {
          const ctx = nodeWithParent.ctx;
          if (ctx.kind === 'columns') {
            const col = nodeWithParent.parent.properties.columns[ctx.colIndex];
            children = col.children || [];
            childIndex = ctx.index;
            isFirst = childIndex === 0;
            isLast = childIndex === children.length - 1;
            showReorder = true;
          } else if (ctx.kind === 'tableCell') {
            const cell = nodeWithParent.parent.properties.body[ctx.row][ctx.col];
            children = cell.children || [];
            childIndex = ctx.index;
            isFirst = childIndex === 0;
            isLast = childIndex === children.length - 1;
            showReorder = true;
          }
        }
        
        // Adicionar bot√µes de reordena√ß√£o para elementos dentro de containers
        if (showReorder && children.length > 1) {
          html += `
            <div class="inspector-field" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e5e7eb;">
              <label style="margin-bottom: 0.75rem; display: block; font-weight: 500;">Reordenar Elemento</label>
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                <button id="btn-move-first" onclick="moveElementInContainer('first')" 
                        style="padding: 0.5rem; background: ${isFirst ? '#e5e7eb' : '#2563eb'}; color: ${isFirst ? '#9ca3af' : 'white'}; border: none; border-radius: 0.375rem; cursor: ${isFirst ? 'not-allowed' : 'pointer'}; font-size: 0.875rem;"
                        ${isFirst ? 'disabled' : ''}>
                  ‚èÆÔ∏è Primeiro
                </button>
                <button id="btn-move-prev" onclick="moveElementInContainer('prev')" 
                        style="padding: 0.5rem; background: ${isFirst ? '#e5e7eb' : '#2563eb'}; color: ${isFirst ? '#9ca3af' : 'white'}; border: none; border-radius: 0.375rem; cursor: ${isFirst ? 'not-allowed' : 'pointer'}; font-size: 0.875rem;"
                        ${isFirst ? 'disabled' : ''}>
                  ‚¨ÖÔ∏è Anterior
                </button>
                <button id="btn-move-next" onclick="moveElementInContainer('next')" 
                        style="padding: 0.5rem; background: ${isLast ? '#e5e7eb' : '#2563eb'}; color: ${isLast ? '#9ca3af' : 'white'}; border: none; border-radius: 0.375rem; cursor: ${isLast ? 'not-allowed' : 'pointer'}; font-size: 0.875rem;"
                        ${isLast ? 'disabled' : ''}>
                  ‚û°Ô∏è Pr√≥ximo
                </button>
                <button id="btn-move-last" onclick="moveElementInContainer('last')" 
                        style="padding: 0.5rem; background: ${isLast ? '#e5e7eb' : '#2563eb'}; color: ${isLast ? '#9ca3af' : 'white'}; border: none; border-radius: 0.375rem; cursor: ${isLast ? 'not-allowed' : 'pointer'}; font-size: 0.875rem;"
                        ${isLast ? 'disabled' : ''}>
                  ‚è≠Ô∏è √öltimo
                </button>
              </div>
            </div>
          `;
        }
        
        // Show width and height fields only for elements in groups
        if (parentGroupInfo) {
          const parentGroup = parentGroupInfo.group;
          if (parentGroup.properties.orientation === 'row') {
            // Show width field for elements in horizontal groups
            const currentWidth = element.width !== null && element.width !== undefined ? element.width : (100 / (parentGroup.properties.children?.length || 1));
            html += `
              <div class="inspector-field">
                <label>Largura (%)</label>
                <input type="number" id="insp-width" value="${Math.round(currentWidth)}" step="1">
                <div class="smallNote">Largura do elemento dentro do grupo. O espa√ßo restante ser√° distribu√≠do entre os outros elementos.</div>
              </div>
            `;
          }          
        }
      }
      
      // Se o elemento √© columns, adicionar op√ß√µes para reordenar e deletar colunas
      if (element.type === 'columns') {
        const cols = element.properties.columns || [];
        if (cols.length > 0) {
          html += `
            <div class="inspector-field" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e5e7eb;">
              <label style="margin-bottom: 0.75rem; display: block; font-weight: 500;">Reordenar Colunas</label>
              <div class="smallNote" style="margin-bottom: 0.5rem;">Selecione uma coluna abaixo para mov√™-la</div>
          `;
          cols.forEach((col, colIndex) => {
            const isFirstCol = colIndex === 0;
            const isLastCol = colIndex === cols.length - 1;
            //const canDelete = cols.length > 1; // S√≥ pode deletar se tiver mais de 1 coluna
            html += `
              <div style="margin-bottom: 0.5rem;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.25rem;">
                  <span style="font-size: 0.875rem; color: rgba(255, 255, 255, 0.6);">Coluna ${colIndex + 1}</span>
                </div>
                ${cols.length > 1 ? `
                  <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 0.25rem;">
                    <button onclick="moveColumnInColumns('${element.id}', ${colIndex}, 'first')" 
                            style="padding: 0.25rem; background: ${isFirstCol ? '#e5e7eb' : '#2563eb'}; color: ${isFirstCol ? '#9ca3af' : 'white'}; border: none; border-radius: 0.25rem; cursor: ${isFirstCol ? 'not-allowed' : 'pointer'}; font-size: 0.75rem;"
                            ${isFirstCol ? 'disabled' : ''}>
                      ‚á§
                    </button>
                    <button onclick="moveColumnInColumns('${element.id}', ${colIndex}, 'prev')" 
                            style="padding: 0.25rem; background: ${isFirstCol ? '#e5e7eb' : '#2563eb'}; color: ${isFirstCol ? '#9ca3af' : 'white'}; border: none; border-radius: 0.25rem; cursor: ${isFirstCol ? 'not-allowed' : 'pointer'}; font-size: 0.75rem;"
                            ${isFirstCol ? 'disabled' : ''}>
                      ‚Üê
                    </button>
                    <button onclick="moveColumnInColumns('${element.id}', ${colIndex}, 'next')" 
                            style="padding: 0.25rem; background: ${isLastCol ? '#e5e7eb' : '#2563eb'}; color: ${isLastCol ? '#9ca3af' : 'white'}; border: none; border-radius: 0.25rem; cursor: ${isLastCol ? 'not-allowed' : 'pointer'}; font-size: 0.75rem;"
                            ${isLastCol ? 'disabled' : ''}>
                      ‚Üí
                    </button>
                    <button onclick="moveColumnInColumns('${element.id}', ${colIndex}, 'last')" 
                            style="padding: 0.25rem; background: ${isLastCol ? '#e5e7eb' : '#2563eb'}; color: ${isLastCol ? '#9ca3af' : 'white'}; border: none; border-radius: 0.25rem; cursor: ${isLastCol ? 'not-allowed' : 'pointer'}; font-size: 0.75rem;"
                            ${isLastCol ? 'disabled' : ''}>
                      ‚á•
                    </button>
                  </div>
                ` : ''}
              </div>
            `;
          });
          html += `</div>`;
        }
      }
      
      // Se o elemento √© table, adicionar op√ß√µes para reordenar e deletar colunas da tabela
      if (element.type === 'table') {
        const body = element.properties.body || [];
        if (body.length > 0 && body[0].length > 0) {
          const numCols = body[0].length;
          html += `
            <div class="inspector-field" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e5e7eb;">
              <label style="margin-bottom: 0.75rem; display: block; font-weight: 500;">Reordenar Colunas da Tabela</label>
              <div class="smallNote" style="margin-bottom: 0.5rem;">Selecione uma coluna abaixo para mov√™-la</div>
          `;
          for (let colIndex = 0; colIndex < numCols; colIndex++) {
            const isFirstCol = colIndex === 0;
            const isLastCol = colIndex === numCols - 1;
            const canDelete = numCols > 1; // S√≥ pode deletar se tiver mais de 1 coluna
            html += `
              <div style="margin-bottom: 0.5rem;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.25rem;">
                  <span style="font-size: 0.875rem; color: rgba(255, 255, 255, 0.6);">Coluna ${colIndex + 1}</span>
                </div>
                ${numCols > 1 ? `
                  <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 0.25rem;">
                    <button onclick="moveColumnInTable('${element.id}', ${colIndex}, 'first')" 
                            style="padding: 0.25rem; background: ${isFirstCol ? '#e5e7eb' : '#2563eb'}; color: ${isFirstCol ? '#9ca3af' : 'white'}; border: none; border-radius: 0.25rem; cursor: ${isFirstCol ? 'not-allowed' : 'pointer'}; font-size: 0.75rem;"
                            ${isFirstCol ? 'disabled' : ''}>
                      ‚á§
                    </button>
                    <button onclick="moveColumnInTable('${element.id}', ${colIndex}, 'prev')" 
                            style="padding: 0.25rem; background: ${isFirstCol ? '#e5e7eb' : '#2563eb'}; color: ${isFirstCol ? '#9ca3af' : 'white'}; border: none; border-radius: 0.25rem; cursor: ${isFirstCol ? 'not-allowed' : 'pointer'}; font-size: 0.75rem;"
                            ${isFirstCol ? 'disabled' : ''}>
                      ‚Üê
                    </button>
                    <button onclick="moveColumnInTable('${element.id}', ${colIndex}, 'next')" 
                            style="padding: 0.25rem; background: ${isLastCol ? '#e5e7eb' : '#2563eb'}; color: ${isLastCol ? '#9ca3af' : 'white'}; border: none; border-radius: 0.25rem; cursor: ${isLastCol ? 'not-allowed' : 'pointer'}; font-size: 0.75rem;"
                            ${isLastCol ? 'disabled' : ''}>
                      ‚Üí
                    </button>
                    <button onclick="moveColumnInTable('${element.id}', ${colIndex}, 'last')" 
                            style="padding: 0.25rem; background: ${isLastCol ? '#e5e7eb' : '#2563eb'}; color: ${isLastCol ? '#9ca3af' : 'white'}; border: none; border-radius: 0.25rem; cursor: ${isLastCol ? 'not-allowed' : 'pointer'}; font-size: 0.75rem;"
                            ${isLastCol ? 'disabled' : ''}>
                      ‚á•
                    </button>
                  </div>
                ` : ''}
              </div>
            `;
          }
          html += `</div>`;
        }
      }

      // Render fields based on element type
      switch (element.type) {
        case 'text':
          html += renderInspectorText(element);
          break;
        case 'header':
          html += renderInspectorHeader(element);
          break;
        case 'image':
          html += renderInspectorImage(element);
          break;
        case 'table':
          html += renderInspectorTable(element);
          break;
        case 'columns':
          html += renderInspectorColumns(element);
          break;
        case 'list':
          html += renderInspectorList(element);
          break;
        case 'margin':
          html += renderInspectorMargin(element);
          break;
        case 'pageBreak':
          html += renderInspectorPageBreak(element);
          break;
        case 'qr':
          html += renderInspectorQR(element);
          break;
        case 'svg':
          html += renderInspectorSVG(element);
          break;
        case 'group':
          html += renderInspectorGroup(element);
          break;
      }

      // Adicionar bot√£o de remover no final do inspector
      html += `
        <div class="inspector-field" style="margin-top: 2rem; padding-top: 1.5rem; border-top: 1px solid #e5e7eb;">
          <button class="btn-remove-large" onclick="removeSelectedElement()" style="width: 100%; padding: 0.75rem 1rem; background: #ef4444; color: white; border: none; border-radius: 0.5rem; font-size: 1rem; font-weight: 500; cursor: pointer; transition: background 0.2s;">
            üóëÔ∏è Remover Elemento
          </button>
        </div>
      `;

      inspector.innerHTML = html;
      
      // Attach event listeners (deve ser chamado ap√≥s atualizar o HTML)
      setTimeout(() => {
        attachInspectorListeners(element);
      }, 0);
    }

    // Inspector render functions
    function renderInspectorText(element) {
      const p = element.properties || {};
      
      // Verificar se o elemento est√° dentro de header ou footer
      const isInHeader = isElementInHeader(element.id);
      const isInFooter = isElementInFooter(element.id);
      const isInHeaderFooter = isInHeader || isInFooter;
      
      return `
        <div class="inspector-field">
              <label>Texto</label>
          <textarea id="insp-text">${escapeHtml(p.text || '')}</textarea>
          ${isInHeaderFooter ? `
            <div class="smallNote" style="margin-top: 0.5rem; padding: 0.75rem; background: #dbeafe; border-left: 3px solid #2563eb; border-radius: 0.25rem; color: #1e40af;">
              <strong>üí° Numera√ß√£o de P√°gina:</strong> Use <code>{{pageNumber}}</code> para n√∫mero da p√°gina atual e <code>{{totalPages}}</code> para total de p√°ginas. Exemplo: "P√°gina {{pageNumber}} de {{totalPages}}"
            </div>
          ` : ''}
            </div>
        <div class="inspector-field">
          <label>Link (URL)</label>
          <input type="text" id="insp-link" value="${escapeHtml(p.link || '')}" placeholder="https://exemplo.com ou deixe vazio">
          <div class="smallNote">Deixe vazio se n√£o quiser que o texto seja um link</div>
            </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Tamanho da Fonte</label>
              <input type="number" id="insp-fontSize" value="${p.fontSize || 14}" min="8" max="72">
            </div>
            <div>
              <label class="smallNote">Fonte</label>
              <select id="insp-font">
                <option value="Roboto" ${p.font === 'Roboto' || !p.font ? 'selected' : ''}>Roboto</option>
                <option value="Courier" ${p.font === 'Courier' ? 'selected' : ''}>Courier</option>
                <option value="Helvetica" ${p.font === 'Helvetica' ? 'selected' : ''}>Helvetica</option>
                <option value="Times" ${p.font === 'Times' ? 'selected' : ''}>Times</option>
              </select>
            </div>
            </div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Font Features (fontFeatures)</label>
          <input type="text" id="insp-fontFeatures" value="${p.fontFeatures ? p.fontFeatures.join(', ') : ''}" placeholder="Ex: kern, liga, smcp (separados por v√≠rgula)">
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: #6b7280;">Features tipogr√°ficas avan√ßadas (dependem da fonte TTF). Separe por v√≠rgula.</div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Cor do Texto</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="color" id="insp-color" value="${p.color || '#000000'}" style="width: 50px; height: 32px; cursor: pointer;">
                <input type="text" id="insp-colorText" value="${p.color || '#000000'}" placeholder="#000000" style="flex: 1; font-size: 0.875rem;">
              </div>
            </div>
            <div>
              <label class="smallNote">Cor de Fundo</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="color" id="insp-background" value="${p.background || '#ffffff'}" style="width: 50px; height: 32px; cursor: pointer;">
                <input type="text" id="insp-backgroundText" value="${p.background || ''}" placeholder="Deixe vazio para transparente" style="flex: 1; font-size: 0.875rem;">
              </div>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Alinhamento</label>
              <select id="insp-alignment">
                <option value="left" ${p.alignment === 'left' ? 'selected' : ''}>Esquerda</option>
                <option value="center" ${p.alignment === 'center' ? 'selected' : ''}>Centro</option>
                <option value="right" ${p.alignment === 'right' ? 'selected' : ''}>Direita</option>
                <option value="justify" ${p.alignment === 'justify' ? 'selected' : ''}>Justificado</option>
              </select>
            </div>
            <div>
              <label class="smallNote">Decora√ß√£o</label>
              <select id="insp-decoration">
                <option value="" ${!p.decoration ? 'selected' : ''}>Nenhuma</option>
                <option value="underline" ${p.decoration === 'underline' ? 'selected' : ''}>Sublinhado</option>
                <option value="lineThrough" ${p.decoration === 'lineThrough' ? 'selected' : ''}>Riscado</option>
                <option value="overline" ${p.decoration === 'overline' ? 'selected' : ''}>Sobrelinha</option>
              </select>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label><input type="checkbox" id="insp-bold" ${p.bold ? 'checked' : ''}> Negrito</label>
            </div>
            <div>
              <label><input type="checkbox" id="insp-italics" ${p.italics ? 'checked' : ''}> It√°lico</label>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Altura da Linha (lineHeight)</label>
              <input type="number" id="insp-lineHeight" value="${p.lineHeight || ''}" placeholder="Auto" min="0" max="10" step="0.1">
              <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: #6b7280;">Deixe vazio para autom√°tico</div>
            </div>
            <div>
              <label class="smallNote">Espa√ßamento entre Caracteres</label>
              <input type="number" id="insp-characterSpacing" value="${p.characterSpacing || ''}" placeholder="0" min="0" max="10" step="0.1">
              <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: #6b7280;">Em unidades (0 = normal)</div>
            </div>
          </div>
        </div>
        <div class="inspector-field" id="decorationOptions" style="${!p.decoration ? 'display: none;' : ''}">
          <div class="row">
            <div>
              <label class="smallNote">Estilo da Decora√ß√£o</label>
              <select id="insp-decorationStyle">
                <option value="solid" ${p.decorationStyle === 'solid' || !p.decorationStyle ? 'selected' : ''}>S√≥lida</option>
                <option value="dashed" ${p.decorationStyle === 'dashed' ? 'selected' : ''}>Tracejada</option>
                <option value="dotted" ${p.decorationStyle === 'dotted' ? 'selected' : ''}>Pontilhada</option>
                <option value="double" ${p.decorationStyle === 'double' ? 'selected' : ''}>Dupla</option>
                <option value="wavy" ${p.decorationStyle === 'wavy' ? 'selected' : ''}>Ondulada</option>
              </select>
            </div>
            <div>
              <label class="smallNote">Cor da Decora√ß√£o</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="color" id="insp-decorationColor" value="${p.decorationColor || p.color || '#000000'}" style="width: 50px; height: 32px; cursor: pointer;">
                <input type="text" id="insp-decorationColorText" value="${p.decorationColor || ''}" placeholder="Deixe vazio para usar cor do texto" style="flex: 1; font-size: 0.875rem;">
              </div>
            </div>
          </div>
        </div>
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorHeader(element) {
      const p = element.properties || {};
      return `
        <div class="inspector-field">
              <label>Texto do Cabe√ßalho</label>
          <input type="text" id="insp-headerText" value="${escapeHtml(p.text || '')}">
            </div>
        <div class="inspector-field">
          <label>Link (URL)</label>
          <input type="text" id="insp-headerLink" value="${escapeHtml(p.link || '')}" placeholder="https://exemplo.com ou deixe vazio">
          <div class="smallNote">Deixe vazio se n√£o quiser que o texto seja um link</div>
            </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Tamanho da Fonte</label>
              <input type="number" id="insp-headerFontSize" value="${p.fontSize || 18}" min="8" max="72">
            </div>
            <div>
              <label class="smallNote">Fonte</label>
              <select id="insp-headerFont">
                <option value="Roboto" ${p.font === 'Roboto' || !p.font ? 'selected' : ''}>Roboto</option>
                <option value="Courier" ${p.font === 'Courier' ? 'selected' : ''}>Courier</option>
                <option value="Helvetica" ${p.font === 'Helvetica' ? 'selected' : ''}>Helvetica</option>
                <option value="Times" ${p.font === 'Times' ? 'selected' : ''}>Times</option>
              </select>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Font Features (fontFeatures)</label>
          <input type="text" id="insp-headerFontFeatures" value="${p.fontFeatures ? p.fontFeatures.join(', ') : ''}" placeholder="Ex: kern, liga, smcp (separados por v√≠rgula)">
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: #6b7280;">Features tipogr√°ficas avan√ßadas (dependem da fonte TTF). Separe por v√≠rgula.</div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Cor do Texto</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="color" id="insp-headerColor" value="${p.color || '#000000'}" style="width: 50px; height: 32px; cursor: pointer;">
                <input type="text" id="insp-headerColorText" value="${p.color || '#000000'}" placeholder="#000000" style="flex: 1; font-size: 0.875rem;">
              </div>
            </div>
            <div>
              <label class="smallNote">Cor de Fundo</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="color" id="insp-headerBackground" value="${p.background || '#ffffff'}" style="width: 50px; height: 32px; cursor: pointer;">
                <input type="text" id="insp-headerBackgroundText" value="${p.background || ''}" placeholder="Deixe vazio para transparente" style="flex: 1; font-size: 0.875rem;">
              </div>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Alinhamento</label>
              <select id="insp-headerAlignment">
                <option value="left" ${p.alignment === 'left' ? 'selected' : ''}>Esquerda</option>
                <option value="center" ${p.alignment === 'center' ? 'selected' : ''}>Centro</option>
                <option value="right" ${p.alignment === 'right' ? 'selected' : ''}>Direita</option>
              </select>
            </div>
            <div>
              <label class="smallNote">Decora√ß√£o</label>
              <select id="insp-headerDecoration">
                <option value="" ${!p.decoration ? 'selected' : ''}>Nenhuma</option>
                <option value="underline" ${p.decoration === 'underline' ? 'selected' : ''}>Sublinhado</option>
                <option value="lineThrough" ${p.decoration === 'lineThrough' ? 'selected' : ''}>Riscado</option>
                <option value="overline" ${p.decoration === 'overline' ? 'selected' : ''}>Sobrelinha</option>
              </select>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label><input type="checkbox" id="insp-headerBold" ${p.bold ? 'checked' : ''}> Negrito</label>
            </div>
            <div>
              <label><input type="checkbox" id="insp-headerItalics" ${p.italics ? 'checked' : ''}> It√°lico</label>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Altura da Linha (lineHeight)</label>
              <input type="number" id="insp-headerLineHeight" value="${p.lineHeight || ''}" placeholder="Auto" min="0" max="10" step="0.1">
              <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: #6b7280;">Deixe vazio para autom√°tico</div>
            </div>
            <div>
              <label class="smallNote">Espa√ßamento entre Caracteres</label>
              <input type="number" id="insp-headerCharacterSpacing" value="${p.characterSpacing || ''}" placeholder="0" min="0" max="10" step="0.1">
              <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: #6b7280;">Em unidades (0 = normal)</div>
            </div>
          </div>
        </div>
        <div class="inspector-field" id="headerDecorationOptions" style="${!p.decoration ? 'display: none;' : ''}">
          <div class="row">
            <div>
              <label class="smallNote">Estilo da Decora√ß√£o</label>
              <select id="insp-headerDecorationStyle">
                <option value="solid" ${p.decorationStyle === 'solid' || !p.decorationStyle ? 'selected' : ''}>S√≥lida</option>
                <option value="dashed" ${p.decorationStyle === 'dashed' ? 'selected' : ''}>Tracejada</option>
                <option value="dotted" ${p.decorationStyle === 'dotted' ? 'selected' : ''}>Pontilhada</option>
                <option value="double" ${p.decorationStyle === 'double' ? 'selected' : ''}>Dupla</option>
                <option value="wavy" ${p.decorationStyle === 'wavy' ? 'selected' : ''}>Ondulada</option>
              </select>
            </div>
            <div>
              <label class="smallNote">Cor da Decora√ß√£o</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="color" id="insp-headerDecorationColor" value="${p.decorationColor || p.color || '#000000'}" style="width: 50px; height: 32px; cursor: pointer;">
                <input type="text" id="insp-headerDecorationColorText" value="${p.decorationColor || ''}" placeholder="Deixe vazio para usar cor do texto" style="flex: 1; font-size: 0.875rem;">
              </div>
            </div>
          </div>
        </div>
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorColumns(element) {
      const p = element.properties || {};
      const cols = p.columns || [{ text: 'Coluna 1', width: '*' }, { text: 'Coluna 2', width: '*' }];
      return `
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">N√∫mero de Colunas</label>
              <input type="number" id="insp-colCount" value="${cols.length}" min="2" max="6">
              </div>
            <div>
              <label class="smallNote">Espa√ßamento (gap)</label>
              <input type="number" id="insp-colGap" value="${p.gap || 10}" min="0" max="50">
            </div>
            </div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Alinhamento Vertical</label>
          <select id="insp-colValign">
            <option value="top" ${p.valign === 'top' || !p.valign ? 'selected' : ''}>Topo</option>
            <option value="center" ${p.valign === 'center' ? 'selected' : ''}>Centro</option>
            <option value="bottom" ${p.valign === 'bottom' ? 'selected' : ''}>Inferior</option>
          </select>
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: #6b7280;">Alinhamento vertical do conte√∫do dentro das colunas</div>
        </div>
        <div class="inspector-field" style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid #e5e7eb;">
          <label style="font-weight: 500; margin-bottom: 0.75rem;">Larguras das Colunas</label>
          ${cols.map((col, idx) => {
            const width = col.width || '*';
            let widthType = 'auto';
            let widthValue = '';
            
            if (width === '*') {
              widthType = 'auto';
            } else if (width === 'auto') {
              widthType = 'auto';
            } else if (typeof width === 'number') {
              widthType = 'pixels';
              widthValue = width;
            } else if (typeof width === 'string' && width.endsWith('%')) {
              widthType = 'percentage';
              widthValue = width.replace('%', '');
            } else {
              widthType = 'auto';
            }
            
            return `
              <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: #1f2937; border: 1px solid #374151; border-radius: 0.375rem;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">
                  <label style="font-weight: 500; color: #f3f4f6;">Coluna ${idx + 1}</label>
                  ${idx > 0 ? `
                    <button type="button" class="btn-delete-col" data-col-index="${idx}" style="padding: 0.25rem 0.5rem; background: #ef4444; color: white; border: none; border-radius: 0.25rem; cursor: pointer; font-size: 0.75rem;">üóëÔ∏è</button>
                  ` : ''}
            </div>
                <div class="row">
                  <div style="flex: 1;">
                    <label class="smallNote" style="color: #d1d5db;">Tipo de Largura</label>
                    <select class="col-width-type" data-col-index="${idx}" style="width: 100%; padding: 0.5rem; background: #111827; color: #f3f4f6; border: 1px solid #374151; border-radius: 0.375rem; font-size: 0.875rem;">
                      <option value="auto" ${widthType === 'auto' ? 'selected' : ''}>Autom√°tico (*)</option>
                      <option value="pixels" ${widthType === 'pixels' ? 'selected' : ''}>Pixels (px)</option>
                      <option value="percentage" ${widthType === 'percentage' ? 'selected' : ''}>Porcentagem (%)</option>
                    </select>
              </div>
                  <div style="flex: 1; ${widthType === 'auto' ? 'display: none;' : ''}" id="col-width-value-${idx}">
                    <label class="smallNote" style="color: #d1d5db;">Valor</label>
                    <input type="number" class="col-width-value" data-col-index="${idx}" value="${widthValue}" min="0" step="${widthType === 'percentage' ? '1' : '1'}" placeholder="${widthType === 'percentage' ? '50' : '100'}" style="width: 100%; padding: 0.5rem; background: #111827; color: #f3f4f6; border: 1px solid #374151; border-radius: 0.375rem; font-size: 0.875rem;">
              </div>
            </div>
            </div>
          `;
          }).join('')}
          <div class="smallNote" style="margin-top: 0.5rem; font-size: 0.75rem; color: #d1d5db;">
            <strong style="color: #f3f4f6;">Tipos de largura:</strong><br>
            ‚Ä¢ Autom√°tico (*): divide o espa√ßo igualmente entre as colunas<br>
            ‚Ä¢ Pixels: largura fixa em pontos (ex: 100, 200)<br>
            ‚Ä¢ Porcentagem: largura em % do espa√ßo dispon√≠vel (ex: 30, 50)
          </div>
        </div>
        <div class="inspector-field">
          <label>Conte√∫do das Colunas (uma por linha, separado por "---")</label>
          <textarea id="insp-colTexts" placeholder="Coluna 1&#10;---&#10;Coluna 2">${cols.map(c => c.text || '').join('\n---\n')}</textarea>
          <div class="smallNote">Use "---" em uma linha separada para dividir as colunas</div>
        </div>
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorList(element) {
      const p = element.properties || {};
      const items = p.items || [{ kind: 'text', text: 'Item 1' }, { kind: 'text', text: 'Item 2' }];
      const textItems = items.filter(item => item.kind === 'text').map(item => item.text || '').join('\n');
      const isOrdered = p.ordered || p.listType === 'ol';
      return `
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Tipo</label>
              <select id="insp-listKind">
                <option value="ul" ${!isOrdered ? 'selected' : ''}>N√£o ordenada (ul)</option>
                <option value="ol" ${isOrdered ? 'selected' : ''}>Ordenada (ol)</option>
              </select>
            </div>
          </div>
        </div>
        ${isOrdered ? `
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">N√∫mero Inicial (start)</label>
              <input type="number" id="insp-listStart" value="${p.start || 1}" min="1" max="1000">
            </div>
            <div>
              <label class="smallNote">Tipo de Marcador</label>
              <select id="insp-listType">
                <option value="decimal" ${p.type === 'decimal' || !p.type ? 'selected' : ''}>Decimal (1, 2, 3...)</option>
                <option value="lower-alpha" ${p.type === 'lower-alpha' ? 'selected' : ''}>Min√∫sculas (a, b, c...)</option>
                <option value="upper-alpha" ${p.type === 'upper-alpha' ? 'selected' : ''}>Mai√∫sculas (A, B, C...)</option>
                <option value="lower-roman" ${p.type === 'lower-roman' ? 'selected' : ''}>Romano min√∫sculo (i, ii, iii...)</option>
                <option value="upper-roman" ${p.type === 'upper-roman' ? 'selected' : ''}>Romano mai√∫sculo (I, II, III...)</option>
              </select>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <label><input type="checkbox" id="insp-listReversed" ${p.reversed ? 'checked' : ''}> Lista Reversa (reversed)</label>
          <div class="smallNote">Inverte a ordem num√©rica da lista</div>
        </div>
        ` : `
        <div class="inspector-field">
          <label class="smallNote">Tipo de Marcador</label>
          <select id="insp-listType">
            <option value="disc" ${p.type === 'disc' || !p.type ? 'selected' : ''}>Disco preenchido (‚óè)</option>
            <option value="circle" ${p.type === 'circle' ? 'selected' : ''}>C√≠rculo vazio (‚óã)</option>
            <option value="square" ${p.type === 'square' ? 'selected' : ''}>Quadrado (‚ñ†)</option>
          </select>
        </div>
        `}
        <div class="inspector-field">
          <label>Itens de Texto (um por linha)</label>
          <textarea id="insp-listItems">${textItems}</textarea>
          <div class="smallNote">Voc√™ tamb√©m pode arrastar elementos diretamente na lista para criar itens complexos.</div>
        </div>
        <div class="inspector-field">
          <div class="smallNote">Itens com elementos aninhados: ${items.filter(item => item.kind === 'node').length}</div>
        </div>
        ${!isOrdered ? `
        <div class="inspector-field">
          <label class="smallNote">Cor dos Marcadores (markerColor)</label>
          <div style="display: flex; gap: 0.5rem; align-items: center;">
            <input type="color" id="insp-markerColor" value="${p.markerColor || '#000000'}" style="width: 50px; height: 32px; cursor: pointer;">
            <input type="text" id="insp-markerColorText" value="${p.markerColor || ''}" placeholder="Deixe vazio para usar cor padr√£o" style="flex: 1; font-size: 0.875rem;">
          </div>
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: #6b7280;">Aplica-se apenas a listas n√£o ordenadas (ul)</div>
        </div>
        ` : ''}
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorTable(element) {
      const p = element.properties || {};
      const body = p.body || [];
      const numRows = body.length || 2;
      const numCols = body[0]?.length || 3;
      const numDataRows = Math.max(0, numRows - 1); // Linhas de dados (excluindo header)
      
      return `
        <div class="inspector-field">
          <div class="smallNote" style="padding: 0.75rem; background: #111827; border-left: 3px solid #2563eb; margin-bottom: 1rem; border-radius: 0.25rem;">
            <strong>üìã Estrutura da Tabela:</strong><br>
            ‚Ä¢ <strong>Linha 1</strong> = Cabe√ßalho (nomes das colunas)<br>
            ‚Ä¢ <strong>Linhas ${numRows > 1 ? '2-' + numRows : '2'}</strong> = Dados da tabela
          </div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Colunas</label>
              <input type="number" id="insp-tableCols" value="${numCols}" min="1" max="10">
            </div>
            <div>
              <label class="smallNote">Linhas de Dados</label>
              <input type="number" id="insp-tableRows" value="${numDataRows}" min="1" max="20">
              <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: #6b7280;">
                (Total: ${numRows} linhas incluindo cabe√ßalho)
              </div>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Layout</label>
          <select id="insp-tableLayout">
            <option value="lightHorizontalLines" ${p.layout === 'lightHorizontalLines' || !p.layout ? 'selected' : ''}>Linhas Horizontais</option>
            <option value="headerLineOnly" ${p.layout === 'headerLineOnly' ? 'selected' : ''}>Apenas Header</option>
            <option value="noBorders" ${p.layout === 'noBorders' ? 'selected' : ''}>Sem Bordas</option>
            <option value="custom" ${p.layout === 'custom' || (p.customLayout && Object.keys(p.customLayout).length > 0) ? 'selected' : ''}>Customizado</option>
          </select>
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: #6b7280;">Escolha "Customizado" para definir cores e larguras das linhas manualmente</div>
        </div>
        
        ${(p.layout === 'custom' || (p.customLayout && Object.keys(p.customLayout).length > 0)) ? `
        <div style="margin-top: 0.5rem;">
          <button type="button" id="btn-show-custom-layout" onclick="document.getElementById('tableCustomLayoutOptions').style.display = 'block'; this.style.display = 'none';" style="padding: 0.5rem; background: #2563eb; color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-size: 0.875rem;">Mostrar Op√ß√µes de Layout Customizado</button>
        </div>
        ` : ''}
        ${(p.layout === 'custom' || (p.customLayout && Object.keys(p.customLayout).length > 0)) ? `
        <div class="inspector-field" id="tableCustomLayoutOptions">
          <label style="font-weight: 500; margin-bottom: 0.75rem; color: #f3f4f6;">Layout Customizado</label>
          
          <div style="margin-bottom: 1rem;">
            <label class="smallNote" style="color: #d1d5db;">Linhas Horizontais</label>
            <div class="row" style="margin-top: 0.5rem;">
              <div style="flex: 1;">
                <label class="smallNote" style="color: #d1d5db; font-size: 0.75rem;">Largura (px)</label>
                <input type="number" id="insp-tableHLineWidth" value="${p.customLayout?.hLineWidth || 1}" min="0" max="10" step="0.1" style="width: 100%; padding: 0.5rem; background: #111827; color: #f3f4f6; border: 1px solid #374151; border-radius: 0.375rem; font-size: 0.875rem;">
              </div>
              <div style="flex: 1;">
                <label class="smallNote" style="color: #d1d5db; font-size: 0.75rem;">Cor</label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <input type="color" id="insp-tableHLineColor" value="${p.customLayout?.hLineColor || '#000000'}" style="width: 50px; height: 32px; cursor: pointer;">
                  <input type="text" id="insp-tableHLineColorText" value="${p.customLayout?.hLineColor || '#000000'}" placeholder="#000000" style="flex: 1; padding: 0.5rem; background: #111827; color: #f3f4f6; border: 1px solid #374151; border-radius: 0.375rem; font-size: 0.875rem;">
                </div>
              </div>
            </div>
          </div>
          
          <div style="margin-bottom: 1rem;">
            <label class="smallNote" style="color: #d1d5db;">Linhas Verticais</label>
            <div class="row" style="margin-top: 0.5rem;">
              <div style="flex: 1;">
                <label class="smallNote" style="color: #d1d5db; font-size: 0.75rem;">Largura (px)</label>
                <input type="number" id="insp-tableVLineWidth" value="${p.customLayout?.vLineWidth || 1}" min="0" max="10" step="0.1" style="width: 100%; padding: 0.5rem; background: #111827; color: #f3f4f6; border: 1px solid #374151; border-radius: 0.375rem; font-size: 0.875rem;">
              </div>
              <div style="flex: 1;">
                <label class="smallNote" style="color: #d1d5db; font-size: 0.75rem;">Cor</label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <input type="color" id="insp-tableVLineColor" value="${p.customLayout?.vLineColor || '#000000'}" style="width: 50px; height: 32px; cursor: pointer;">
                  <input type="text" id="insp-tableVLineColorText" value="${p.customLayout?.vLineColor || '#000000'}" placeholder="#000000" style="flex: 1; padding: 0.5rem; background: #111827; color: #f3f4f6; border: 1px solid #374151; border-radius: 0.375rem; font-size: 0.875rem;">
                </div>
              </div>
            </div>
          </div>
          
          <div style="margin-bottom: 1rem;">
            <label class="smallNote" style="color: #d1d5db;">Padding das C√©lulas</label>
            <div class="row" style="margin-top: 0.5rem;">
              <div style="flex: 1;">
                <label class="smallNote" style="color: #d1d5db; font-size: 0.75rem;">Esquerda</label>
                <input type="number" id="insp-tablePaddingLeft" value="${p.customLayout?.paddingLeft || 5}" min="0" max="50" style="width: 100%; padding: 0.5rem; background: #111827; color: #f3f4f6; border: 1px solid #374151; border-radius: 0.375rem; font-size: 0.875rem;">
              </div>
              <div style="flex: 1;">
                <label class="smallNote" style="color: #d1d5db; font-size: 0.75rem;">Direita</label>
                <input type="number" id="insp-tablePaddingRight" value="${p.customLayout?.paddingRight || 5}" min="0" max="50" style="width: 100%; padding: 0.5rem; background: #111827; color: #f3f4f6; border: 1px solid #374151; border-radius: 0.375rem; font-size: 0.875rem;">
              </div>
            </div>
            <div class="row" style="margin-top: 0.5rem;">
              <div style="flex: 1;">
                <label class="smallNote" style="color: #d1d5db; font-size: 0.75rem;">Topo</label>
                <input type="number" id="insp-tablePaddingTop" value="${p.customLayout?.paddingTop || 5}" min="0" max="50" style="width: 100%; padding: 0.5rem; background: #111827; color: #f3f4f6; border: 1px solid #374151; border-radius: 0.375rem; font-size: 0.875rem;">
              </div>
              <div style="flex: 1;">
                <label class="smallNote" style="color: #d1d5db; font-size: 0.75rem;">Inferior</label>
                <input type="number" id="insp-tablePaddingBottom" value="${p.customLayout?.paddingBottom || 5}" min="0" max="50" style="width: 100%; padding: 0.5rem; background: #111827; color: #f3f4f6; border: 1px solid #374151; border-radius: 0.375rem; font-size: 0.875rem;">
              </div>
            </div>
          </div>
          
          <div style="margin-bottom: 1rem;">
            <label class="smallNote" style="color: #d1d5db;">Estilos de Linhas (Dashed)</label>
            <div class="row" style="margin-top: 0.5rem;">
              <div style="flex: 1;">
                <label><input type="checkbox" id="insp-tableHLineStyle" ${p.customLayout?.hLineStyle ? 'checked' : ''}> Linhas Horizontais Tracejadas</label>
                <div class="smallNote" style="margin-top: 0.25rem; color: #d1d5db; font-size: 0.75rem;">
                  Aplica estilo tracejado nas linhas horizontais
                </div>
              </div>
              <div style="flex: 1;">
                <label><input type="checkbox" id="insp-tableVLineStyle" ${p.customLayout?.vLineStyle ? 'checked' : ''}> Linhas Verticais Tracejadas</label>
                <div class="smallNote" style="margin-top: 0.25rem; color: #d1d5db; font-size: 0.75rem;">
                  Aplica estilo tracejado nas linhas verticais
                </div>
              </div>
            </div>
          </div>
          
          <div style="margin-bottom: 1rem;">
            <label class="smallNote" style="color: #d1d5db;">Borda Padr√£o (defaultBorder)</label>
            <div style="margin-top: 0.5rem;">
              <label><input type="checkbox" id="insp-tableDefaultBorder" ${p.customLayout?.defaultBorder !== false ? 'checked' : ''}> Usar Bordas Padr√£o</label>
              <div class="smallNote" style="margin-top: 0.25rem; color: #d1d5db; font-size: 0.75rem;">
                Se desmarcado, apenas c√©lulas com border definido ter√£o bordas
              </div>
            </div>
          </div>
        </div>
        ` : ''}
        
        <div class="inspector-field" style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid #374151;">
          <label style="font-weight: 500; margin-bottom: 0.75rem; color: #f3f4f6;">Tabela Zebrada</label>
          <div style="margin-bottom: 1rem;">
            <label><input type="checkbox" id="insp-tableZebraEnabled" ${p.zebraEnabled ? 'checked' : ''}> Ativar Tabela Zebrada</label>
            <div class="smallNote" style="margin-top: 0.5rem; color: #d1d5db; font-size: 0.75rem;">
              Alterna cores de fundo entre linhas para facilitar a leitura
            </div>
          </div>
          
          ${p.zebraEnabled ? `
          <div id="tableZebraOptions" style="margin-top: 1rem; padding: 1rem; background: #1f2937; border: 1px solid #374151; border-radius: 0.375rem;">
            <div style="margin-bottom: 1rem;">
              <label class="smallNote" style="color: #d1d5db; font-size: 0.75rem; margin-bottom: 0.5rem; display: block;">Cor Base (linhas pares)</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="color" id="insp-tableZebraColor" value="${p.zebraColor || '#CCCCCC'}" style="width: 50px; height: 32px; cursor: pointer;">
                <input type="text" id="insp-tableZebraColorText" value="${p.zebraColor || '#CCCCCC'}" placeholder="#CCCCCC" style="flex: 1; padding: 0.5rem; background: #111827; color: #f3f4f6; border: 1px solid #374151; border-radius: 0.375rem; font-size: 0.875rem;">
              </div>
              <div class="smallNote" style="margin-top: 0.5rem; color: #d1d5db; font-size: 0.75rem;">
                A cor das linhas √≠mpares ser√° gerada automaticamente com 50% de opacidade
              </div>
            </div>
            
            <div style="margin-bottom: 1rem;">
              <label><input type="checkbox" id="insp-tableZebraWithLines" ${p.zebraWithLines !== false ? 'checked' : ''}> Mostrar Linhas Horizontais</label>
              <div class="smallNote" style="margin-top: 0.5rem; color: #d1d5db; font-size: 0.75rem;">
                Adiciona linhas horizontais entre as linhas da tabela
              </div>
            </div>
          </div>
          ` : ''}
        </div>
        <div class="inspector-field" style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid #374151;">
          <label style="font-weight: 500; margin-bottom: 0.75rem; color: #f3f4f6;">Estilos das C√©lulas</label>
          <div class="smallNote" style="margin-bottom: 0.75rem; color: #d1d5db; font-size: 0.75rem;">
            Configure cores de fundo e texto para as c√©lulas da tabela. A primeira linha √© o cabe√ßalho.
          </div>
          
          ${Array.from({ length: numRows }, (_, rowIdx) => {
            const isHeader = rowIdx === 0;
            return Array.from({ length: numCols }, (_, colIdx) => {
              const cell = body[rowIdx]?.[colIdx] || { children: [] };
              const cellFillColor = cell.fillColor || '';
              const cellColor = cell.color || '';
              const cellFillOpacity = cell.fillOpacity !== undefined ? cell.fillOpacity : 1;
              
              return `
                <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: #1f2937; border: 1px solid #374151; border-radius: 0.375rem;">
                  <label style="font-weight: 500; color: #f3f4f6; margin-bottom: 0.5rem; display: block;">
                    ${isHeader ? 'üîµ' : '‚ö™'} ${isHeader ? 'Cabe√ßalho' : 'Linha'} ${rowIdx + 1}, Coluna ${colIdx + 1}
                  </label>
                  
                  <div style="margin-bottom: 0.5rem;">
                    <label class="smallNote" style="color: #d1d5db; font-size: 0.75rem;">Cor de Fundo (fillColor)</label>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                      <input type="color" class="table-cell-fill-color" data-row="${rowIdx}" data-col="${colIdx}" value="${cellFillColor || '#ffffff'}" style="width: 50px; height: 32px; cursor: pointer;">
                      <input type="text" class="table-cell-fill-color-text" data-row="${rowIdx}" data-col="${colIdx}" value="${cellFillColor || ''}" placeholder="Deixe vazio para transparente" style="flex: 1; padding: 0.5rem; background: #111827; color: #f3f4f6; border: 1px solid #374151; border-radius: 0.375rem; font-size: 0.875rem;">
                    </div>
                  </div>
                  
                  <div style="margin-bottom: 0.5rem;">
                    <label class="smallNote" style="color: #d1d5db; font-size: 0.75rem;">Cor do Texto (color)</label>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                      <input type="color" class="table-cell-color" data-row="${rowIdx}" data-col="${colIdx}" value="${cellColor || '#000000'}" style="width: 50px; height: 32px; cursor: pointer;">
                      <input type="text" class="table-cell-color-text" data-row="${rowIdx}" data-col="${colIdx}" value="${cellColor || ''}" placeholder="Deixe vazio para cor padr√£o" style="flex: 1; padding: 0.5rem; background: #111827; color: #f3f4f6; border: 1px solid #374151; border-radius: 0.375rem; font-size: 0.875rem;">
                    </div>
                  </div>
                  
                  <div>
                    <label class="smallNote" style="color: #d1d5db; font-size: 0.75rem;">Opacidade do Fundo (fillOpacity)</label>
                    <input type="number" class="table-cell-fill-opacity" data-row="${rowIdx}" data-col="${colIdx}" value="${cellFillOpacity}" min="0" max="1" step="0.1" style="width: 100%; padding: 0.5rem; background: #111827; color: #f3f4f6; border: 1px solid #374151; border-radius: 0.375rem; font-size: 0.875rem;">
                  </div>
                </div>
              `;
            }).join('')
          }).join('')}
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label><input type="checkbox" id="insp-tableDontBreakRows" ${p.dontBreakRows ? 'checked' : ''}> N√£o Quebrar Linhas</label>
              <div class="smallNote">Previne quebra de linhas entre p√°ginas</div>
            </div>
            <div>
              <label class="smallNote">Manter com Header (keepWithHeaderRows)</label>
              <input type="number" id="insp-tableKeepWithHeaderRows" value="${p.keepWithHeaderRows || 0}" min="0" max="10">
              <div class="smallNote">N√∫mero de linhas para manter com cabe√ßalho</div>
            </div>
          </div>
        </div>
        <div class="inspector-field" style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid #374151;">
          <label style="font-weight: 500; margin-bottom: 0.75rem; color: #f3f4f6;">Larguras das Colunas</label>
          ${Array.from({ length: numCols }, (_, idx) => {
            const widths = p.widths || [];
            const width = widths[idx] || '*';
            let widthType = 'auto';
            let widthValue = '';
            
            if (width === '*' || width === 'auto') {
              widthType = 'auto';
            } else if (typeof width === 'number') {
              widthType = 'pixels';
              widthValue = width;
            } else if (typeof width === 'string' && width.endsWith('%')) {
              widthType = 'percentage';
              widthValue = width.replace('%', '');
            } else {
              widthType = 'auto';
            }
            
            return `
              <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: #1f2937; border: 1px solid #374151; border-radius: 0.375rem;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">
                  <label style="font-weight: 500; color: #f3f4f6;">Coluna ${idx + 1}</label>
                  ${idx > 0 ? `
                    <button type="button" class="btn-delete-table-col" data-col-index="${idx}" style="padding: 0.25rem 0.5rem; background: #ef4444; color: white; border: none; border-radius: 0.25rem; cursor: pointer; font-size: 0.75rem;">üóëÔ∏è</button>
                  ` : ''}
                </div>
                <div class="row">
                  <div style="flex: 1;">
                    <label class="smallNote" style="color: #d1d5db;">Tipo de Largura</label>
                    <select class="table-col-width-type" data-col-index="${idx}" style="width: 100%; padding: 0.5rem; background: #111827; color: #f3f4f6; border: 1px solid #374151; border-radius: 0.375rem; font-size: 0.875rem;">
                      <option value="auto" ${widthType === 'auto' ? 'selected' : ''}>Autom√°tico (*)</option>
                      <option value="pixels" ${widthType === 'pixels' ? 'selected' : ''}>Pixels (px)</option>
                      <option value="percentage" ${widthType === 'percentage' ? 'selected' : ''}>Porcentagem (%)</option>
                    </select>
                  </div>
                  <div style="flex: 1; ${widthType === 'auto' ? 'display: none;' : ''}" id="table-col-width-value-${idx}">
                    <label class="smallNote" style="color: #d1d5db;">Valor</label>
                    <input type="number" class="table-col-width-value" data-col-index="${idx}" value="${widthValue}" min="0" step="${widthType === 'percentage' ? '1' : '1'}" placeholder="${widthType === 'percentage' ? '50' : '100'}" style="width: 100%; padding: 0.5rem; background: #111827; color: #f3f4f6; border: 1px solid #374151; border-radius: 0.375rem; font-size: 0.875rem;">
                  </div>
                </div>
              </div>
            `;
          }).join('')}
          <div class="smallNote" style="margin-top: 0.5rem; font-size: 0.75rem; color: #d1d5db;">
            <strong style="color: #f3f4f6;">Tipos de largura:</strong><br>
            ‚Ä¢ Autom√°tico (*): divide o espa√ßo igualmente entre as colunas<br>
            ‚Ä¢ Pixels: largura fixa em pontos (ex: 100, 200)<br>
            ‚Ä¢ Porcentagem: largura em % do espa√ßo dispon√≠vel (ex: 30, 50)
          </div>
        </div>
        <div class="inspector-field" style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid #374151;">
          <label style="font-weight: 500; margin-bottom: 0.75rem; color: #f3f4f6;">Altura das Linhas (heights)</label>
          <div class="smallNote" style="margin-bottom: 0.75rem; color: #d1d5db; font-size: 0.75rem;">
            Defina a altura das linhas da tabela. Pode ser um valor fixo para todas, um array por linha, ou uma fun√ß√£o.
          </div>
          <div class="row">
            <div style="flex: 1;">
              <label class="smallNote" style="color: #d1d5db;">Tipo</label>
              <select id="insp-tableHeightsType" style="width: 100%; padding: 0.5rem; background: #111827; color: #f3f4f6; border: 1px solid #374151; border-radius: 0.375rem; font-size: 0.875rem;">
                <option value="none" ${!p.heights ? 'selected' : ''}>N√£o Definir</option>
                <option value="fixed" ${p.heights && typeof p.heights === 'number' ? 'selected' : ''}>Valor Fixo (todas as linhas)</option>
                <option value="array" ${p.heights && Array.isArray(p.heights) ? 'selected' : ''}>Array (por linha)</option>
              </select>
            </div>
            <div style="flex: 1; ${!p.heights || typeof p.heights !== 'number' ? 'display: none;' : ''}" id="table-heights-fixed">
              <label class="smallNote" style="color: #d1d5db;">Altura Fixa (px)</label>
              <input type="number" id="insp-tableHeightsFixed" value="${p.heights && typeof p.heights === 'number' ? p.heights : 40}" min="0" step="1" style="width: 100%; padding: 0.5rem; background: #111827; color: #f3f4f6; border: 1px solid #374151; border-radius: 0.375rem; font-size: 0.875rem;">
            </div>
          </div>
          ${p.heights && Array.isArray(p.heights) ? `
          <div style="margin-top: 1rem;">
            <label class="smallNote" style="color: #d1d5db; margin-bottom: 0.5rem; display: block;">Alturas por Linha</label>
            ${Array.from({ length: numRows }, (_, idx) => {
              const height = p.heights[idx] || 40;
              return `
                <div style="margin-bottom: 0.5rem;">
                  <label class="smallNote" style="color: #d1d5db; font-size: 0.75rem;">Linha ${idx + 1}</label>
                  <input type="number" class="table-row-height" data-row="${idx}" value="${height}" min="0" step="1" style="width: 100%; padding: 0.5rem; background: #111827; color: #f3f4f6; border: 1px solid #374151; border-radius: 0.375rem; font-size: 0.875rem;">
                </div>
              `;
            }).join('')}
          </div>
          ` : ''}
        </div>
        <div class="inspector-field" style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid #374151;">
          <label style="font-weight: 500; margin-bottom: 0.75rem; color: #f3f4f6;">Propriedades Avan√ßadas das C√©lulas</label>
          <div class="smallNote" style="margin-bottom: 0.75rem; color: #d1d5db; font-size: 0.75rem;">
            Configure rowSpan, colSpan, border e borderColor para c√©lulas individuais.
          </div>
          
          ${Array.from({ length: numRows }, (_, rowIdx) => {
            const isHeader = rowIdx === 0;
            return Array.from({ length: numCols }, (_, colIdx) => {
              const cell = body[rowIdx]?.[colIdx] || { children: [] };
              const rowSpan = cell.rowSpan || 1;
              const colSpan = cell.colSpan || 1;
              const border = cell.border || [true, true, true, true];
              const borderColor = cell.borderColor || ['', '', '', ''];
              
              return `
                <div style="margin-bottom: 1rem; padding: 0.75rem; background: #1f2937; border: 1px solid #374151; border-radius: 0.375rem;">
                  <label style="font-weight: 500; color: #f3f4f6; margin-bottom: 0.75rem; display: block;">
                    ${isHeader ? 'üîµ' : '‚ö™'} ${isHeader ? 'Cabe√ßalho' : 'Linha'} ${rowIdx + 1}, Coluna ${colIdx + 1}
                  </label>
                  
                  <div class="row" style="margin-bottom: 0.75rem;">
                    <div style="flex: 1;">
                      <label class="smallNote" style="color: #d1d5db; font-size: 0.75rem;">rowSpan</label>
                      <input type="number" class="table-cell-rowspan" data-row="${rowIdx}" data-col="${colIdx}" value="${rowSpan}" min="1" max="10" style="width: 100%; padding: 0.5rem; background: #111827; color: #f3f4f6; border: 1px solid #374151; border-radius: 0.375rem; font-size: 0.875rem;">
            </div>
                    <div style="flex: 1;">
                      <label class="smallNote" style="color: #d1d5db; font-size: 0.75rem;">colSpan</label>
                      <input type="number" class="table-cell-colspan" data-row="${rowIdx}" data-col="${colIdx}" value="${colSpan}" min="1" max="10" style="width: 100%; padding: 0.5rem; background: #111827; color: #f3f4f6; border: 1px solid #374151; border-radius: 0.375rem; font-size: 0.875rem;">
            </div>
                  </div>
                  
                  <div style="margin-bottom: 0.75rem;">
                    <label class="smallNote" style="color: #d1d5db; font-size: 0.75rem; margin-bottom: 0.5rem; display: block;">Bordas (border) - [esquerda, topo, direita, inferior]</label>
                    <div class="row">
                      <div style="flex: 1;">
                        <label class="smallNote" style="color: #d1d5db; font-size: 0.7rem;">Esquerda</label>
                        <input type="checkbox" class="table-cell-border" data-row="${rowIdx}" data-col="${colIdx}" data-side="0" ${border[0] ? 'checked' : ''} style="width: 100%;">
                      </div>
                      <div style="flex: 1;">
                        <label class="smallNote" style="color: #d1d5db; font-size: 0.7rem;">Topo</label>
                        <input type="checkbox" class="table-cell-border" data-row="${rowIdx}" data-col="${colIdx}" data-side="1" ${border[1] ? 'checked' : ''} style="width: 100%;">
                      </div>
                      <div style="flex: 1;">
                        <label class="smallNote" style="color: #d1d5db; font-size: 0.7rem;">Direita</label>
                        <input type="checkbox" class="table-cell-border" data-row="${rowIdx}" data-col="${colIdx}" data-side="2" ${border[2] ? 'checked' : ''} style="width: 100%;">
                      </div>
                      <div style="flex: 1;">
                        <label class="smallNote" style="color: #d1d5db; font-size: 0.7rem;">Inferior</label>
                        <input type="checkbox" class="table-cell-border" data-row="${rowIdx}" data-col="${colIdx}" data-side="3" ${border[3] ? 'checked' : ''} style="width: 100%;">
                      </div>
                    </div>
                  </div>
                  
                  <div>
                    <label class="smallNote" style="color: #d1d5db; font-size: 0.75rem; margin-bottom: 0.5rem; display: block;">Cores das Bordas (borderColor) - [esquerda, topo, direita, inferior]</label>
                    <div class="row">
                      <div style="flex: 1;">
                        <label class="smallNote" style="color: #d1d5db; font-size: 0.7rem;">Esquerda</label>
                        <input type="color" class="table-cell-border-color" data-row="${rowIdx}" data-col="${colIdx}" data-side="0" value="${borderColor[0] || '#000000'}" style="width: 100%; height: 32px; cursor: pointer;">
                      </div>
                      <div style="flex: 1;">
                        <label class="smallNote" style="color: #d1d5db; font-size: 0.7rem;">Topo</label>
                        <input type="color" class="table-cell-border-color" data-row="${rowIdx}" data-col="${colIdx}" data-side="1" value="${borderColor[1] || '#000000'}" style="width: 100%; height: 32px; cursor: pointer;">
                      </div>
                      <div style="flex: 1;">
                        <label class="smallNote" style="color: #d1d5db; font-size: 0.7rem;">Direita</label>
                        <input type="color" class="table-cell-border-color" data-row="${rowIdx}" data-col="${colIdx}" data-side="2" value="${borderColor[2] || '#000000'}" style="width: 100%; height: 32px; cursor: pointer;">
                      </div>
                      <div style="flex: 1;">
                        <label class="smallNote" style="color: #d1d5db; font-size: 0.7rem;">Inferior</label>
                        <input type="color" class="table-cell-border-color" data-row="${rowIdx}" data-col="${colIdx}" data-side="3" value="${borderColor[3] || '#000000'}" style="width: 100%; height: 32px; cursor: pointer;">
                      </div>
                    </div>
                  </div>
                </div>
              `;
            }).join('')
          }).join('')}
        </div>
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorImage(element) {
      const p = element.properties || {};
      const useFit = p.fit !== undefined;
      const useCover = p.cover !== undefined;
      const useAbsolutePosition = p.absolutePosition !== undefined;
      const useRelativePosition = p.relativePosition !== undefined;
      return `
        <div class="inspector-field">
          <label>URL da Imagem</label>
          <input type="text" id="insp-imageUrl" value="${escapeHtml(p.url || '')}" placeholder="https://exemplo.com/imagem.jpg">
          <div class="smallNote">Cole a URL completa da imagem</div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Modo de Dimensionamento</label>
          <select id="insp-imageSizeMode">
            <option value="widthHeight" ${!useFit && !useCover ? 'selected' : ''}>Largura e Altura</option>
            <option value="fit" ${useFit ? 'selected' : ''}>Fit (Ajustar mantendo propor√ß√£o)</option>
            <option value="cover" ${useCover ? 'selected' : ''}>Cover (Preencher √°rea)</option>
              </select>
            </div>
        <div id="imageWidthHeightOptions" style="${useFit || useCover ? 'display: none;' : ''}">
          <div class="inspector-field">
            <div class="row">
              <div>
                <label class="smallNote">Largura</label>
                <input type="number" id="insp-imageWidth" value="${p.width || ''}" min="10" max="500" placeholder="Auto">
              </div>
              <div>
                <label class="smallNote">Altura</label>
                <input type="number" id="insp-imageHeight" value="${p.height || ''}" min="10" max="500" placeholder="Auto">
              </div>
            </div>
          </div>
        </div>
        <div id="imageFitOptions" style="${!useFit ? 'display: none;' : ''}">
          <div class="inspector-field">
            <div class="row">
              <div>
                <label class="smallNote">Fit Width</label>
                <input type="number" id="insp-imageFitWidth" value="${Array.isArray(p.fit) ? p.fit[0] : (p.fit || 100)}" min="10" max="500">
              </div>
              <div>
                <label class="smallNote">Fit Height</label>
                <input type="number" id="insp-imageFitHeight" value="${Array.isArray(p.fit) ? p.fit[1] : (p.fit || 100)}" min="10" max="500">
              </div>
            </div>
            <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: #6b7280;">Ajusta a imagem mantendo a propor√ß√£o</div>
          </div>
        </div>
        <div id="imageCoverOptions" style="${!useCover ? 'display: none;' : ''}">
          <div class="inspector-field">
            <div class="row">
              <div>
                <label class="smallNote">Cover Width</label>
                <input type="number" id="insp-imageCoverWidth" value="${p.cover?.width || 300}" min="10" max="500">
              </div>
              <div>
                <label class="smallNote">Cover Height</label>
                <input type="number" id="insp-imageCoverHeight" value="${p.cover?.height || 150}" min="10" max="500">
              </div>
            </div>
          </div>
          <div class="inspector-field">
            <div class="row">
              <div>
                <label class="smallNote">Cover Align</label>
                <select id="insp-imageCoverAlign">
                  <option value="left" ${p.cover?.align === 'left' ? 'selected' : ''}>Esquerda</option>
                  <option value="center" ${p.cover?.align === 'center' || !p.cover?.align ? 'selected' : ''}>Centro</option>
                  <option value="right" ${p.cover?.align === 'right' ? 'selected' : ''}>Direita</option>
                </select>
              </div>
              <div>
                <label class="smallNote">Cover Valign</label>
                <select id="insp-imageCoverValign">
                  <option value="top" ${p.cover?.valign === 'top' ? 'selected' : ''}>Topo</option>
                  <option value="center" ${p.cover?.valign === 'center' || !p.cover?.valign ? 'selected' : ''}>Centro</option>
                  <option value="bottom" ${p.cover?.valign === 'bottom' ? 'selected' : ''}>Inferior</option>
                </select>
              </div>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Border Radius</label>
          <input type="number" id="insp-imageBorderRadius" value="${p.borderRadius || 0}" min="0" max="1000" step="1" placeholder="0">
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: #6b7280;">Apenas o n√∫mero (ex: 30, 50, 100). 0 = sem arredondamento</div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Opacidade (0.0 - 1.0)</label>
          <input type="number" id="insp-imageOpacity" value="${p.opacity !== undefined ? p.opacity : ''}" placeholder="1.0" min="0" max="1" step="0.1">
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: #6b7280;">1.0 = totalmente opaco, 0.0 = transparente</div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Alinhamento</label>
          <select id="insp-imageAlignment">
            <option value="left" ${p.alignment === 'left' ? 'selected' : ''}>Esquerda</option>
            <option value="center" ${p.alignment === 'center' ? 'selected' : ''}>Centro</option>
            <option value="right" ${p.alignment === 'right' ? 'selected' : ''}>Direita</option>
          </select>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Tipo de Posicionamento</label>
          <select id="insp-imagePositionType">
            <option value="none" ${!useAbsolutePosition && !useRelativePosition ? 'selected' : ''}>Normal (fluxo do documento)</option>
            <option value="absolute" ${useAbsolutePosition ? 'selected' : ''}>Posi√ß√£o Absoluta</option>
            <option value="relative" ${useRelativePosition ? 'selected' : ''}>Posi√ß√£o Relativa</option>
          </select>
        </div>
        <div id="imageAbsolutePositionOptions" style="${!useAbsolutePosition ? 'display: none;' : ''}">
          <div class="inspector-field">
            <div class="row">
              <div>
                <label class="smallNote">X (absoluto)</label>
                <input type="number" id="insp-imageAbsoluteX" value="${p.absolutePosition?.x || 0}" min="0" step="1">
              </div>
              <div>
                <label class="smallNote">Y (absoluto)</label>
                <input type="number" id="insp-imageAbsoluteY" value="${p.absolutePosition?.y || 0}" min="0" step="1">
              </div>
            </div>
            <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: #6b7280;">Posi√ß√£o em pixels a partir do canto superior esquerdo da p√°gina</div>
          </div>
        </div>
        <div id="imageRelativePositionOptions" style="${!useRelativePosition ? 'display: none;' : ''}">
          <div class="inspector-field">
            <div class="row">
              <div>
                <label class="smallNote">X (relativo)</label>
                <input type="number" id="insp-imageRelativeX" value="${p.relativePosition?.x || 0}" step="1">
              </div>
              <div>
                <label class="smallNote">Y (relativo)</label>
                <input type="number" id="insp-imageRelativeY" value="${p.relativePosition?.y || 0}" step="1">
              </div>
            </div>
            <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: #6b7280;">Deslocamento relativo √† posi√ß√£o atual no fluxo do documento</div>
          </div>
        </div>
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorMargin(element) {
      const p = element.properties || {};
      // Suportar tanto o formato antigo (size) quanto o novo (margin array)
      const marginArray = p.margin || (p.size ? [0, p.size, 0, 0] : [0, 20, 0, 0]);
      return `
        <div class="inspector-field">
          <label>Margens Individuais (px)</label>
          <div class="smallNote" style="margin-bottom: 0.5rem;">Configure as margens: [Esquerda, Topo, Direita, Baixo]</div>
          <div class="row">
            <div>
              <label class="smallNote">Esquerda</label>
              <input type="number" id="insp-marginLeft" value="${marginArray[0] || 0}" min="0" step="1">
            </div>
            <div>
              <label class="smallNote">Topo</label>
              <input type="number" id="insp-marginTop" value="${marginArray[1] || 20}" min="0" step="1">
            </div>
            <div>
              <label class="smallNote">Direita</label>
              <input type="number" id="insp-marginRight" value="${marginArray[2] || 0}" min="0" step="1">
            </div>
            <div>
              <label class="smallNote">Baixo</label>
              <input type="number" id="insp-marginBottom" value="${marginArray[3] || 0}" min="0" step="1">
            </div>
          </div>
          <div class="smallNote" style="margin-top: 0.5rem; font-size: 0.75rem; color: #6b7280;">Formato PDFMake: [left, top, right, bottom]</div>
            </div>
          `;
    }
    
    // Fun√ß√£o auxiliar para renderizar se√ß√£o de margens (reutiliz√°vel para todos os elementos)
    function renderMarginSection(element) {
      const p = element.properties || {};
      const marginArray = p.margin || [0, 0, 0, 0];
      return `
        <div class="inspector-field" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e5e7eb;">
          <label style="font-weight: 500; margin-bottom: 0.5rem;">Margens (px)</label>
          <div class="row">
            <div>
              <label class="smallNote">Esquerda</label>
              <input type="number" class="margin-input" data-side="0" value="${marginArray[0] || 0}" min="0" step="1" placeholder="0">
            </div>
            <div>
              <label class="smallNote">Topo</label>
              <input type="number" class="margin-input" data-side="1" value="${marginArray[1] || 0}" min="0" step="1" placeholder="0">
            </div>
            <div>
              <label class="smallNote">Direita</label>
              <input type="number" class="margin-input" data-side="2" value="${marginArray[2] || 0}" min="0" step="1" placeholder="0">
            </div>
            <div>
              <label class="smallNote">Baixo</label>
              <input type="number" class="margin-input" data-side="3" value="${marginArray[3] || 0}" min="0" step="1" placeholder="0">
            </div>
          </div>
          <div class="smallNote" style="margin-top: 0.5rem; font-size: 0.75rem; color: #6b7280;">Formato: [left, top, right, bottom]</div>
        </div>
      `;
    }

    function renderInspectorPageBreak(element) {
      return `
        <div class="inspector-field">
          <div class="smallNote">Quebra de p√°gina - n√£o h√° propriedades configur√°veis para este elemento.</div>
            </div>
          `;
    }

    function renderInspectorQR(element) {
      const p = element.properties || {};
      return `
        <div class="inspector-field">
          <label>Texto/Dados para QR Code</label>
          <textarea id="insp-qrText" placeholder="URL, texto ou dados para codificar" style="min-height: 60px;">${escapeHtml(p.text || '')}</textarea>
          <div class="smallNote">Pode ser uma URL, texto ou qualquer dado que voc√™ queira codificar no QR Code</div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Tamanho (fit)</label>
              <input type="number" id="insp-qrFit" value="${p.fit || 100}" min="50" max="500">
            </div>
            <div>
              <label class="smallNote">N√≠vel de Corre√ß√£o</label>
              <select id="insp-qrEccLevel">
                <option value="L" ${p.eccLevel === 'L' ? 'selected' : ''}>L (Baixo - 7%)</option>
                <option value="M" ${p.eccLevel === 'M' || !p.eccLevel ? 'selected' : ''}>M (M√©dio - 15%)</option>
                <option value="Q" ${p.eccLevel === 'Q' ? 'selected' : ''}>Q (Alto - 25%)</option>
                <option value="H" ${p.eccLevel === 'H' ? 'selected' : ''}>H (Muito Alto - 30%)</option>
              </select>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Cor do QR Code</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="color" id="insp-qrForeground" value="${p.foreground || '#000000'}" style="width: 50px; height: 32px; cursor: pointer;">
                <input type="text" id="insp-qrForegroundText" value="${p.foreground || '#000000'}" placeholder="#000000" style="flex: 1; font-size: 0.875rem;">
              </div>
            </div>
            <div>
              <label class="smallNote">Cor de Fundo</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="color" id="insp-qrBackground" value="${p.background || '#ffffff'}" style="width: 50px; height: 32px; cursor: pointer;">
                <input type="text" id="insp-qrBackgroundText" value="${p.background || '#ffffff'}" placeholder="#ffffff" style="flex: 1; font-size: 0.875rem;">
              </div>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Alinhamento</label>
          <select id="insp-qrAlignment">
            <option value="left" ${p.alignment === 'left' ? 'selected' : ''}>Esquerda</option>
            <option value="center" ${p.alignment === 'center' || !p.alignment ? 'selected' : ''}>Centro</option>
            <option value="right" ${p.alignment === 'right' ? 'selected' : ''}>Direita</option>
              </select>
            </div>
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorSVG(element) {
      const p = element.properties || {};
      return `
        <div class="inspector-field">
          <label>C√≥digo SVG</label>
          <textarea id="insp-svgCode" placeholder="Cole ou digite o c√≥digo SVG aqui" style="min-height: 120px; font-family: monospace; font-size: 0.875rem;">${escapeHtml(p.svg || '')}</textarea>
          <div class="smallNote">Cole o c√≥digo SVG completo (incluindo a tag &lt;svg&gt;)</div>
            </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Largura</label>
              <input type="number" id="insp-svgWidth" value="${p.width || 100}" min="10" max="1000">
            </div>
            <div>
              <label class="smallNote">Altura</label>
              <input type="number" id="insp-svgHeight" value="${p.height || 100}" min="10" max="1000">
            </div>
            </div>
                </div>
        <div class="inspector-field">
          <label class="smallNote">Cor (para SVGs monocrom√°ticos)</label>
          <div style="display: flex; gap: 0.5rem; align-items: center;">
            <input type="color" id="insp-svgColor" value="${p.color || '#000000'}" style="width: 50px; height: 32px; cursor: pointer;">
            <input type="text" id="insp-svgColorText" value="${p.color || '#000000'}" placeholder="#000000" style="flex: 1; font-size: 0.875rem;">
            </div>
          <div class="smallNote">Aplic√°vel apenas para SVGs que suportam colora√ß√£o (deixe vazio se o SVG j√° tiver cores definidas)</div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Alinhamento</label>
          <select id="insp-svgAlignment">
            <option value="left" ${p.alignment === 'left' ? 'selected' : ''}>Esquerda</option>
            <option value="center" ${p.alignment === 'center' || !p.alignment ? 'selected' : ''}>Centro</option>
            <option value="right" ${p.alignment === 'right' ? 'selected' : ''}>Direita</option>
          </select>
        </div>
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorGroup(element) {
      const p = element.properties || {};
      return `
        <div class="inspector-field">
          <label class="smallNote">Orienta√ßao</label>
          <select id="insp-groupOrientation">
            <option value="column" ${p.orientation === 'column' ? 'selected' : ''}>Coluna (vertical)</option>
            <option value="row" ${p.orientation === 'row' ? 'selected' : ''}>Linha (horizontal)</option>
          </select>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Alinhamento</label>
          <select id="insp-groupAlignment">
            <option value="left" ${p.alignment === 'left' ? 'selected' : ''}>Esquerda</option>
            <option value="center" ${p.alignment === 'center' ? 'selected' : ''}>Centro</option>
            <option value="right" ${p.alignment === 'right' ? 'selected' : ''}>Direita</option>
            <option value="justify" ${p.alignment === 'justify' ? 'selected' : ''}>Justificado</option>
          </select>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Espa√ßamento entre elementos (gap)</label>
          <input type="number" id="insp-groupGap" value="${p.gap || 10}" min="0" max="50">
          <div class="smallNote">Espa√ßo entre os elementos dentro do grupo</div>
        </div>
        <div class="inspector-field">
          <div class="smallNote">Elementos no grupo: ${p.children?.length || 0}</div>
        </div>
        ${renderMarginSection(element)}
      `;
    }

    // Vari√°veis para debounce e preserva√ß√£o de foco
    let renderTimeout = null;
    let focusedElementId = null;
    let focusedElementValue = null;
    let focusedElementSelectionStart = null;
    let focusedElementSelectionEnd = null;
    
    function attachInspectorListeners(element) {
      const p = element.properties || {};
      const parentGroupInfo = findParentGroup(element.id);
      
      // Listeners gen√©ricos para margens (aplic√°vel a todos os elementos)
      const marginInputs = document.querySelectorAll('.margin-input');
      marginInputs.forEach(input => {
        input.addEventListener('input', () => {
          const side = parseInt(input.dataset.side || 0);
          if (!p.margin) p.margin = [0, 0, 0, 0];
          p.margin[side] = parseInt(input.value || 0) || 0;
          // Se todas as margens s√£o 0, remover a propriedade
          if (p.margin.every(m => m === 0)) {
            delete p.margin;
          }
          updateWithoutLosingFocus(() => {
            if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
          }, 300);
        });
      });
      
      // Fun√ß√£o helper para atualizar sem perder foco
      function updateWithoutLosingFocus(updateFn, delay = 300) {
        // Salvar estado do elemento focado
        const activeElement = document.activeElement;
        if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
          focusedElementId = activeElement.id;
          focusedElementValue = activeElement.value;
          focusedElementSelectionStart = activeElement.selectionStart;
          focusedElementSelectionEnd = activeElement.selectionEnd;
        }
        
        // Limpar timeout anterior
        if (renderTimeout) {
          clearTimeout(renderTimeout);
        }
        
        // Executar atualiza√ß√£o ap√≥s delay
        renderTimeout = setTimeout(() => {
          updateFn();
          
          // Restaurar foco ap√≥s renderiza√ß√£o
          setTimeout(() => {
            if (focusedElementId) {
              const element = document.getElementById(focusedElementId);
              if (element) {
                element.focus();
                if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                  element.value = focusedElementValue;
                  if (element.setSelectionRange && focusedElementSelectionStart !== undefined) {
                    const len = element.value.length;
                    element.setSelectionRange(
                      Math.min(focusedElementSelectionStart, len),
                      Math.min(focusedElementSelectionEnd !== undefined ? focusedElementSelectionEnd : focusedElementSelectionStart, len)
                    );
                  }
                }
              }
            }
          }, 10);
        }, delay);
      }
      
      // Handle width field if element is in a horizontal group
      if (parentGroupInfo && parentGroupInfo.group.properties && parentGroupInfo.group.properties.orientation === 'row') {
        const widthInput = document.getElementById('insp-width');
        if (widthInput && typeof redistributeGroupWidths === 'function') {
          widthInput.addEventListener('input', () => {
            const newWidth = parseFloat(widthInput.value) || 0;
            redistributeGroupWidths(parentGroupInfo.group, element.id, newWidth);
            updateWithoutLosingFocus(() => {
              if (typeof renderAll === 'function') {
                renderAll();
              } else if (typeof render === 'function') {
                render();
              }
              // Re-renderizar o inspector para atualizar os valores dos outros elementos
              setTimeout(() => {
                if (typeof renderInspector === 'function') renderInspector();
              }, 0);
            }, 300);
          });
        }
      }
    
      
      // Handle height field if element is in a group
      if (parentGroupInfo) {
        const heightInput = document.getElementById('insp-height');
        if (heightInput) {
          heightInput.addEventListener('input', () => {
            element.h = parseInt(heightInput.value) || 100;
            if (typeof updateGroupDimensions === 'function') {
              updateGroupDimensions(parentGroupInfo.group);
            }
            updateWithoutLosingFocus(() => {
              if (typeof renderAll === 'function') {
                renderAll();
              } else if (typeof render === 'function') {
                render();
              }
            }, 300);
          });
        }
      }
      
      switch (element.type) {
        case 'text':
          const textInput = document.getElementById('insp-text');
          const textLinkInput = document.getElementById('insp-link');
          const fontSizeInput = document.getElementById('insp-fontSize');
          const fontSelect = document.getElementById('insp-font');
          const fontFeaturesInput = document.getElementById('insp-fontFeatures');
          const alignmentSelect = document.getElementById('insp-alignment');
          const decorationSelect = document.getElementById('insp-decoration');
          const colorInput = document.getElementById('insp-color');
          const colorTextInput = document.getElementById('insp-colorText');
          const backgroundInput = document.getElementById('insp-background');
          const backgroundTextInput = document.getElementById('insp-backgroundText');
          const boldCheck = document.getElementById('insp-bold');
          const italicsCheck = document.getElementById('insp-italics');
          const lineHeightInput = document.getElementById('insp-lineHeight');
          const characterSpacingInput = document.getElementById('insp-characterSpacing');
          const decorationStyleSelect = document.getElementById('insp-decorationStyle');
          const decorationColorInput = document.getElementById('insp-decorationColor');
          const decorationColorTextInput = document.getElementById('insp-decorationColorText');
          const decorationOptions = document.getElementById('decorationOptions');
          
          if (textInput) {
            textInput.addEventListener('input', () => { 
              p.text = textInput.value; 
              updateParentGroupsDimensions(element.id);
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (textLinkInput) {
            textLinkInput.addEventListener('input', () => { 
              p.link = textLinkInput.value.trim() || null;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (fontSizeInput) {
            fontSizeInput.addEventListener('input', () => { 
              p.fontSize = parseInt(fontSizeInput.value); 
              updateParentGroupsDimensions(element.id);
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (fontSelect) {
            fontSelect.addEventListener('change', () => { 
              p.font = fontSelect.value || null;
              if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render(); 
            });
          }
          if (fontFeaturesInput) {
            fontFeaturesInput.addEventListener('input', () => {
              const val = fontFeaturesInput.value.trim();
              p.fontFeatures = val ? val.split(',').map(f => f.trim()).filter(Boolean) : undefined;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (alignmentSelect) alignmentSelect.addEventListener('change', () => { 
            p.alignment = alignmentSelect.value; 
            if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render(); 
          });
          if (decorationSelect) {
            decorationSelect.addEventListener('change', () => { 
              p.decoration = decorationSelect.value || null;
              if (decorationOptions) decorationOptions.style.display = p.decoration ? '' : 'none';
              if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render(); 
            });
          }
          if (decorationStyleSelect) {
            decorationStyleSelect.addEventListener('change', () => {
              p.decorationStyle = decorationStyleSelect.value || null;
              if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
            });
          }
          if (decorationColorInput && decorationColorTextInput) {
            decorationColorInput.addEventListener('input', () => {
              decorationColorTextInput.value = decorationColorInput.value;
              p.decorationColor = decorationColorInput.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
            decorationColorTextInput.addEventListener('input', () => {
              if (!decorationColorTextInput.value.trim()) {
                p.decorationColor = null;
              } else if (/^#[0-9A-F]{6}$/i.test(decorationColorTextInput.value)) {
                decorationColorInput.value = decorationColorTextInput.value;
                p.decorationColor = decorationColorTextInput.value;
              }
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (colorInput && colorTextInput) {
            colorInput.addEventListener('input', () => {
              colorTextInput.value = colorInput.value;
              p.color = colorInput.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
            colorTextInput.addEventListener('input', () => {
              if (/^#[0-9A-F]{6}$/i.test(colorTextInput.value)) {
                colorInput.value = colorTextInput.value;
                p.color = colorTextInput.value;
                updateWithoutLosingFocus(() => {
                  if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
                }, 300);
              }
            });
          }
          if (backgroundInput && backgroundTextInput) {
            backgroundInput.addEventListener('input', () => {
              backgroundTextInput.value = backgroundInput.value;
              p.background = backgroundInput.value || null;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
            backgroundTextInput.addEventListener('input', () => {
              if (!backgroundTextInput.value.trim()) {
                p.background = null;
              } else if (/^#[0-9A-F]{6}$/i.test(backgroundTextInput.value)) {
                backgroundInput.value = backgroundTextInput.value;
                p.background = backgroundTextInput.value;
              }
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (boldCheck) boldCheck.addEventListener('change', () => { 
            p.bold = boldCheck.checked; 
            if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render(); 
          });
          if (italicsCheck) italicsCheck.addEventListener('change', () => { 
            p.italics = italicsCheck.checked; 
            if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render(); 
          });
          if (lineHeightInput) {
            lineHeightInput.addEventListener('input', () => {
              const val = lineHeightInput.value.trim();
              p.lineHeight = val ? parseFloat(val) : undefined;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (characterSpacingInput) {
            characterSpacingInput.addEventListener('input', () => {
              const val = characterSpacingInput.value.trim();
              p.characterSpacing = val ? parseFloat(val) : undefined;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          break;
          
        case 'header':
          const headerTextInput = document.getElementById('insp-headerText');
          const headerLinkInput = document.getElementById('insp-headerLink');
          const headerFontSizeInput = document.getElementById('insp-headerFontSize');
          const headerFontSelect = document.getElementById('insp-headerFont');
          const headerFontFeaturesInput = document.getElementById('insp-headerFontFeatures');
          const headerAlignmentSelect = document.getElementById('insp-headerAlignment');
          const headerDecorationSelect = document.getElementById('insp-headerDecoration');
          const headerColorInput = document.getElementById('insp-headerColor');
          const headerColorTextInput = document.getElementById('insp-headerColorText');
          const headerBackgroundInput = document.getElementById('insp-headerBackground');
          const headerBackgroundTextInput = document.getElementById('insp-headerBackgroundText');
          const headerBoldCheck = document.getElementById('insp-headerBold');
          const headerItalicsCheck = document.getElementById('insp-headerItalics');
          const headerLineHeightInput = document.getElementById('insp-headerLineHeight');
          const headerCharacterSpacingInput = document.getElementById('insp-headerCharacterSpacing');
          const headerDecorationStyleSelect = document.getElementById('insp-headerDecorationStyle');
          const headerDecorationColorInput = document.getElementById('insp-headerDecorationColor');
          const headerDecorationColorTextInput = document.getElementById('insp-headerDecorationColorText');
          const headerDecorationOptions = document.getElementById('headerDecorationOptions');
          
          if (headerTextInput) {
            headerTextInput.addEventListener('input', () => { 
              p.text = headerTextInput.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (headerLinkInput) {
            headerLinkInput.addEventListener('input', () => { 
              p.link = headerLinkInput.value.trim() || null;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (headerFontSizeInput) {
            headerFontSizeInput.addEventListener('input', () => { 
              p.fontSize = parseInt(headerFontSizeInput.value);
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (headerFontSelect) {
            headerFontSelect.addEventListener('change', () => { 
              p.font = headerFontSelect.value || null;
              if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render(); 
            });
          }
          if (headerFontFeaturesInput) {
            headerFontFeaturesInput.addEventListener('input', () => {
              const val = headerFontFeaturesInput.value.trim();
              p.fontFeatures = val ? val.split(',').map(f => f.trim()).filter(Boolean) : undefined;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (headerAlignmentSelect) headerAlignmentSelect.addEventListener('change', () => { 
            p.alignment = headerAlignmentSelect.value; 
            if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render(); 
          });
          if (headerDecorationSelect) {
            headerDecorationSelect.addEventListener('change', () => { 
              p.decoration = headerDecorationSelect.value || null;
              if (headerDecorationOptions) headerDecorationOptions.style.display = p.decoration ? '' : 'none';
              if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render(); 
            });
          }
          if (headerDecorationStyleSelect) {
            headerDecorationStyleSelect.addEventListener('change', () => {
              p.decorationStyle = headerDecorationStyleSelect.value || null;
              if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
            });
          }
          if (headerDecorationColorInput && headerDecorationColorTextInput) {
            headerDecorationColorInput.addEventListener('input', () => {
              headerDecorationColorTextInput.value = headerDecorationColorInput.value;
              p.decorationColor = headerDecorationColorInput.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
            headerDecorationColorTextInput.addEventListener('input', () => {
              if (!headerDecorationColorTextInput.value.trim()) {
                p.decorationColor = null;
              } else if (/^#[0-9A-F]{6}$/i.test(headerDecorationColorTextInput.value)) {
                headerDecorationColorInput.value = headerDecorationColorTextInput.value;
                p.decorationColor = headerDecorationColorTextInput.value;
              }
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (headerColorInput && headerColorTextInput) {
            headerColorInput.addEventListener('input', () => {
              headerColorTextInput.value = headerColorInput.value;
              p.color = headerColorInput.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
            headerColorTextInput.addEventListener('input', () => {
              if (/^#[0-9A-F]{6}$/i.test(headerColorTextInput.value)) {
                headerColorInput.value = headerColorTextInput.value;
                p.color = headerColorTextInput.value;
                updateWithoutLosingFocus(() => {
                  if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
                }, 300);
              }
            });
          }
          if (headerBackgroundInput && headerBackgroundTextInput) {
            headerBackgroundInput.addEventListener('input', () => {
              headerBackgroundTextInput.value = headerBackgroundInput.value;
              p.background = headerBackgroundInput.value || null;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
            headerBackgroundTextInput.addEventListener('input', () => {
              if (!headerBackgroundTextInput.value.trim()) {
                p.background = null;
              } else if (/^#[0-9A-F]{6}$/i.test(headerBackgroundTextInput.value)) {
                headerBackgroundInput.value = headerBackgroundTextInput.value;
                p.background = headerBackgroundTextInput.value;
              }
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (headerBoldCheck) headerBoldCheck.addEventListener('change', () => { 
            p.bold = headerBoldCheck.checked; 
            if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render(); 
          });
          if (headerItalicsCheck) headerItalicsCheck.addEventListener('change', () => { 
            p.italics = headerItalicsCheck.checked; 
            if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render(); 
          });
          if (headerLineHeightInput) {
            headerLineHeightInput.addEventListener('input', () => {
              const val = headerLineHeightInput.value.trim();
              p.lineHeight = val ? parseFloat(val) : undefined;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (headerCharacterSpacingInput) {
            headerCharacterSpacingInput.addEventListener('input', () => {
              const val = headerCharacterSpacingInput.value.trim();
              p.characterSpacing = val ? parseFloat(val) : undefined;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          break;
          
        case 'columns':
          const colCountInput = document.getElementById('insp-colCount');
          const colGapInput = document.getElementById('insp-colGap');
          const colValignSelect = document.getElementById('insp-colValign');
          const colTextsInput = document.getElementById('insp-colTexts');
          
          // Listeners para larguras das colunas
          document.querySelectorAll('.col-width-type').forEach(select => {
            select.addEventListener('change', () => {
              const colIndex = parseInt(select.dataset.colIndex || 0);
              const widthType = select.value;
              const valueInput = document.querySelector(`.col-width-value[data-col-index="${colIndex}"]`);
              const valueContainer = document.getElementById(`col-width-value-${colIndex}`);
              
              if (!p.columns || !p.columns[colIndex]) return;
              
              if (widthType === 'auto') {
                p.columns[colIndex].width = '*';
                if (valueContainer) valueContainer.style.display = 'none';
            } else {
                if (valueContainer) valueContainer.style.display = '';
                const currentValue = valueInput ? parseFloat(valueInput.value) || 0 : 0;
                if (widthType === 'pixels') {
                  p.columns[colIndex].width = currentValue || 100;
                } else if (widthType === 'percentage') {
                  p.columns[colIndex].width = currentValue ? `${currentValue}%` : '50%';
                }
              }
              
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          });
          
          document.querySelectorAll('.col-width-value').forEach(input => {
            input.addEventListener('input', () => {
              const colIndex = parseInt(input.dataset.colIndex || 0);
              const typeSelect = document.querySelector(`.col-width-type[data-col-index="${colIndex}"]`);
              const widthType = typeSelect ? typeSelect.value : 'auto';
              const value = parseFloat(input.value) || 0;
              
              if (!p.columns || !p.columns[colIndex]) return;
              
              if (widthType === 'pixels') {
                p.columns[colIndex].width = value || 100;
              } else if (widthType === 'percentage') {
                p.columns[colIndex].width = value ? `${value}%` : '50%';
              }
              
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          });
          
          // Listener para deletar coluna
          document.querySelectorAll('.btn-delete-col').forEach(btn => {
            btn.addEventListener('click', () => {
              const colIndex = parseInt(btn.dataset.colIndex || 0);
              if (colIndex > 0 && p.columns && p.columns.length > 1) {
                if (typeof showConfirmModal === 'function') {
                  showConfirmModal(
                    'Deletar Coluna',
                    `Tem certeza que deseja deletar a Coluna ${colIndex + 1}?`,
                    () => {
                      p.columns.splice(colIndex, 1);
                      if (colCountInput) colCountInput.value = p.columns.length;
                      if (typeof renderAll === 'function') {
                        renderAll();
                      } else if (typeof render === 'function') {
            render();
                      }
                      setTimeout(() => {
                        if (typeof renderInspector === 'function') renderInspector();
                      }, 0);
                    }
                  );
                }
              }
            });
          });
          
          if (colCountInput) {
            colCountInput.addEventListener('input', () => {
              const count = parseInt(colCountInput.value) || 2;
              const current = p.columns || [];
              while (current.length < count) {
                current.push({ text: `Coluna ${current.length + 1}`, width: '*', children: [] });
              }
              while (current.length > count) {
                current.pop();
              }
              p.columns = current;
              if (typeof renderAll === 'function') {
                renderAll();
              } else if (typeof render === 'function') {
                render();
              }
              // Atualizar inspector para mostrar as novas colunas
              setTimeout(() => {
                if (typeof renderInspector === 'function') renderInspector();
              }, 0);
            });
          }
          
          if (colGapInput) {
            colGapInput.addEventListener('input', () => { 
              p.gap = parseInt(colGapInput.value) || 10;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          
          if (colValignSelect) {
            colValignSelect.addEventListener('change', () => {
              p.valign = colValignSelect.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          
          if (colTextsInput) {
            colTextsInput.addEventListener('input', () => {
              const parts = colTextsInput.value.split('\n---\n');
              // Preservar children e width existentes ao atualizar textos
              p.columns = parts.map((t, i) => {
                const existingCol = p.columns && p.columns[i];
                return { 
                  text: t.trim() || `Coluna ${i + 1}`, 
                  width: existingCol?.width || '*',
                  children: existingCol?.children || []
                };
              });
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          break;
          
        case 'list':
          const listKindSelect = document.getElementById('insp-listKind');
          const listItemsInput = document.getElementById('insp-listItems');
          const listStartInput = document.getElementById('insp-listStart');
          const listTypeSelect = document.getElementById('insp-listType');
          const listReversedCheck = document.getElementById('insp-listReversed');
          const markerColorInput = document.getElementById('insp-markerColor');
          const markerColorTextInput = document.getElementById('insp-markerColorText');
          
          if (listKindSelect) {
            listKindSelect.addEventListener('change', () => { 
              p.ordered = listKindSelect.value === 'ol';
              p.listType = listKindSelect.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (listStartInput) {
            listStartInput.addEventListener('input', () => {
              p.start = parseInt(listStartInput.value) || 1;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (listTypeSelect) {
            listTypeSelect.addEventListener('change', () => {
              p.type = listTypeSelect.value;
              if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
            });
          }
          if (listReversedCheck) {
            listReversedCheck.addEventListener('change', () => {
              p.reversed = listReversedCheck.checked;
              if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
            });
          }
          if (listItemsInput) {
            listItemsInput.addEventListener('input', () => { 
              // Converter strings para objetos {kind: 'text', text: '...'}
              const lines = listItemsInput.value.split('\n').filter(Boolean);
              p.items = lines.map(line => ({ kind: 'text', text: line }));
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          break;
          
        case 'table':
          const tableColsInput = document.getElementById('insp-tableCols');
          const tableRowsInput = document.getElementById('insp-tableRows');
          const tableLayoutSelect = document.getElementById('insp-tableLayout');
          
          if (tableColsInput || tableRowsInput) {
            const updateTable = () => {
              const cols = parseInt(tableColsInput?.value || 3);
              const dataRows = parseInt(tableRowsInput?.value || 1); // Linhas de dados (sem contar header)
              const totalRows = dataRows + 1; // +1 para o header
              
              // Preservar estrutura existente se poss√≠vel
              const currentBody = p.body || [];
              const currentCols = currentBody[0]?.length || cols;
              
              const newBody = Array(totalRows).fill(null).map((_, i) => {
                if (i === 0) {
                  // Primeira linha = header
                  const existingHeader = currentBody[0] || [];
                  return Array(cols).fill(null).map((_, j) => {
                    // Preservar c√©lulas existentes se poss√≠vel, sen√£o criar nova estrutura
                    if (existingHeader[j] && typeof existingHeader[j] === 'object' && existingHeader[j].children) {
                      return existingHeader[j];
                    }
                    return { children: [] };
                  });
                } else {
                  // Linhas de dados
                  const existingRow = currentBody[i] || [];
                  return Array(cols).fill(null).map((_, j) => {
                    if (existingRow[j] && typeof existingRow[j] === 'object' && existingRow[j].children) {
                      return existingRow[j];
                    }
                    return { children: [] };
                  });
                }
              });
              
              p.body = newBody;
              
              // Atualizar larguras preservando as existentes quando poss√≠vel
              if (!p.widths || p.widths.length !== cols) {
                const existingWidths = p.widths || [];
                p.widths = Array(cols).fill(null).map((_, i) => {
                  return existingWidths[i] || '*';
                });
              }
              
              if (typeof renderAll === 'function') {
                renderAll();
              } else if (typeof render === 'function') {
      render();
    }
            };
            if (tableColsInput) tableColsInput.addEventListener('input', updateTable);
            if (tableRowsInput) tableRowsInput.addEventListener('input', updateTable);
          }
          if (tableLayoutSelect) {
            tableLayoutSelect.addEventListener('change', () => { 
              p.layout = tableLayoutSelect.value;
              
              // Mostrar/ocultar op√ß√µes de layout customizado
              const customLayoutOptions = document.getElementById('tableCustomLayoutOptions');
              if (customLayoutOptions) {
                customLayoutOptions.style.display = (tableLayoutSelect.value === 'custom') ? 'block' : 'none';
              }
              
              if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              setTimeout(() => {
                if (typeof renderInspector === 'function') renderInspector();
              }, 0);
            });
          }
          
          // Listeners para layout customizado
          const hLineWidthInput = document.getElementById('insp-tableHLineWidth');
          const hLineColorInput = document.getElementById('insp-tableHLineColor');
          const hLineColorTextInput = document.getElementById('insp-tableHLineColorText');
          const vLineWidthInput = document.getElementById('insp-tableVLineWidth');
          const vLineColorInput = document.getElementById('insp-tableVLineColor');
          const vLineColorTextInput = document.getElementById('insp-tableVLineColorText');
          const paddingLeftInput = document.getElementById('insp-tablePaddingLeft');
          const paddingRightInput = document.getElementById('insp-tablePaddingRight');
          const paddingTopInput = document.getElementById('insp-tablePaddingTop');
          const paddingBottomInput = document.getElementById('insp-tablePaddingBottom');
          
          const updateCustomLayout = () => {
            if (!p.customLayout) p.customLayout = {};
            if (hLineWidthInput) p.customLayout.hLineWidth = parseFloat(hLineWidthInput.value) || 1;
            if (hLineColorTextInput && hLineColorTextInput.value) p.customLayout.hLineColor = hLineColorTextInput.value;
            if (vLineWidthInput) p.customLayout.vLineWidth = parseFloat(vLineWidthInput.value) || 1;
            if (vLineColorTextInput && vLineColorTextInput.value) p.customLayout.vLineColor = vLineColorTextInput.value;
            if (paddingLeftInput) p.customLayout.paddingLeft = parseInt(paddingLeftInput.value) || 5;
            if (paddingRightInput) p.customLayout.paddingRight = parseInt(paddingRightInput.value) || 5;
            if (paddingTopInput) p.customLayout.paddingTop = parseInt(paddingTopInput.value) || 5;
            if (paddingBottomInput) p.customLayout.paddingBottom = parseInt(paddingBottomInput.value) || 5;
            
            updateWithoutLosingFocus(() => {
              if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
            }, 300);
          };
          
          if (hLineWidthInput) hLineWidthInput.addEventListener('input', updateCustomLayout);
          if (hLineColorInput) {
            hLineColorInput.addEventListener('change', () => {
              if (hLineColorTextInput) hLineColorTextInput.value = hLineColorInput.value;
              updateCustomLayout();
            });
          }
          if (hLineColorTextInput) hLineColorTextInput.addEventListener('input', updateCustomLayout);
          
          if (vLineWidthInput) vLineWidthInput.addEventListener('input', updateCustomLayout);
          if (vLineColorInput) {
            vLineColorInput.addEventListener('change', () => {
              if (vLineColorTextInput) vLineColorTextInput.value = vLineColorInput.value;
              updateCustomLayout();
            });
          }
          if (vLineColorTextInput) vLineColorTextInput.addEventListener('input', updateCustomLayout);
          
          if (paddingLeftInput) paddingLeftInput.addEventListener('input', updateCustomLayout);
          if (paddingRightInput) paddingRightInput.addEventListener('input', updateCustomLayout);
          if (paddingTopInput) paddingTopInput.addEventListener('input', updateCustomLayout);
          if (paddingBottomInput) paddingBottomInput.addEventListener('input', updateCustomLayout);
          
          // Listeners para tabela zebrada
          const zebraEnabledCheck = document.getElementById('insp-tableZebraEnabled');
          const zebraColorInput = document.getElementById('insp-tableZebraColor');
          const zebraColorTextInput = document.getElementById('insp-tableZebraColorText');
          const zebraWithLinesCheck = document.getElementById('insp-tableZebraWithLines');
          
          if (zebraEnabledCheck) {
            zebraEnabledCheck.addEventListener('change', () => {
              p.zebraEnabled = zebraEnabledCheck.checked;
              if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              setTimeout(() => {
                if (typeof renderInspector === 'function') renderInspector();
              }, 0);
            });
          }
          
          if (zebraColorInput) {
            zebraColorInput.addEventListener('change', () => {
              if (zebraColorTextInput) zebraColorTextInput.value = zebraColorInput.value;
              p.zebraColor = zebraColorInput.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          
          if (zebraColorTextInput) {
            zebraColorTextInput.addEventListener('input', () => {
              if (zebraColorInput && zebraColorTextInput.value) zebraColorInput.value = zebraColorTextInput.value;
              p.zebraColor = zebraColorTextInput.value || '#CCCCCC';
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          
          if (zebraWithLinesCheck) {
            zebraWithLinesCheck.addEventListener('change', () => {
              p.zebraWithLines = zebraWithLinesCheck.checked;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          
          const tableDontBreakRowsCheck = document.getElementById('insp-tableDontBreakRows');
          const tableKeepWithHeaderRowsInput = document.getElementById('insp-tableKeepWithHeaderRows');
          
          if (tableDontBreakRowsCheck) {
            tableDontBreakRowsCheck.addEventListener('change', () => {
              p.dontBreakRows = tableDontBreakRowsCheck.checked;
              if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
            });
          }
          
          if (tableKeepWithHeaderRowsInput) {
            tableKeepWithHeaderRowsInput.addEventListener('input', () => {
              p.keepWithHeaderRows = parseInt(tableKeepWithHeaderRowsInput.value) || 0;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          
          // Listeners para estilos das c√©lulas
          document.querySelectorAll('.table-cell-fill-color').forEach(input => {
            input.addEventListener('change', () => {
              const row = parseInt(input.dataset.row || 0);
              const col = parseInt(input.dataset.col || 0);
              const textInput = document.querySelector(`.table-cell-fill-color-text[data-row="${row}"][data-col="${col}"]`);
              if (textInput) textInput.value = input.value;
              
              if (!p.body[row] || !p.body[row][col]) return;
              p.body[row][col].fillColor = input.value || undefined;
              
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          });
          
          document.querySelectorAll('.table-cell-fill-color-text').forEach(input => {
            input.addEventListener('input', () => {
              const row = parseInt(input.dataset.row || 0);
              const col = parseInt(input.dataset.col || 0);
              const colorInput = document.querySelector(`.table-cell-fill-color[data-row="${row}"][data-col="${col}"]`);
              if (colorInput && input.value) colorInput.value = input.value;
              
              if (!p.body[row] || !p.body[row][col]) return;
              p.body[row][col].fillColor = input.value || undefined;
              
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          });
          
          document.querySelectorAll('.table-cell-color').forEach(input => {
            input.addEventListener('change', () => {
              const row = parseInt(input.dataset.row || 0);
              const col = parseInt(input.dataset.col || 0);
              const textInput = document.querySelector(`.table-cell-color-text[data-row="${row}"][data-col="${col}"]`);
              if (textInput) textInput.value = input.value;
              
              if (!p.body[row] || !p.body[row][col]) return;
              p.body[row][col].color = input.value || undefined;
              
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          });
          
          document.querySelectorAll('.table-cell-color-text').forEach(input => {
            input.addEventListener('input', () => {
              const row = parseInt(input.dataset.row || 0);
              const col = parseInt(input.dataset.col || 0);
              const colorInput = document.querySelector(`.table-cell-color[data-row="${row}"][data-col="${col}"]`);
              if (colorInput && input.value) colorInput.value = input.value;
              
              if (!p.body[row] || !p.body[row][col]) return;
              p.body[row][col].color = input.value || undefined;
              
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          });
          
          document.querySelectorAll('.table-cell-fill-opacity').forEach(input => {
            input.addEventListener('input', () => {
              const row = parseInt(input.dataset.row || 0);
              const col = parseInt(input.dataset.col || 0);
              
              if (!p.body[row] || !p.body[row][col]) return;
              const opacity = parseFloat(input.value);
              p.body[row][col].fillOpacity = isNaN(opacity) ? 1 : opacity;
              
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          });
          
          // Listeners para rowSpan e colSpan
          document.querySelectorAll('.table-cell-rowspan').forEach(input => {
            input.addEventListener('input', () => {
              const row = parseInt(input.dataset.row || 0);
              const col = parseInt(input.dataset.col || 0);
              
              if (!p.body[row] || !p.body[row][col]) return;
              const rowSpan = parseInt(input.value) || 1;
              p.body[row][col].rowSpan = rowSpan > 1 ? rowSpan : undefined;
              
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          });
          
          document.querySelectorAll('.table-cell-colspan').forEach(input => {
            input.addEventListener('input', () => {
              const row = parseInt(input.dataset.row || 0);
              const col = parseInt(input.dataset.col || 0);
              
              if (!p.body[row] || !p.body[row][col]) return;
              const colSpan = parseInt(input.value) || 1;
              p.body[row][col].colSpan = colSpan > 1 ? colSpan : undefined;
              
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          });
          
          // Listeners para border (checkboxes)
          document.querySelectorAll('.table-cell-border').forEach(checkbox => {
            checkbox.addEventListener('change', () => {
              const row = parseInt(checkbox.dataset.row || 0);
              const col = parseInt(checkbox.dataset.col || 0);
              const side = parseInt(checkbox.dataset.side || 0);
              
              if (!p.body[row] || !p.body[row][col]) return;
              
              if (!p.body[row][col].border) {
                p.body[row][col].border = [true, true, true, true];
              }
              
              p.body[row][col].border[side] = checkbox.checked;
              
              // Se todas as bordas forem true, pode remover a propriedade (usa padr√£o)
              if (p.body[row][col].border.every(b => b === true)) {
                p.body[row][col].border = undefined;
              }
              
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          });
          
          // Listeners para borderColor
          document.querySelectorAll('.table-cell-border-color').forEach(input => {
            input.addEventListener('change', () => {
              const row = parseInt(input.dataset.row || 0);
              const col = parseInt(input.dataset.col || 0);
              const side = parseInt(input.dataset.side || 0);
              
              if (!p.body[row] || !p.body[row][col]) return;
              
              if (!p.body[row][col].borderColor) {
                p.body[row][col].borderColor = ['', '', '', ''];
              }
              
              p.body[row][col].borderColor[side] = input.value || '';
              
              // Se todas as cores forem vazias, pode remover a propriedade
              if (p.body[row][col].borderColor.every(c => !c)) {
                p.body[row][col].borderColor = undefined;
              }
              
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          });
          
          // Listeners para heights
          const heightsTypeSelect = document.getElementById('insp-tableHeightsType');
          const heightsFixedInput = document.getElementById('insp-tableHeightsFixed');
          
          if (heightsTypeSelect) {
            heightsTypeSelect.addEventListener('change', () => {
              const type = heightsTypeSelect.value;
              const fixedContainer = document.getElementById('table-heights-fixed');
              
              if (type === 'none') {
                p.heights = undefined;
                if (fixedContainer) fixedContainer.style.display = 'none';
              } else if (type === 'fixed') {
                const fixedValue = heightsFixedInput ? parseFloat(heightsFixedInput.value) || 40 : 40;
                p.heights = fixedValue;
                if (fixedContainer) fixedContainer.style.display = '';
              } else if (type === 'array') {
                const numRows = p.body?.length || 2;
                p.heights = Array(numRows).fill(40);
                if (fixedContainer) fixedContainer.style.display = 'none';
                // Re-renderizar para mostrar os inputs de array
                if (typeof renderInspector === 'function') renderInspector();
                return;
              }
              
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          
          if (heightsFixedInput) {
            heightsFixedInput.addEventListener('input', () => {
              const value = parseFloat(heightsFixedInput.value) || 40;
              p.heights = value;
              
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          
          // Listeners para alturas por linha (array)
          document.querySelectorAll('.table-row-height').forEach(input => {
            input.addEventListener('input', () => {
              const row = parseInt(input.dataset.row || 0);
              const value = parseFloat(input.value) || 40;
              
              if (!p.heights || !Array.isArray(p.heights)) {
                const numRows = p.body?.length || 2;
                p.heights = Array(numRows).fill(40);
              }
              
              p.heights[row] = value;
              
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          });
          
          // Listeners para hLineStyle e vLineStyle
          const hLineStyleCheck = document.getElementById('insp-tableHLineStyle');
          const vLineStyleCheck = document.getElementById('insp-tableVLineStyle');
          const defaultBorderCheck = document.getElementById('insp-tableDefaultBorder');
          
          if (hLineStyleCheck) {
            hLineStyleCheck.addEventListener('change', () => {
              if (!p.customLayout) p.customLayout = {};
              if (hLineStyleCheck.checked) {
                p.customLayout.hLineStyle = true; // Ser√° convertido para fun√ß√£o na gera√ß√£o
              } else {
                p.customLayout.hLineStyle = undefined;
              }
              
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          
          if (vLineStyleCheck) {
            vLineStyleCheck.addEventListener('change', () => {
              if (!p.customLayout) p.customLayout = {};
              if (vLineStyleCheck.checked) {
                p.customLayout.vLineStyle = true; // Ser√° convertido para fun√ß√£o na gera√ß√£o
              } else {
                p.customLayout.vLineStyle = undefined;
              }
              
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          
          if (defaultBorderCheck) {
            defaultBorderCheck.addEventListener('change', () => {
              if (!p.customLayout) p.customLayout = {};
              p.customLayout.defaultBorder = defaultBorderCheck.checked;
              
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          
          // Listeners para larguras das colunas da tabela
          document.querySelectorAll('.table-col-width-type').forEach(select => {
            select.addEventListener('change', () => {
              const colIndex = parseInt(select.dataset.colIndex || 0);
              const widthType = select.value;
              const valueInput = document.querySelector(`.table-col-width-value[data-col-index="${colIndex}"]`);
              const valueContainer = document.getElementById(`table-col-width-value-${colIndex}`);
              
              if (!p.widths) {
                const body = p.body || [];
                const numCols = body[0]?.length || 3;
                p.widths = Array(numCols).fill('*');
              }
              
              if (widthType === 'auto') {
                p.widths[colIndex] = '*';
                if (valueContainer) valueContainer.style.display = 'none';
              } else {
                if (valueContainer) valueContainer.style.display = '';
                const currentValue = valueInput ? parseFloat(valueInput.value) || 0 : 0;
                if (widthType === 'pixels') {
                  p.widths[colIndex] = currentValue || 100;
                } else if (widthType === 'percentage') {
                  p.widths[colIndex] = currentValue ? `${currentValue}%` : '50%';
                }
              }
              
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          });
          
          document.querySelectorAll('.table-col-width-value').forEach(input => {
            input.addEventListener('input', () => {
              const colIndex = parseInt(input.dataset.colIndex || 0);
              const typeSelect = document.querySelector(`.table-col-width-type[data-col-index="${colIndex}"]`);
              const widthType = typeSelect ? typeSelect.value : 'auto';
              const value = parseFloat(input.value) || 0;
              
              if (!p.widths) {
                const body = p.body || [];
                const numCols = body[0]?.length || 3;
                p.widths = Array(numCols).fill('*');
              }
              
              if (widthType === 'pixels') {
                p.widths[colIndex] = value || 100;
              } else if (widthType === 'percentage') {
                p.widths[colIndex] = value ? `${value}%` : '50%';
              }
              
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          });
          
          // Listener para deletar coluna da tabela
          document.querySelectorAll('.btn-delete-table-col').forEach(btn => {
            btn.addEventListener('click', () => {
              const colIndex = parseInt(btn.dataset.colIndex || 0);
              const body = p.body || [];
              const numCols = body[0]?.length || 0;
              
              if (colIndex > 0 && numCols > 1) {
                if (typeof showConfirmModal === 'function') {
                  showConfirmModal(
                    'Deletar Coluna',
                    `Tem certeza que deseja deletar a Coluna ${colIndex + 1}?`,
                    () => {
                      // Remover coluna de todas as linhas
                      body.forEach(row => {
                        if (row && Array.isArray(row) && row[colIndex]) {
                          row.splice(colIndex, 1);
                        }
                      });
                      
                      // Remover largura correspondente
                      if (p.widths && p.widths[colIndex]) {
                        p.widths.splice(colIndex, 1);
                      }
                      
                      // Atualizar n√∫mero de colunas
                      if (tableColsInput) {
                        tableColsInput.value = numCols - 1;
                      }
                      
                      if (typeof renderAll === 'function') {
                        renderAll();
                      } else if (typeof render === 'function') {
                        render();
                      }
                      setTimeout(() => {
                        if (typeof renderInspector === 'function') renderInspector();
                      }, 0);
                    }
                  );
                }
              }
            });
          });
          break;
          
        case 'image':
          const imageUrlInput = document.getElementById('insp-imageUrl');
          const imageSizeModeSelect = document.getElementById('insp-imageSizeMode');
          const imageWidthInput = document.getElementById('insp-imageWidth');
          const imageHeightInput = document.getElementById('insp-imageHeight');
          const imageFitWidthInput = document.getElementById('insp-imageFitWidth');
          const imageFitHeightInput = document.getElementById('insp-imageFitHeight');
          const imageCoverWidthInput = document.getElementById('insp-imageCoverWidth');
          const imageCoverHeightInput = document.getElementById('insp-imageCoverHeight');
          const imageCoverAlignSelect = document.getElementById('insp-imageCoverAlign');
          const imageCoverValignSelect = document.getElementById('insp-imageCoverValign');
          const imageBorderRadiusInput = document.getElementById('insp-imageBorderRadius');
          const imageOpacityInput = document.getElementById('insp-imageOpacity');
          const imageAlignmentSelect = document.getElementById('insp-imageAlignment');
          const imagePositionTypeSelect = document.getElementById('insp-imagePositionType');
          const imageAbsoluteXInput = document.getElementById('insp-imageAbsoluteX');
          const imageAbsoluteYInput = document.getElementById('insp-imageAbsoluteY');
          const imageRelativeXInput = document.getElementById('insp-imageRelativeX');
          const imageRelativeYInput = document.getElementById('insp-imageRelativeY');
          
          // Modo de dimensionamento
          if (imageSizeModeSelect) {
            imageSizeModeSelect.addEventListener('change', () => {
              const mode = imageSizeModeSelect.value;
              // Limpar propriedades n√£o usadas
              if (mode === 'widthHeight') {
                delete p.fit;
                delete p.cover;
              } else if (mode === 'fit') {
                delete p.width;
                delete p.height;
                delete p.cover;
                if (!p.fit) p.fit = [100, 100];
              } else if (mode === 'cover') {
                delete p.width;
                delete p.height;
                delete p.fit;
                if (!p.cover) p.cover = { width: 300, height: 150, align: 'center', valign: 'center' };
              }
              // Atualizar UI
              setTimeout(() => {
                if (typeof renderInspector === 'function') renderInspector();
              }, 0);
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          
          if (imageUrlInput) {
            imageUrlInput.addEventListener('input', async () => { 
              const url = imageUrlInput.value.trim();
              p.url = url;
              
              // Converter URL para base64 apenas para preview visual
              if (url && (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('data:'))) {
                try {
                  const base64 = await convertImageUrlToBase64(url);
                  if (base64) {
                    p._base64Preview = base64; // Armazenar base64 apenas para preview
                  } else {
                    delete p._base64Preview;
                  }
                } catch (e) {
                  console.warn('Erro ao converter imagem para base64:', e);
                  delete p._base64Preview;
                }
              } else {
                delete p._base64Preview;
              }
              
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          
          // Width e Height
          if (imageWidthInput) {
            imageWidthInput.addEventListener('input', () => { 
              const val = imageWidthInput.value.trim();
              p.width = val ? parseInt(val) : undefined;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (imageHeightInput) {
            imageHeightInput.addEventListener('input', () => { 
              const val = imageHeightInput.value.trim();
              p.height = val ? parseInt(val) : undefined;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          
          // Fit
          if (imageFitWidthInput) {
            imageFitWidthInput.addEventListener('input', () => {
              if (!Array.isArray(p.fit)) p.fit = [100, 100];
              p.fit[0] = parseInt(imageFitWidthInput.value) || 100;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (imageFitHeightInput) {
            imageFitHeightInput.addEventListener('input', () => {
              if (!Array.isArray(p.fit)) p.fit = [100, 100];
              p.fit[1] = parseInt(imageFitHeightInput.value) || 100;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          
          // Cover
          if (imageCoverWidthInput) {
            imageCoverWidthInput.addEventListener('input', () => {
              if (!p.cover) p.cover = { width: 300, height: 150, align: 'center', valign: 'center' };
              p.cover.width = parseInt(imageCoverWidthInput.value) || 300;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (imageCoverHeightInput) {
            imageCoverHeightInput.addEventListener('input', () => {
              if (!p.cover) p.cover = { width: 300, height: 150, align: 'center', valign: 'center' };
              p.cover.height = parseInt(imageCoverHeightInput.value) || 150;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (imageCoverAlignSelect) {
            imageCoverAlignSelect.addEventListener('change', () => {
              if (!p.cover) p.cover = { width: 300, height: 150, align: 'center', valign: 'center' };
              p.cover.align = imageCoverAlignSelect.value;
              if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
            });
          }
          if (imageCoverValignSelect) {
            imageCoverValignSelect.addEventListener('change', () => {
              if (!p.cover) p.cover = { width: 300, height: 150, align: 'center', valign: 'center' };
              p.cover.valign = imageCoverValignSelect.value;
              if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
            });
          }
          
          if (imageBorderRadiusInput) {
            imageBorderRadiusInput.addEventListener('input', () => { 
              p.borderRadius = parseInt(imageBorderRadiusInput.value) || 0;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          
          if (imageOpacityInput) {
            imageOpacityInput.addEventListener('input', () => {
              const val = imageOpacityInput.value.trim();
              p.opacity = val ? parseFloat(val) : undefined;
              if (p.opacity !== undefined) {
                p.opacity = Math.max(0, Math.min(1, p.opacity)); // Clamp entre 0 e 1
              }
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          
          if (imageAlignmentSelect) {
            imageAlignmentSelect.addEventListener('change', () => { 
              p.alignment = imageAlignmentSelect.value; 
              if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render(); 
            });
          }
          
          // Tipo de posicionamento
          if (imagePositionTypeSelect) {
            imagePositionTypeSelect.addEventListener('change', () => {
              const posType = imagePositionTypeSelect.value;
              if (posType === 'none') {
                delete p.absolutePosition;
                delete p.relativePosition;
              } else if (posType === 'absolute') {
                delete p.relativePosition;
                if (!p.absolutePosition) p.absolutePosition = { x: 0, y: 0 };
              } else if (posType === 'relative') {
                delete p.absolutePosition;
                if (!p.relativePosition) p.relativePosition = { x: 0, y: 0 };
              }
              // Atualizar UI
              setTimeout(() => {
                if (typeof renderInspector === 'function') renderInspector();
              }, 0);
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          
          // Posi√ß√£o absoluta
          if (imageAbsoluteXInput) {
            imageAbsoluteXInput.addEventListener('input', () => {
              if (!p.absolutePosition) p.absolutePosition = { x: 0, y: 0 };
              p.absolutePosition.x = parseInt(imageAbsoluteXInput.value) || 0;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (imageAbsoluteYInput) {
            imageAbsoluteYInput.addEventListener('input', () => {
              if (!p.absolutePosition) p.absolutePosition = { x: 0, y: 0 };
              p.absolutePosition.y = parseInt(imageAbsoluteYInput.value) || 0;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          
          // Posi√ß√£o relativa
          if (imageRelativeXInput) {
            imageRelativeXInput.addEventListener('input', () => {
              if (!p.relativePosition) p.relativePosition = { x: 0, y: 0 };
              p.relativePosition.x = parseInt(imageRelativeXInput.value) || 0;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (imageRelativeYInput) {
            imageRelativeYInput.addEventListener('input', () => {
              if (!p.relativePosition) p.relativePosition = { x: 0, y: 0 };
              p.relativePosition.y = parseInt(imageRelativeYInput.value) || 0;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          break;
          
        case 'margin':
          const marginLeftInput = document.getElementById('insp-marginLeft');
          const marginTopInput = document.getElementById('insp-marginTop');
          const marginRightInput = document.getElementById('insp-marginRight');
          const marginBottomInput = document.getElementById('insp-marginBottom');
          
          const updateMargin = () => {
            const left = parseInt(marginLeftInput?.value || 0) || 0;
            const top = parseInt(marginTopInput?.value || 0) || 0;
            const right = parseInt(marginRightInput?.value || 0) || 0;
            const bottom = parseInt(marginBottomInput?.value || 0) || 0;
            p.margin = [left, top, right, bottom];
            // Manter compatibilidade com o formato antigo (size)
            if (top > 0 && left === 0 && right === 0 && bottom === 0) {
              p.size = top;
            }
            updateWithoutLosingFocus(() => {
              if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
            }, 300);
          };
          
          if (marginLeftInput) marginLeftInput.addEventListener('input', updateMargin);
          if (marginTopInput) marginTopInput.addEventListener('input', updateMargin);
          if (marginRightInput) marginRightInput.addEventListener('input', updateMargin);
          if (marginBottomInput) marginBottomInput.addEventListener('input', updateMargin);
          break;
          
        case 'group':
          const groupOrientationSelect = document.getElementById('insp-groupOrientation');
          const groupAlignmentSelect = document.getElementById('insp-groupAlignment');
          const groupGapInput = document.getElementById('insp-groupGap');
          
          if (groupOrientationSelect) {
            groupOrientationSelect.addEventListener('change', () => {
              p.orientation = groupOrientationSelect.value;
              // Recalcular larguras quando orienta√ß√£o muda
              if (typeof updateGroupChildrenWidths === 'function') {
                updateGroupChildrenWidths(element);
              }
              if (typeof updateGroupDimensions === 'function') {
                updateGroupDimensions(element);
              }
              if (typeof renderAll === 'function') {
                renderAll();
              } else if (typeof render === 'function') {
                render();
              }
            });
          }
          if (groupAlignmentSelect) groupAlignmentSelect.addEventListener('change', () => { 
            p.alignment = groupAlignmentSelect.value; 
            if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render(); 
          });
          if (groupGapInput) {
            groupGapInput.addEventListener('input', () => { 
              p.gap = parseInt(groupGapInput.value) || 10; 
              if (typeof updateGroupDimensions === 'function') updateGroupDimensions(element);
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          // Padding sempre 0 (removido conforme solicitado)
          p.padding = 0;
          break;
          
        case 'qr':
          const qrTextInput = document.getElementById('insp-qrText');
          const qrFitInput = document.getElementById('insp-qrFit');
          const qrEccLevelSelect = document.getElementById('insp-qrEccLevel');
          const qrForegroundInput = document.getElementById('insp-qrForeground');
          const qrForegroundTextInput = document.getElementById('insp-qrForegroundText');
          const qrBackgroundInput = document.getElementById('insp-qrBackground');
          const qrBackgroundTextInput = document.getElementById('insp-qrBackgroundText');
          const qrAlignmentSelect = document.getElementById('insp-qrAlignment');
          
          if (qrTextInput) {
            qrTextInput.addEventListener('input', () => {
              p.text = qrTextInput.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (qrFitInput) {
            qrFitInput.addEventListener('input', () => {
              p.fit = parseInt(qrFitInput.value) || 100;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (qrEccLevelSelect) {
            qrEccLevelSelect.addEventListener('change', () => {
              p.eccLevel = qrEccLevelSelect.value;
              if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
            });
          }
          if (qrForegroundInput && qrForegroundTextInput) {
            qrForegroundInput.addEventListener('input', () => {
              qrForegroundTextInput.value = qrForegroundInput.value;
              p.foreground = qrForegroundInput.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
            qrForegroundTextInput.addEventListener('input', () => {
              if (/^#[0-9A-F]{6}$/i.test(qrForegroundTextInput.value)) {
                qrForegroundInput.value = qrForegroundTextInput.value;
                p.foreground = qrForegroundTextInput.value;
                updateWithoutLosingFocus(() => {
                  if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
                }, 300);
              }
            });
          }
          if (qrBackgroundInput && qrBackgroundTextInput) {
            qrBackgroundInput.addEventListener('input', () => {
              qrBackgroundTextInput.value = qrBackgroundInput.value;
              p.background = qrBackgroundInput.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
            qrBackgroundTextInput.addEventListener('input', () => {
              if (/^#[0-9A-F]{6}$/i.test(qrBackgroundTextInput.value)) {
                qrBackgroundInput.value = qrBackgroundTextInput.value;
                p.background = qrBackgroundTextInput.value;
                updateWithoutLosingFocus(() => {
                  if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
                }, 300);
              }
            });
          }
          if (qrAlignmentSelect) {
            qrAlignmentSelect.addEventListener('change', () => {
              p.alignment = qrAlignmentSelect.value;
              if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
            });
          }
          break;
          
        case 'svg':
          const svgCodeInput = document.getElementById('insp-svgCode');
          const svgWidthInput = document.getElementById('insp-svgWidth');
          const svgHeightInput = document.getElementById('insp-svgHeight');
          const svgColorInput = document.getElementById('insp-svgColor');
          const svgColorTextInput = document.getElementById('insp-svgColorText');
          const svgAlignmentSelect = document.getElementById('insp-svgAlignment');
          
          if (svgCodeInput) {
            svgCodeInput.addEventListener('input', () => {
              p.svg = svgCodeInput.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (svgWidthInput) {
            svgWidthInput.addEventListener('input', () => {
              p.width = parseInt(svgWidthInput.value) || 100;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (svgHeightInput) {
            svgHeightInput.addEventListener('input', () => {
              p.height = parseInt(svgHeightInput.value) || 100;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (svgColorInput && svgColorTextInput) {
            svgColorInput.addEventListener('input', () => {
              svgColorTextInput.value = svgColorInput.value;
              p.color = svgColorInput.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
              }, 300);
            });
            svgColorTextInput.addEventListener('input', () => {
              if (/^#[0-9A-F]{6}$/i.test(svgColorTextInput.value)) {
                svgColorInput.value = svgColorTextInput.value;
                p.color = svgColorTextInput.value;
                updateWithoutLosingFocus(() => {
                  if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
                }, 300);
              }
            });
          }
          if (svgAlignmentSelect) {
            svgAlignmentSelect.addEventListener('change', () => {
              p.alignment = svgAlignmentSelect.value;
              if (typeof renderAll === 'function') renderAll(); else if (typeof render === 'function') render();
            });
          }
          break;
      }
    }

    // -----------------------
    // PDFMake Builder (nested)
    // -----------------------
    function elementToPdfmake(el, context = {}) {
      const p = el.properties || {};
      const { inHeader = false, inFooter = false } = context;

      // helper for common props
      const common = {};
      if (Array.isArray(p.margin)) common.margin = p.margin;
      if (p.alignment) common.alignment = p.alignment;
      if (p.style) common.style = p.style;

      if (el.type === 'header') {
        const headerObj = {
          ...common,
          text: p.text || '',
          fontSize: Number(p.fontSize || 18),
          bold: !!p.bold
        };
        
        // Styling completo
        if (p.color) headerObj.color = p.color;
        if (p.background) headerObj.background = p.background;
        if (p.font) headerObj.font = p.font;
        if (p.decoration) headerObj.decoration = p.decoration;
        if (p.alignment) headerObj.alignment = p.alignment;
        if (p.italics) headerObj.italics = true;
        if (p.lineHeight !== undefined) headerObj.lineHeight = p.lineHeight;
        if (p.characterSpacing !== undefined) headerObj.characterSpacing = p.characterSpacing;
        if (p.decorationStyle) headerObj.decorationStyle = p.decorationStyle;
        if (p.decorationColor) headerObj.decorationColor = p.decorationColor;
        if (p.fontFeatures && Array.isArray(p.fontFeatures) && p.fontFeatures.length > 0) headerObj.fontFeatures = p.fontFeatures;
        
        // Link
        if (p.link && p.link.trim()) {
          headerObj.link = p.link.trim();
        }
        
        return headerObj;
      }

      if (el.type === 'text') {
        let textValue = p.text || '';
        
        // Se o texto estiver dentro de header/footer e contiver placeholders, substituir automaticamente
        // Usar contexto passado ou verificar diretamente
        const isInHeaderFooter = inHeader || inFooter || isElementInHeader(el.id) || isElementInFooter(el.id);
        
        if (isInHeaderFooter && textValue.includes('{{')) {
          // Substituir placeholders por template literals que ser√£o avaliados na fun√ß√£o header/footer
          // O PDFMake espera que isso seja uma string com ${currentPage} e ${pageCount}
          textValue = textValue
            .replace(/\{\{pageNumber\}\}/g, '${currentPage}')
            .replace(/\{\{totalPages\}\}/g, '${pageCount}');
        }
        
        const textObj = {
          ...common,
          text: textValue,
          fontSize: Number(p.fontSize || 14)
        };
        
        // Styling completo
        if (p.color) textObj.color = p.color;
        if (p.background) textObj.background = p.background;
        if (p.font) textObj.font = p.font;
        if (p.decoration) textObj.decoration = p.decoration;
        if (p.alignment) textObj.alignment = p.alignment;
        if (p.bold) textObj.bold = true;
        if (p.italics) textObj.italics = true;
        if (p.lineHeight !== undefined) textObj.lineHeight = p.lineHeight;
        if (p.characterSpacing !== undefined) textObj.characterSpacing = p.characterSpacing;
        if (p.decorationStyle) textObj.decorationStyle = p.decorationStyle;
        if (p.decorationColor) textObj.decorationColor = p.decorationColor;
        if (p.fontFeatures && Array.isArray(p.fontFeatures) && p.fontFeatures.length > 0) textObj.fontFeatures = p.fontFeatures;
        
        // Link
        if (p.link && p.link.trim()) {
          textObj.link = p.link.trim();
        }
        
        return textObj;
      }

      if (el.type === 'image') {
        const out = {
          ...common,
          image: p.url || ''
        };
        
        // Dimensionamento: width/height, fit ou cover (mutuamente exclusivos)
        if (p.fit !== undefined) {
          out.fit = Array.isArray(p.fit) ? [Number(p.fit[0]), Number(p.fit[1])] : Number(p.fit);
        } else if (p.cover !== undefined) {
          out.cover = {
            width: Number(p.cover.width || 300),
            height: Number(p.cover.height || 150),
            ...(p.cover.align ? { align: p.cover.align } : {}),
            ...(p.cover.valign ? { valign: p.cover.valign } : {})
          };
        } else {
          if (p.width !== undefined) out.width = Number(p.width);
          if (p.height !== undefined) out.height = Number(p.height);
        }
        
        // Outras propriedades
        if (p.alignment) out.alignment = p.alignment;
        if (p.opacity !== undefined) out.opacity = Number(p.opacity);
        if (p.borderRadius && p.borderRadius > 0) out.borderRadius = Number(p.borderRadius);
        if (p.absolutePosition) {
          out.absolutePosition = {
            x: Number(p.absolutePosition.x || 0),
            y: Number(p.absolutePosition.y || 0)
          };
        }
        if (p.relativePosition) {
          out.relativePosition = {
            x: Number(p.relativePosition.x || 0),
            y: Number(p.relativePosition.y || 0)
          };
        }
        
        return out;
      }

      if (el.type === 'margin') {
        // No pdfmake, um "texto vazio" com margin ou um canvas; aqui usamos um texto invis√≠vel
        // Suportar tanto o formato antigo (size) quanto o novo (margin array)
        const marginArray = p.margin || (p.size ? [0, p.size, 0, 0] : [0, 20, 0, 0]);
        return { text: ' ', margin: marginArray };
      }

      if (el.type === 'pageBreak') {
        return { text: ' ', pageBreak: 'after' };
      }

      if (el.type === 'qr') {
        const qrObj = {
          ...common,
          qr: p.text || 'https://exemplo.com',
          fit: Number(p.fit || 100)
        };
        if (p.eccLevel) qrObj.eccLevel = p.eccLevel;
        // Sempre aplicar foreground e background (mesmo que sejam os padr√µes)
        qrObj.foreground = p.foreground || '#000000';
        qrObj.background = p.background || '#ffffff';
        if (p.alignment) qrObj.alignment = p.alignment;
        return qrObj;
      }

      if (el.type === 'svg') {
        const svgObj = {
          ...common,
          svg: p.svg || '<svg></svg>'
        };
        if (p.width) svgObj.width = Number(p.width);
        if (p.height) svgObj.height = Number(p.height);
        if (p.color) svgObj.color = p.color;
        if (p.alignment) svgObj.alignment = p.alignment;
        return svgObj;
      }

      if (el.type === 'group') {
        // group no editor = stack no PDF
        // Passar contexto para elementos filhos (se estiver em header/footer, manter contexto)
        const kids = (p.children || []).map(ch => elementToPdfmake(ch, context));
        return kids.length <= 1 ? (kids[0] || { text: '' }) : { stack: kids };
      }

      if (el.type === 'columns') {
        const cols = (p.columns || []).map(col => {
          // Passar contexto para elementos filhos
          const kids = (col.children || []).map(ch => elementToPdfmake(ch, context));
          const contentNode = kids.length <= 1 ? (kids[0] || { text: '' }) : { stack: kids };
          
          // Processar width: pode ser '*', n√∫mero, ou string com '%'
          let width = col.width || '*';
          if (typeof width === 'string' && width.endsWith('%')) {
            // Manter como string com % para PDFMake
            width = width;
          } else if (typeof width === 'number') {
            // N√∫mero = pixels
            width = width;
          } else {
            // '*' ou 'auto' = autom√°tico
            width = '*';
          }
          
          return { width, ...contentNode };
        });
        
              return {
          ...common,
          columnGap: Number(p.gap || 10),
          columns: cols
        };
      }

      if (el.type === 'list') {
        const items = (p.items || []).map(it => {
          if (!it) return '';
          if (it.kind === 'text') return it.text || '';
          if (it.kind === 'node' && it.node) return elementToPdfmake(it.node, context);
          return '';
        });
        const listType = p.listType === 'ol' ? 'ol' : 'ul';
        const listObj = {
          ...common,
          [listType]: items
        };
        
        // Adicionar propriedades extras para listas ordenadas
        if (listType === 'ol') {
          if (p.start && p.start !== 1) listObj.start = p.start;
          if (p.reversed) listObj.reversed = true;
          if (p.type) listObj.type = p.type;
            } else {
          // Para listas n√£o ordenadas, apenas type e markerColor
          if (p.type) listObj.type = p.type;
          if (p.markerColor) listObj.markerColor = p.markerColor;
        }
        
        return listObj;
      }

      if (el.type === 'table') {
        // Primeiro, processar o body e identificar c√©lulas com rowSpan/colSpan
        const processedBody = [];
        const originalBody = p.body || [];
        
        // Rastrear c√©lulas cobertas por spans
        const coveredCells = new Set();
        
        for (let r = 0; r < originalBody.length; r++) {
          const processedRow = [];
          
          for (let c = 0; c < originalBody[r].length; c++) {
            // Pular c√©lulas j√° cobertas
            if (coveredCells.has(`${r}-${c}`)) {
              processedRow.push({}); // C√©lula vazia para PDFMake
              continue;
            }
            
            const cell = originalBody[r][c];
            
            // Se a c√©lula √© null ou string vazia, manter como objeto vazio
            if (!cell || (typeof cell === 'string' && cell === '')) {
              processedRow.push({});
              continue;
            }
            
            // Processar conte√∫do da c√©lula
            // Passar contexto para elementos filhos (se estiver em header/footer, manter contexto)
            const kids = (cell.children || []).map(ch => elementToPdfmake(ch, context));
            const cellContent = (kids.length <= 1) ? (kids[0] || '') : { stack: kids };
            
            // Aplicar estilos da c√©lula
            // Se a c√©lula tem um estilo definido, usar refer√™ncia ao estilo
            // Caso contr√°rio, aplicar propriedades inline
            const cellObj = typeof cellContent === 'string' ? { text: cellContent } : cellContent;
            
            // Se a c√©lula tem um nome de estilo, usar refer√™ncia ao estilo
            // Propriedades que podem estar no estilo: fontSize, alignment, margin, color (texto), bold, italics
            if (cell._styleName) {
              cellObj.style = cell._styleName;
            } else {
              // Aplicar propriedades inline (fallback se n√£o houver estilo)
              if (cell.fontSize !== undefined) cellObj.fontSize = cell.fontSize;
              if (cell.alignment) cellObj.alignment = cell.alignment;
              if (cell.margin && Array.isArray(cell.margin)) cellObj.margin = cell.margin;
              if (cell.color) cellObj.color = cell.color; // Cor do texto
              if (cell.bold !== undefined) cellObj.bold = cell.bold;
              if (cell.italics !== undefined) cellObj.italics = cell.italics;
            }
            
            // Propriedades espec√≠ficas da c√©lula (nunca devem ser estilos)
            // fillColor = cor de fundo da c√©lula (diferente de color = cor do texto)
            // S√≥ aplicar fillColor individual se zebra n√£o estiver ativado
            if (!p.zebraEnabled && cell.fillColor) cellObj.fillColor = cell.fillColor;
            if (cell.fillOpacity !== undefined) cellObj.fillOpacity = Number(cell.fillOpacity);
            
            // rowSpan e colSpan - IMPORTANTE: marcar c√©lulas cobertas
            if (cell.rowSpan && cell.rowSpan > 1) {
              cellObj.rowSpan = cell.rowSpan;
              // Marcar c√©lulas abaixo como cobertas
              for (let sr = 1; sr < cell.rowSpan; sr++) {
                if (r + sr < originalBody.length) {
                  coveredCells.add(`${r + sr}-${c}`);
                }
              }
            }
            if (cell.colSpan && cell.colSpan > 1) {
              cellObj.colSpan = cell.colSpan;
              // Marcar c√©lulas √† direita como cobertas
              for (let sc = 1; sc < cell.colSpan; sc++) {
                if (c + sc < originalBody[r].length) {
                  coveredCells.add(`${r}-${c + sc}`);
                }
              }
            }
            
            // border (array de 4 booleanos [left, top, right, bottom])
            if (cell.border && Array.isArray(cell.border)) {
              // Sempre adicionar o array de border, mesmo se for [true, true, true, true]
              // O PDFMake usa isso para controlar quais bordas mostrar
              cellObj.border = cell.border.map(b => Boolean(b));
            }
            
            // borderColor (array de 4 cores)
            if (cell.borderColor && Array.isArray(cell.borderColor)) {
              // S√≥ adicionar se houver pelo menos uma cor definida
              if (cell.borderColor.some(c => c && c.trim())) {
                cellObj.borderColor = cell.borderColor.map(c => c || '');
              }
            }
            
            processedRow.push(cellObj);
          }
          
          processedBody.push(processedRow);
        }
        
        const body = processedBody;
        
        const tableObj = {
          ...common,
          table: {
            widths: (p.widths || (body[0] ? body[0].map(() => '*') : ['*'])),
            body
          }
        };
        
        // heights (pode ser n√∫mero, array ou fun√ß√£o)
        if (p.heights !== undefined) {
          if (typeof p.heights === 'number') {
            tableObj.table.heights = p.heights;
          } else if (Array.isArray(p.heights)) {
            tableObj.table.heights = p.heights.map(h => Number(h) || 40);
          }
          // Fun√ß√£o ser√° tratada separadamente se necess√°rio
        }
        
        // Tabela zebrada tem prioridade - se ativada, sempre criar layout como objeto
        // IMPORTANTE: layout deve ficar no mesmo n√≠vel que table, n√£o dentro de table
        if (p.zebraEnabled && p.zebraColor) {
          // Criar layout como objeto (n√£o string) - mesmo n√≠vel que table
          tableObj.layout = {};
          
          // Usar a cor diretamente como string no c√≥digo da fun√ß√£o
          // Criar fun√ß√£o usando Function constructor para que a cor seja string literal no c√≥digo fonte
          const zebraColorStr = p.zebraColor;
          // Criar fun√ß√£o que quando serializada j√° ter√° a cor como string literal
          tableObj.layout.fillColor = new Function('i', 'node', 
            `return (i % 2 === 0) ? '${zebraColorStr}' : null;`
          );
          // Armazenar a cor como propriedade tamb√©m para backup na serializa√ß√£o
          tableObj.layout.fillColor._zebraColor = zebraColorStr;
          
          // Se zebraWithLines estiver ativado, adicionar linhas horizontais (seguindo o exemplo)
          // IMPORTANTE: Usar new Function() para que valores sejam literais no c√≥digo gerado
          if (p.zebraWithLines !== false) {
            tableObj.layout.hLineWidth = new Function('i', 'node', 
              `if (i === 0 || i === node.table.body.length) {
                return 0;
              }
              return (i === node.table.headerRows) ? 2 : 1;`
            );
            tableObj.layout.hLineColor = new Function('i', 
              `return i === 1 ? 'black' : '#aaa';`
            );
            tableObj.layout.vLineWidth = new Function('i', 
              `return 0;`
            );
          } else {
            // Sem linhas horizontais
            tableObj.layout.hLineWidth = new Function('i', 'node', 
              `return 0;`
            );
            tableObj.layout.vLineWidth = new Function('i', 
              `return 0;`
            );
          }
          
          // Padding padr√£o (se n√£o houver customLayout)
          // IMPORTANTE: Usar new Function() para que valores sejam literais no c√≥digo gerado
          if (!p.customLayout || !p.customLayout.paddingLeft) {
            tableObj.layout.paddingLeft = new Function('i', 
              `return i === 0 ? 0 : 8;`
            );
          }
          if (!p.customLayout || !p.customLayout.paddingRight) {
            tableObj.layout.paddingRight = new Function('i', 'node', 
              `return (i === node.table.widths.length - 1) ? 0 : 8;`
            );
          }
          
          // Se houver customLayout, aplicar suas configura√ß√µes de padding
          // IMPORTANTE: Usar new Function() para que valores sejam literais no c√≥digo gerado
          if (p.customLayout) {
            if (p.customLayout.paddingLeft !== undefined) {
              const paddingLeft = Number(p.customLayout.paddingLeft);
              tableObj.layout.paddingLeft = new Function('i', 
                `return i === 0 ? 0 : ${paddingLeft};`
              );
            }
            if (p.customLayout.paddingRight !== undefined) {
              const paddingRight = Number(p.customLayout.paddingRight);
              tableObj.layout.paddingRight = new Function('i', 'node', 
                `return (i === node.table.widths.length - 1) ? 0 : ${paddingRight};`
              );
            }
            if (p.customLayout.paddingTop !== undefined) {
              const paddingTop = Number(p.customLayout.paddingTop);
              tableObj.layout.paddingTop = new Function('i', 
                `return ${paddingTop};`
              );
            }
            if (p.customLayout.paddingBottom !== undefined) {
              const paddingBottom = Number(p.customLayout.paddingBottom);
              tableObj.layout.paddingBottom = new Function('i', 
                `return ${paddingBottom};`
              );
            }
          }
        } else if (p.layout === 'custom' && p.customLayout) {
          // Layout customizado (sem zebra)
          const customLayout = {};
          
          // Linhas horizontais
          // IMPORTANTE: Usar new Function() para que valores sejam literais no c√≥digo gerado
          if (p.customLayout.hLineWidth !== undefined) {
            const hLineWidth = Number(p.customLayout.hLineWidth || 1);
            customLayout.hLineWidth = new Function('i', 'node', 
              `return ${hLineWidth};`
            );
          }
          if (p.customLayout.hLineColor) {
            const hLineColor = p.customLayout.hLineColor;
            customLayout.hLineColor = new Function('i', 'node', 
              `return '${hLineColor}';`
            );
          }
          
          // Linhas verticais
          if (p.customLayout.vLineWidth !== undefined) {
            const vLineWidth = Number(p.customLayout.vLineWidth || 1);
            customLayout.vLineWidth = new Function('i', 'node', 
              `return ${vLineWidth};`
            );
          }
          if (p.customLayout.vLineColor) {
            const vLineColor = p.customLayout.vLineColor;
            customLayout.vLineColor = new Function('i', 'node', 
              `return '${vLineColor}';`
            );
          }
          
          // Padding (deve ser fun√ß√£o, n√£o valor fixo)
          if (p.customLayout.paddingLeft !== undefined) {
            const paddingLeft = Number(p.customLayout.paddingLeft);
            customLayout.paddingLeft = new Function('i', 
              `return i === 0 ? 0 : ${paddingLeft};`
            );
          }
          if (p.customLayout.paddingRight !== undefined) {
            const paddingRight = Number(p.customLayout.paddingRight);
            customLayout.paddingRight = new Function('i', 'node', 
              `return (i === node.table.widths.length - 1) ? 0 : ${paddingRight};`
            );
          }
          if (p.customLayout.paddingTop !== undefined) {
            const paddingTop = Number(p.customLayout.paddingTop);
            customLayout.paddingTop = new Function('i', 
              `return ${paddingTop};`
            );
          }
          if (p.customLayout.paddingBottom !== undefined) {
            const paddingBottom = Number(p.customLayout.paddingBottom);
            customLayout.paddingBottom = new Function('i', 
              `return ${paddingBottom};`
            );
          }
          
          // hLineStyle e vLineStyle (dashed)
          // IMPORTANTE: Usar new Function() para que valores sejam literais no c√≥digo gerado
          if (p.customLayout.hLineStyle) {
            customLayout.hLineStyle = new Function('i', 'node', 
              `if (i === 0 || i === node.table.body.length) {
            return null;
        }
              return { dash: { length: 10, space: 4 } };`
            );
          }
          if (p.customLayout.vLineStyle) {
            customLayout.vLineStyle = new Function('i', 'node', 
              `if (i === 0 || i === node.table.widths.length) {
                return null;
              }
              return { dash: { length: 4 } };`
            );
          }
          
          // defaultBorder
          if (p.customLayout.defaultBorder !== undefined) {
            customLayout.defaultBorder = p.customLayout.defaultBorder;
          }
          
          if (Object.keys(customLayout).length > 0) {
            // Layout deve ficar no mesmo n√≠vel que table, n√£o dentro de table
            tableObj.layout = customLayout;
          }
        } else if (p.layout && p.layout !== 'custom') {
          // Layout padr√£o (string) - tamb√©m no mesmo n√≠vel que table
          tableObj.layout = p.layout;
        }
        
        // Adicionar propriedades extras da tabela
        // dontBreakRows e keepWithHeaderRows devem estar dentro de table, n√£o no objeto principal
        if (p.dontBreakRows) tableObj.table.dontBreakRows = true;
        if (p.keepWithHeaderRows) tableObj.table.keepWithHeaderRows = p.keepWithHeaderRows;
        
        // headerRows deve ser definido se houver cabe√ßalho (primeira linha)
        if (body.length > 0) {
          tableObj.table.headerRows = 1;
        }
        
        return tableObj;
      }

      return { ...common, text: '' };
    }

    // Processar vari√°veis din√¢micas em header/footer
    function processHeaderFooterText(text, currentPage, totalPages) {
      if (!text) return '';
      return text
        .replace(/\{\{pageNumber\}\}/g, currentPage.toString())
        .replace(/\{\{totalPages\}\}/g, totalPages.toString());
    }
    
    function buildDocDefinition() {
      const root = getRootGroup();
      
      // Primeiro, coletar estilos das c√©lulas ANTES de converter para PDFMake
      const cellStylesMap = new Map();
      let styleCounter = 0;
      
      function collectTableCellStyles(element) {
        if (!element || element.type !== 'table') return;
        const p = element.properties || {};
        const body = p.body || [];
        
        body.forEach(row => {
          if (Array.isArray(row)) {
            row.forEach(cell => {
              if (cell && typeof cell === 'object' && cell.children) {
                // Coletar propriedades de estilo da c√©lula
                const styleProps = {};
                // Verificar propriedades que podem ser estilos
                // Nota: fillColor, color, fillOpacity s√£o espec√≠ficos da c√©lula e n√£o devem ser estilos
                // Mas fontSize, alignment, margin, bold podem ser estilos
                
                // Coletar do objeto cell diretamente (propriedades da c√©lula)
                // Essas propriedades v√™m do editor de c√©lulas
                const cellStyleKey = JSON.stringify({
                  fontSize: cell.fontSize,
                  alignment: cell.alignment,
                  margin: cell.margin,
                  color: cell.color,
                  bold: cell.bold,
                  italics: cell.italics
                });
                
                if (!cellStylesMap.has(cellStyleKey) && cell.fontSize) {
                  const styleName = `tableCellStyle${++styleCounter}`;
                  const styleObj = {};
                  if (cell.fontSize) styleObj.fontSize = cell.fontSize;
                  if (cell.alignment) styleObj.alignment = cell.alignment;
                  if (cell.margin && Array.isArray(cell.margin)) styleObj.margin = cell.margin;
                  if (cell.color) styleObj.color = cell.color;
                  if (cell.bold !== undefined) styleObj.bold = cell.bold;
                  if (cell.italics !== undefined) styleObj.italics = cell.italics;
                  
                  cellStylesMap.set(cellStyleKey, { name: styleName, props: styleObj });
                  // Armazenar o nome do estilo na c√©lula para uso posterior
                  cell._styleName = styleName;
                } else if (cellStylesMap.has(cellStyleKey)) {
                  cell._styleName = cellStylesMap.get(cellStyleKey).name;
                }
              }
            });
          }
        });
      }
      
      // Coletar estilos recursivamente de todas as tabelas
      function traverseElements(el) {
        if (!el) return;
        if (el.type === 'table') {
          collectTableCellStyles(el);
        }
        if (el.properties && el.properties.children) {
          el.properties.children.forEach(traverseElements);
        }
      }
      traverseElements(root);
      
      // Agora converter para PDFMake (os estilos j√° est√£o marcados nas c√©lulas)
      const content = root ? [elementToPdfmake(root)] : [];

      const docDef = {
        pageSize,
        pageOrientation: orientation,
        pageMargins,
        content
      };
      
      // Adicionar estilos coletados ao docDef
      if (cellStylesMap.size > 0) {
        docDef.styles = {};
        cellStylesMap.forEach(({ name, props }) => {
          docDef.styles[name] = props;
        });
      }
      
      // Adicionar header se configurado (usando container visual)
      if (documentHeader && documentHeader.enabled && documentHeader.root) {
        const headerChildren = documentHeader.root.properties.children || [];
        if (headerChildren.length > 0) {
          // Converter elementos do header para PDFMake
          // Passar contexto para processar placeholders corretamente
          const headerContent = headerChildren.map(el => elementToPdfmake(el, { inHeader: true }));
          
          // Criar fun√ß√£o que retorna o array de conte√∫do
          docDef.header = function(currentPage, pageCount, pageSize) {
            return headerContent;
          };
          // Armazenar conte√∫do serializado para uso na gera√ß√£o de c√≥digo
          docDef.header._content = headerContent;
        }
      }
      
      // Adicionar footer se configurado (usando container visual)
      if (documentFooter && documentFooter.enabled && documentFooter.root) {
        const footerChildren = documentFooter.root.properties.children || [];
        if (footerChildren.length > 0) {
          // Converter elementos do footer para PDFMake
          // Passar contexto para processar placeholders corretamente
          const footerContent = footerChildren.map(el => elementToPdfmake(el, { inFooter: true }));
          
          // Criar fun√ß√£o que retorna o array de conte√∫do
          docDef.footer = function(currentPage, pageCount, pageSize) {
            return footerContent;
          };
          // Armazenar conte√∫do serializado para uso na gera√ß√£o de c√≥digo
          docDef.footer._content = footerContent;
        }
      }
      
      // Adicionar watermark se configurado (apenas texto - PDFMake n√£o suporta imagens)
      if (documentWatermark && documentWatermark.text && documentWatermark.text.trim()) {
        docDef.watermark = {
          text: documentWatermark.text,
          fontSize: documentWatermark.fontSize || 48,
          color: documentWatermark.color || '#cccccc',
          opacity: documentWatermark.opacity !== undefined ? documentWatermark.opacity : 0.3,
          angle: documentWatermark.angle !== undefined ? documentWatermark.angle : -45
        };
      }
      
      // Adicionar TOC se configurado
      if (documentTOC && documentTOC.enabled) {
        // O TOC ser√° adicionado no in√≠cio do content
        const tocItem = {
          toc: {
            title: { text: documentTOC.title || '√çndice', ...(documentTOC.titleStyle || {}) },
            textStyle: documentTOC.textStyle || {},
            numberStyle: documentTOC.numberStyle || {},
            margin: documentTOC.margin || [0, 0, 0, 20]
          }
        };
        docDef.content.unshift(tocItem);
      }
      
      // Adicionar Security se configurado
      if (documentSecurity && documentSecurity.enabled && documentSecurity.userPassword) {
        docDef.userPassword = documentSecurity.userPassword;
        if (documentSecurity.ownerPassword) {
          docDef.ownerPassword = documentSecurity.ownerPassword;
        }
        if (documentSecurity.permissions) {
          docDef.permissions = {
            printing: documentSecurity.permissions.printing !== false ? 'highResolution' : false,
            modifying: documentSecurity.permissions.modifying !== false,
            copying: documentSecurity.permissions.copying !== false,
            annotating: documentSecurity.permissions.annotating !== false
          };
        }
      }
      
      // Adicionar Info (Metadados) se configurado
      if (documentPageInfo && (documentPageInfo.author || documentPageInfo.title || documentPageInfo.subject || documentPageInfo.keywords)) {
        docDef.info = {};
        if (documentPageInfo.author) docDef.info.author = documentPageInfo.author;
        if (documentPageInfo.title) docDef.info.title = documentPageInfo.title;
        if (documentPageInfo.subject) docDef.info.subject = documentPageInfo.subject;
        if (documentPageInfo.keywords) docDef.info.keywords = documentPageInfo.keywords;
      }
      
      // Adicionar Compress se configurado
      if (documentCompress) {
        docDef.compress = true;
      }
      
      return docDef;
    }

    
    // -----------------------
    // Confirm Modal Helpers
    // -----------------------
    let confirmModalCallback = null;

    function showConfirmModal(title, message, callback) {
      const modal = document.getElementById('confirmModal');
      const titleEl = document.getElementById('confirmModalTitle');
      const messageEl = document.getElementById('confirmModalMessage');
      
      if (!modal || !titleEl || !messageEl) {
        console.error('Modal de confirma√ß√£o n√£o encontrado');
        return;
      }
      
      titleEl.textContent = title || 'Confirmar a√ß√£o';
      messageEl.textContent = message || 'Tem certeza que deseja realizar esta a√ß√£o?';
      confirmModalCallback = callback;
      
      modal.classList.add('active');
    }
    window.showConfirmModal = showConfirmModal; // Tornar global

    function confirmModalAction() {
      if (confirmModalCallback) {
        confirmModalCallback();
      }
      closeConfirmModal();
    }
    window.confirmModalAction = confirmModalAction; // Tornar global para uso no onclick
    
    function closeConfirmModal() {
      const modal = document.getElementById('confirmModal');
      if (modal) {
        modal.classList.remove('active');
      }
      confirmModalCallback = null;
    }
    window.closeConfirmModal = closeConfirmModal; // Tornar global para uso no onclick

    // -----------------------
    // Alert Modal Helpers
    // -----------------------
    function showAlertModal(title, message) {
      const modal = document.getElementById('alertModal');
      const titleEl = modal.querySelector('.custom-modal-header h3');
      const messageEl = document.getElementById('alertModalMessage');
      
      if (titleEl) titleEl.textContent = title || 'Aviso';
      if (messageEl) messageEl.textContent = message || 'Mensagem de alerta';
      
      if (modal) {
        modal.classList.add('active');
      }
    }
    window.showAlertModal = showAlertModal; // Tornar global
    
    function closeAlertModal() {
      const modal = document.getElementById('alertModal');
      if (modal) {
        modal.classList.remove('active');
      }
    }
    window.closeAlertModal = closeAlertModal; // Tornar global para uso no onclick

    // Fechar modal de preview do PDF
    function closePreviewModal() {
      const modal = document.getElementById('previewModal');
      const iframe = document.getElementById('previewIframe');
      
      if (modal) {
        modal.classList.remove('active');
      }
      
      // Limpar o src do iframe para liberar mem√≥ria
      if (iframe && iframe.src) {
        URL.revokeObjectURL(iframe.src);
        iframe.src = '';
      }
    }
    window.closePreviewModal = closePreviewModal; // Tornar global para uso no onclick

    function closeBubbleTestModal() {
      const modal = document.getElementById('bubbleTestModal');
      const iframe = document.getElementById('bubbleTestIframe');
      
      if (modal) {
        modal.classList.remove('active');
      }
      
      // Limpar o src do iframe
      if (iframe) {
        iframe.src = '';
      }
    }
    window.closeBubbleTestModal = closeBubbleTestModal; // Tornar global para uso no onclick

    // Fechar modais com ESC
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeConfirmModal();
        closePreviewModal();
        closeBubbleTestModal();
      }
    });

// -----------------------
    // Code tab
    // -----------------------
    function updateCode() {
      const dd = buildDocDefinition();
      
      // Mapear fun√ß√µes para seus valores de vari√°veis locais (para substitui√ß√£o)
      const functionVariableMap = new Map();
      
      // Coletar informa√ß√µes sobre fun√ß√µes e suas vari√°veis locais
      // Esta fun√ß√£o coleta valores de vari√°veis usadas em fun√ß√µes para substitui√ß√£o na serializa√ß√£o
      function collectFunctionVariables(obj, path = '') {
        if (!obj || typeof obj !== 'object') return;
        
        if (Array.isArray(obj)) {
          obj.forEach((item, idx) => {
            collectFunctionVariables(item, `${path}[${idx}]`);
          });
            } else {
          // Verificar se √© uma tabela com layout
          if (obj.table && obj.layout && typeof obj.layout === 'object') {
            const layout = obj.layout;
            Object.keys(layout).forEach(key => {
              if (typeof layout[key] === 'function') {
                const funcStr = layout[key].toString();
                const currentPath = `${path}.layout.${key}`;
                
                // Tentar executar a fun√ß√£o para obter valores de retorno
                try {
                  // Para fillColor, testar com linha par
                  if (key === 'fillColor') {
                    const testResult = layout[key](2, { table: { body: [[], [], []] } });
                    if (testResult && typeof testResult === 'string') {
                      functionVariableMap.set(currentPath, {
                        type: 'fillColor',
                        color: testResult
                      });
                    }
                  }
                  // Para padding, testar com diferentes √≠ndices
                  else if (key.startsWith('padding')) {
                    const testResult = layout[key](1, { table: { widths: ['*', '*'] } });
                    if (typeof testResult === 'number') {
                      functionVariableMap.set(currentPath, {
                        type: 'padding',
                        value: testResult
                      });
                    }
                  }
                  // Para hLineWidth, vLineWidth
                  else if (key.includes('LineWidth')) {
                    const testResult = layout[key](1, { table: { body: [[], []], widths: ['*', '*'] } });
                    if (typeof testResult === 'number') {
                      functionVariableMap.set(currentPath, {
                        type: 'lineWidth',
                        value: testResult
                      });
                    }
                  }
                  // Para hLineColor, vLineColor
                  else if (key.includes('LineColor')) {
                    const testResult = layout[key](1, {});
                    if (typeof testResult === 'string') {
                      functionVariableMap.set(currentPath, {
                        type: 'lineColor',
                        color: testResult
                      });
                    }
                  }
                } catch (e) {
                  // Se falhar, tentar usar propriedades armazenadas
                  if (layout[key]._zebraColor) {
                    functionVariableMap.set(currentPath, {
                      type: 'fillColor',
                      color: layout[key]._zebraColor
                    });
                  }
                }
              }
            });
          }
          
          Object.keys(obj).forEach(key => {
            if (key !== 'header' && key !== 'footer') {
              collectFunctionVariables(obj[key], path ? `${path}.${key}` : key);
            }
          });
        }
      }
      collectFunctionVariables(dd);
      
      // Fun√ß√£o recursiva para serializar objeto incluindo fun√ß√µes inline
      function serializeObject(obj, indent = 0, isInArray = false, currentPath = '') {
        const indentStr = '  '.repeat(indent);
        const nextIndent = indent + 1;
        const nextIndentStr = '  '.repeat(nextIndent);
        
        if (obj === null) return 'null';
        if (obj === undefined) return 'undefined';
        
        // Remover propriedades internas do PDFMake
        if (typeof obj === 'object' && !Array.isArray(obj) && obj !== null) {
          const filtered = {};
          Object.keys(obj).forEach(key => {
            if (!key.startsWith('_')) {
              filtered[key] = obj[key];
            }
          });
          obj = filtered;
        }
        
        if (Array.isArray(obj)) {
          if (obj.length === 0) return '[]';
          let result = '[\n';
          obj.forEach((item, idx) => {
            result += nextIndentStr + serializeObject(item, nextIndent, true, `${currentPath}[${idx}]`);
            if (idx < obj.length - 1) result += ',';
            result += '\n';
          });
          result += indentStr + ']';
          return result;
        }
        
        if (typeof obj === 'function') {
          // Para header/footer, usar conte√∫do serializado armazenado em _content
          if (obj._content && Array.isArray(obj._content)) {
            // Serializar o conte√∫do como array literal dentro da fun√ß√£o
            // IMPORTANTE: Serializar cada item recursivamente para garantir valores literais
            let contentStr = '';
            if (obj._content.length === 0) {
              contentStr = '[]';
            } else {
              const items = [];
              obj._content.forEach((item, idx) => {
                const itemStr = serializeObject(item, nextIndent + 1, true, `${currentPath}._content[${idx}]`);
                items.push(itemStr);
              });
              // Formatar array com indenta√ß√£o correta
              if (items.length === 1 && !items[0].includes('\n')) {
                // Array de um item simples - uma linha
                contentStr = `[${items[0]}]`;
              } else {
                // Array multi-linha
                contentStr = '[\n';
                items.forEach((itemStr, idx) => {
                  // Adicionar indenta√ß√£o extra para cada item
                  const lines = itemStr.split('\n');
                  lines.forEach((line, lineIdx) => {
                    if (lineIdx === 0) {
                      contentStr += nextIndentStr + '  ' + line;
                    } else {
                      contentStr += '\n' + nextIndentStr + '  ' + line;
                    }
                  });
                  if (idx < items.length - 1) contentStr += ',';
                  contentStr += '\n';
                });
                contentStr += nextIndentStr + ']';
              }
            }
            return `function(currentPage, pageCount, pageSize) {\n${nextIndentStr}return ${contentStr};\n${indentStr}}`;
          }
          
          // Serializar fun√ß√£o como string de c√≥digo formatada
          let funcStr = obj.toString();
          
          // Obter informa√ß√µes da vari√°vel mapeada
          const varInfo = functionVariableMap.get(currentPath);
          
          // Substituir vari√°veis conhecidas por valores literais
          // 1. Se a fun√ß√£o tem propriedade _zebraColor, usar diretamente
          if (obj._zebraColor) {
            funcStr = funcStr.replace(/\bzebraColorStr\b|\bzebraColor\b|\bbaseColor\b/g, `'${obj._zebraColor}'`);
          }
          // 2. Se temos informa√ß√£o do mapeamento, usar
          else if (varInfo) {
            if (varInfo.type === 'fillColor' && varInfo.color) {
              funcStr = funcStr.replace(/\bzebraColorStr\b|\bzebraColor\b|\bbaseColor\b/g, `'${varInfo.color}'`);
            } else if (varInfo.type === 'padding' && typeof varInfo.value === 'number') {
              // Substituir vari√°veis de padding (paddingLeft, paddingRight, paddingTop, paddingBottom)
              funcStr = funcStr.replace(/\bpaddingLeft\b|\bpaddingRight\b|\bpaddingTop\b|\bpaddingBottom\b/g, varInfo.value.toString());
            } else if (varInfo.type === 'lineWidth' && typeof varInfo.value === 'number') {
              // Substituir vari√°veis de lineWidth
              funcStr = funcStr.replace(/\bhLineWidth\b|\bvLineWidth\b/g, varInfo.value.toString());
            } else if (varInfo.type === 'lineColor' && varInfo.color) {
              // Substituir vari√°veis de lineColor
              funcStr = funcStr.replace(/\bhLineColor\b|\bvLineColor\b/g, `'${varInfo.color}'`);
            }
          }
          // 3. Tentar executar a fun√ß√£o para obter valores
          else {
            try {
              // Para fillColor
              if (funcStr.includes('fillColor') || funcStr.includes('zebraColor') || funcStr.includes('baseColor')) {
                const testResult = obj(2, { table: { body: [[], [], []] } });
                if (testResult && typeof testResult === 'string' && testResult.match(/^#[0-9A-Fa-f]{6}$/)) {
                  funcStr = funcStr.replace(/\bzebraColorStr\b|\bzebraColor\b|\bbaseColor\b/g, `'${testResult}'`);
                }
              }
              // Para padding
              else if (funcStr.includes('padding')) {
                const testResult = obj(1, { table: { widths: ['*', '*'] } });
                if (typeof testResult === 'number') {
                  // Encontrar o nome da vari√°vel de padding no c√≥digo
                  const paddingMatch = funcStr.match(/\b(paddingLeft|paddingRight|paddingTop|paddingBottom)\b/);
                  if (paddingMatch) {
                    funcStr = funcStr.replace(new RegExp(`\\b${paddingMatch[1]}\\b`, 'g'), testResult.toString());
                  }
                }
              }
              // Para lineWidth
              else if (funcStr.includes('LineWidth')) {
                const testResult = obj(1, { table: { body: [[], []], widths: ['*', '*'] } });
                if (typeof testResult === 'number') {
                  const lineWidthMatch = funcStr.match(/\b(hLineWidth|vLineWidth)\b/);
                  if (lineWidthMatch) {
                    funcStr = funcStr.replace(new RegExp(`\\b${lineWidthMatch[1]}\\b`, 'g'), testResult.toString());
                  }
                }
              }
              // Para lineColor
              else if (funcStr.includes('LineColor')) {
                const testResult = obj(1, {});
                if (typeof testResult === 'string') {
                  const lineColorMatch = funcStr.match(/\b(hLineColor|vLineColor)\b/);
                  if (lineColorMatch) {
                    funcStr = funcStr.replace(new RegExp(`\\b${lineColorMatch[1]}\\b`, 'g'), `'${testResult}'`);
                  }
                }
              }
            } catch (e) {
              // Ignorar erro - fun√ß√£o pode n√£o ser execut√°vel neste contexto
            }
          }
          
          // Substitui√ß√£o final: procurar padr√µes comuns de vari√°veis
          // Padr√£o: return (i % 2 === 0) ? zebraColorStr : null;
          const returnMatch = funcStr.match(/return\s*\([^)]+\)\s*\?\s*(\w+)\s*:/);
          if (returnMatch) {
            const varName = returnMatch[1];
            // Se ainda n√£o foi substitu√≠do, tentar obter do mapeamento ou propriedade
            if (funcStr.includes(varName)) {
              const value = obj._zebraColor || functionVariableMap.get(currentPath)?.color || functionVariableMap.get(currentPath)?.value;
              if (value !== undefined) {
                const replacement = typeof value === 'string' ? `'${value}'` : value.toString();
                funcStr = funcStr.replace(new RegExp(`\\b${varName}\\b`, 'g'), replacement);
              }
            }
          }
          
          // Remover quebras de linha extras e formatar com indenta√ß√£o correta
          // Se a fun√ß√£o foi criada com new Function(), ela j√° tem o formato correto
          // Se foi criada com function(), precisa ser formatada
          const lines = funcStr.split('\n').filter(line => line.trim() !== '');
          if (lines.length > 1) {
            // Fun√ß√£o multi-linha - formatar com indenta√ß√£o
            let formatted = lines[0].trim() + '\n';
            for (let i = 1; i < lines.length - 1; i++) {
              const line = lines[i].trim();
              // Adicionar indenta√ß√£o extra para o corpo da fun√ß√£o
              formatted += nextIndentStr + '  ' + line + '\n';
            }
            if (lines.length > 1) {
              formatted += nextIndentStr + lines[lines.length - 1].trim();
            }
            return formatted;
          }
          // Fun√ß√£o de uma linha - manter como est√°
          return funcStr;
        }
        
        if (typeof obj === 'string') {
          // Escapar caracteres especiais e usar template literals se necess√°rio
          if (obj.includes('${') || obj.includes('`')) {
            // Usar template literal
            const escaped = obj.replace(/\\/g, '\\\\').replace(/`/g, '\\`');
            return '`' + escaped + '`';
          }
          // Usar string normal
          const escaped = obj
            .replace(/\\/g, '\\\\')
            .replace(/'/g, "\\'")
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t');
          return `'${escaped}'`;
        }
        
        if (typeof obj === 'object' && obj !== null) {
          const keys = Object.keys(obj);
          if (keys.length === 0) return '{}';
          
          let result = '{\n';
          let validKeys = keys.filter(key => {
            // Filtrar propriedades internas e undefined
            if (key.startsWith('_')) return false;
            const value = obj[key];
            // N√£o incluir propriedades undefined (mas incluir null)
            if (value === undefined) return false;
            return true;
          });
          
          validKeys.forEach((key, idx) => {
            const value = obj[key];
            
            // Validar nome da chave (n√£o pode come√ßar com n√∫mero ou ter caracteres especiais problem√°ticos)
            const safeKey = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : JSON.stringify(key);
            
            // Limpar widths se for array
            if (key === 'widths' && Array.isArray(value)) {
              const cleanedWidths = value.map(w => {
                if (typeof w === 'object' && w !== null) {
                  if (w.width !== undefined) return w.width;
                  return '*';
                }
                return w;
              });
              result += nextIndentStr + `${safeKey}: ${JSON.stringify(cleanedWidths)}`;
            } else {
              const newPath = currentPath ? `${currentPath}.${key}` : key;
              const serialized = serializeObject(value, nextIndent, false, newPath);
              result += nextIndentStr + `${safeKey}: ${serialized}`;
            }
            
            if (idx < validKeys.length - 1) result += ',';
            result += '\n';
          });
          result += indentStr + '}';
          return result;
        }
        
        // N√∫meros, booleanos, etc.
        return JSON.stringify(obj);
      }
      
      // Construir c√≥digo completo com tudo dentro do objeto dd
      let code = 'const dd = ' + serializeObject(dd, 0, false, 'dd') + ';\n';
      
      codeEditor.textContent = code;
      
      // Salvar c√≥digo gerado no localStorage
      try {
        localStorage.setItem(STORAGE_CODE_KEY, code);
      } catch (e) {
        console.warn('Erro ao salvar c√≥digo no localStorage:', e);
      }
    }

    function copyCode() {
      const text = codeEditor.textContent || '';
      navigator.clipboard.writeText(text).then(() => {
        if (!copyBtn) return;
        copyBtn.classList.add('copied');
        copyBtn.textContent = '‚úÖ Copiado';
        setTimeout(() => {
          copyBtn.classList.remove('copied');
          copyBtn.textContent = 'üìã Copiar';
        }, 1200);
      });
    }
    window.copyCode = copyCode;

    // -----------------------
    // Tabs (editor/code) - already in layout
    // -----------------------
    function switchTab(tab) {
      const tabEditorBtn = document.getElementById('tabEditor');
      const tabPageBtn = document.getElementById('tabPage');
      const tabCodeBtn = document.getElementById('tabCode');
      const contentEditor = document.getElementById('tabContentEditor');
      const contentPage = document.getElementById('tabContentPage');
      const contentCode = document.getElementById('tabContentCode');

      // Remover active de todos
      [tabEditorBtn, tabPageBtn, tabCodeBtn].forEach(btn => btn?.classList.remove('active'));
      [contentEditor, contentPage, contentCode].forEach(content => content?.classList.remove('active'));

      if (tab === 'code') {
        tabCodeBtn.classList.add('active');
        contentCode.classList.add('active');
        updateCode();
      } else if (tab === 'page') {
        tabPageBtn.classList.add('active');
        contentPage.classList.add('active');
        renderPageInspector();
      } else {
        tabEditorBtn.classList.add('active');
        contentEditor.classList.add('active');
      }
    }
    
    // Renderizar Page Inspector (combina TOC, Header/Footer e Watermark)
    function renderPageInspector() {
      const inspector = document.getElementById('pageInspector');
      if (!inspector) return;
      
      // Combinar os 3 conte√∫dos em uma √∫nica p√°gina
      inspector.innerHTML = `
        <!-- Se√ß√£o 1: √çndice (TOC) -->
        <div style="margin-bottom: 2rem;">
          <h3 style="margin-bottom: 1rem; font-size: 1.125rem; font-weight: 600; color: #2563eb;">üìë √çndice (Table of Contents)</h3>
          <div class="inspector-field">
            <label><input type="checkbox" id="tocEnabled" ${documentTOC?.enabled ? 'checked' : ''}> Habilitar √çndice</label>
            <div class="smallNote">Marque elementos como "TOC" no editor para inclu√≠-los no √≠ndice</div>
          </div>
          <div id="tocOptions" style="${documentTOC?.enabled ? '' : 'display: none;'}">
            <div class="inspector-field">
              <label>T√≠tulo do √çndice</label>
              <input type="text" id="tocTitle" value="${escapeHtml(documentTOC?.title || '√çndice')}">
            </div>
            <div class="inspector-field">
              <div class="smallNote" style="padding: 0.75rem; background: #111827; border-left: 3px solid #2563eb; margin-bottom: 1rem; border-radius: 0.25rem;">
                <strong>üí° Como usar:</strong><br>
                ‚Ä¢ Selecione um elemento (text, header) no canvas<br>
                ‚Ä¢ No editor, marque a op√ß√£o "Incluir no √çndice"<br>
                ‚Ä¢ O elemento aparecer√° automaticamente no √≠ndice
              </div>
            </div>
          </div>
        </div>
        
        <!-- Separador -->
        <div style="margin: 2rem 0; border-top: 1px solid #e5e7eb;"></div>
        
        <!-- Se√ß√£o 2: Header/Footer -->
        <div style="margin-bottom: 2rem;">
          <h3 style="margin-bottom: 1rem; font-size: 1.125rem; font-weight: 600; color: #2563eb;">üìÑ Cabe√ßalho e Rodap√©</h3>
          
          <!-- Header Toggle -->
          <div class="inspector-field">
            <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
              <input type="checkbox" id="headerEnabled" ${documentHeader?.enabled ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
              <span>Ativar Cabe√ßalho</span>
            </label>
            <div class="smallNote">Quando ativado, uma √°rea de cabe√ßalho aparecer√° no topo do canvas. Arraste elementos para dentro dela.</div>
          </div>
          
          <div id="headerOptions" style="${documentHeader?.enabled ? '' : 'display: none;'}">
            <div class="inspector-field">
              <label class="smallNote">Altura Estimada (px)</label>
              <input type="number" id="headerHeight" value="${documentHeader?.height || 60}" min="20" max="200">
              <div class="smallNote">Usado para calcular as margens da p√°gina automaticamente</div>
            </div>
            <div class="inspector-field">
              <div class="smallNote" style="padding: 0.75rem; background: #dbeafe; border-left: 3px solid #2563eb; margin-bottom: 1rem; border-radius: 0.25rem; color: #1e40af;">
                <strong>üí° Dica:</strong> Arraste um elemento de texto para o cabe√ßalho e use <code>{{pageNumber}}</code> para n√∫mero da p√°gina atual e <code>{{totalPages}}</code> para total de p√°ginas. Exemplo: "P√°gina {{pageNumber}} de {{totalPages}}"
              </div>
            </div>
            <div class="inspector-field">
              <button type="button" onclick="clearHeader()" style="width: 100%; padding: 0.75rem; background: #ef4444; color: white; border: none; border-radius: 0.375rem; cursor: pointer;">
                üóëÔ∏è Limpar Cabe√ßalho
              </button>
            </div>
          </div>
          
          <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid #e5e7eb;">
            <!-- Footer Toggle -->
            <div class="inspector-field">
              <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
                <input type="checkbox" id="footerEnabled" ${documentFooter?.enabled ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
                <span>Ativar Rodap√©</span>
              </label>
              <div class="smallNote">Quando ativado, uma √°rea de rodap√© aparecer√° na parte inferior do canvas. Arraste elementos para dentro dela.</div>
            </div>
            
            <div id="footerOptions" style="${documentFooter?.enabled ? '' : 'display: none;'}">
              <div class="inspector-field">
                <label class="smallNote">Altura Estimada (px)</label>
                <input type="number" id="footerHeight" value="${documentFooter?.height || 60}" min="20" max="200">
                <div class="smallNote">Usado para calcular as margens da p√°gina automaticamente</div>
              </div>
              <div class="inspector-field">
                <div class="smallNote" style="padding: 0.75rem; background: #dbeafe; border-left: 3px solid #2563eb; margin-bottom: 1rem; border-radius: 0.25rem; color: #1e40af;">
                  <strong>üí° Dica:</strong> Arraste um elemento de texto para o rodap√© e use <code>{{pageNumber}}</code> para n√∫mero da p√°gina atual e <code>{{totalPages}}</code> para total de p√°ginas. Exemplo: "P√°gina {{pageNumber}} de {{totalPages}}"
                </div>
              </div>
              <div class="inspector-field">
                <button type="button" onclick="clearFooter()" style="width: 100%; padding: 0.75rem; background: #ef4444; color: white; border: none; border-radius: 0.375rem; cursor: pointer;">
                  üóëÔ∏è Limpar Rodap√©
                </button>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Separador -->
        <div style="margin: 2rem 0; border-top: 1px solid #e5e7eb;"></div>
        
        <!-- Se√ß√£o 3: Watermark -->
        <div>
          <h3 style="margin-bottom: 1rem; font-size: 1.125rem; font-weight: 600; color: #2563eb;">üíß Marca d'√Ågua (Watermark)</h3>
          <div class="inspector-field">
            <label>Texto da Marca d'√Ågua</label>
            <input type="text" id="watermarkText" value="${escapeHtml(documentWatermark?.text || '')}" placeholder="Ex: CONFIDENCIAL">
            <div class="smallNote">Deixe vazio para desabilitar a marca d'√°gua</div>
          </div>
          <div class="inspector-field">
            <div class="row">
              <div>
                <label class="smallNote">Tamanho da Fonte</label>
                <input type="number" id="watermarkFontSize" value="${documentWatermark?.fontSize || 48}" min="12" max="200">
              </div>
              <div>
                <label class="smallNote">Cor</label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <input type="color" id="watermarkColor" value="${documentWatermark?.color || '#cccccc'}" style="width: 50px; height: 32px; cursor: pointer;">
                  <input type="text" id="watermarkColorText" value="${documentWatermark?.color || '#cccccc'}" placeholder="#cccccc" style="flex: 1; font-size: 0.875rem;">
                </div>
              </div>
            </div>
          </div>
          <div class="inspector-field">
            <div class="row">
              <div>
                <label class="smallNote">Opacidade (0.0 - 1.0)</label>
                <input type="number" id="watermarkOpacity" value="${documentWatermark?.opacity || 0.3}" min="0" max="1" step="0.1">
              </div>
              <div>
                <label class="smallNote">√Çngulo (graus)</label>
                <input type="number" id="watermarkAngle" value="${documentWatermark?.angle || -45}" min="-180" max="180" step="1">
              </div>
            </div>
          </div>
          <div class="inspector-field">
            <button type="button" onclick="clearWatermark()" style="width: 100%; padding: 0.75rem; background: #ef4444; color: white; border: none; border-radius: 0.375rem; cursor: pointer;">
              üóëÔ∏è Remover Marca d'√Ågua
            </button>
          </div>
        </div>
        
        <!-- Separador -->
        <div style="margin: 2rem 0; border-top: 1px solid #e5e7eb;"></div>
        
        <!-- Se√ß√£o 4: Security -->
        <div>
          <h3 style="margin-bottom: 1rem; font-size: 1.125rem; font-weight: 600; color: #2563eb;">üîí Seguran√ßa do PDF</h3>
          <div class="inspector-field">
            <label><input type="checkbox" id="securityEnabled" ${documentSecurity?.enabled ? 'checked' : ''}> Habilitar Prote√ß√£o por Senha</label>
            <div class="smallNote">Adicione senhas e permiss√µes para proteger o PDF</div>
          </div>
          <div id="securityOptions" style="${documentSecurity?.enabled ? '' : 'display: none;'}">
            <div class="inspector-field">
              <label>Senha do Usu√°rio</label>
              <input type="password" id="securityUserPassword" value="${escapeHtml(documentSecurity?.userPassword || '')}" placeholder="Senha para abrir o PDF">
              <div class="smallNote">Senha necess√°ria para abrir e visualizar o PDF</div>
            </div>
            <div class="inspector-field">
              <label>Senha do Propriet√°rio</label>
              <input type="password" id="securityOwnerPassword" value="${escapeHtml(documentSecurity?.ownerPassword || '')}" placeholder="Senha para modificar permiss√µes">
              <div class="smallNote">Senha para modificar permiss√µes (deixe vazio para usar a mesma senha do usu√°rio)</div>
            </div>
            <div class="inspector-field">
              <label style="margin-bottom: 0.75rem; display: block; font-weight: 500;">Permiss√µes</label>
              <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                <label><input type="checkbox" id="securityPrinting" ${documentSecurity?.permissions?.printing !== false ? 'checked' : ''}> Permitir Impress√£o</label>
                <label><input type="checkbox" id="securityModifying" ${documentSecurity?.permissions?.modifying !== false ? 'checked' : ''}> Permitir Modifica√ß√£o</label>
                <label><input type="checkbox" id="securityCopying" ${documentSecurity?.permissions?.copying !== false ? 'checked' : ''}> Permitir C√≥pia</label>
                <label><input type="checkbox" id="securityAnnotating" ${documentSecurity?.permissions?.annotating !== false ? 'checked' : ''}> Permitir Anota√ß√µes</label>
              </div>
            </div>
            <div class="inspector-field">
              <div class="smallNote" style="padding: 0.75rem; background: #fef3c7; border-left: 3px solid #f59e0b; margin-bottom: 1rem; border-radius: 0.25rem; color: #92400e;">
                <strong>‚ö†Ô∏è Aviso:</strong> As senhas n√£o podem ser recuperadas. Certifique-se de guard√°-las em local seguro.
              </div>
            </div>
          </div>
        </div>
        
        <!-- Separador -->
        <div style="margin: 2rem 0; border-top: 1px solid #e5e7eb;"></div>
        
        <!-- Se√ß√£o 5: Metadados e Compress√£o -->
        <div>
          <h3 style="margin-bottom: 1rem; font-size: 1.125rem; font-weight: 600; color: #2563eb;">üìã Metadados do PDF</h3>
          <div class="inspector-field">
            <label>Autor</label>
            <input type="text" id="pageInfoAuthor" value="${escapeHtml(documentPageInfo?.author || '')}" placeholder="Nome do autor">
          </div>
          <div class="inspector-field">
            <label>T√≠tulo</label>
            <input type="text" id="pageInfoTitle" value="${escapeHtml(documentPageInfo?.title || '')}" placeholder="T√≠tulo do documento">
          </div>
          <div class="inspector-field">
            <label>Assunto</label>
            <input type="text" id="pageInfoSubject" value="${escapeHtml(documentPageInfo?.subject || '')}" placeholder="Assunto do documento">
          </div>
          <div class="inspector-field">
            <label>Palavras-chave</label>
            <input type="text" id="pageInfoKeywords" value="${escapeHtml(documentPageInfo?.keywords || '')}" placeholder="palavra1, palavra2, palavra3">
            <div class="smallNote">Separe m√∫ltiplas palavras-chave com v√≠rgulas</div>
          </div>
          
          <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid #e5e7eb;">
            <h4 style="margin-bottom: 0.75rem; font-size: 1rem; font-weight: 500; color: #374151;">Compress√£o</h4>
            <div class="inspector-field">
              <label><input type="checkbox" id="pageCompress" ${documentCompress ? 'checked' : ''}> Comprimir PDF</label>
              <div class="smallNote">Reduz o tamanho do arquivo PDF gerado (pode aumentar o tempo de gera√ß√£o)</div>
            </div>
          </div>
        </div>
      `;
      
      // Attach todos os listeners
      attachTOCListeners();
      attachHeaderFooterListeners();
      attachWatermarkListeners();
      attachSecurityListeners();
      attachPageInfoListeners();
    }
    
    // Attach listeners para TOC
    function attachTOCListeners() {
      const tocEnabled = document.getElementById('tocEnabled');
      const tocTitle = document.getElementById('tocTitle');
      const tocOptions = document.getElementById('tocOptions');
      
      if (tocEnabled) {
        tocEnabled.addEventListener('change', () => {
          if (!documentTOC) documentTOC = {};
          documentTOC.enabled = tocEnabled.checked;
          if (tocOptions) tocOptions.style.display = documentTOC.enabled ? '' : 'none';
          updateCode();
        });
      }
      
      if (tocTitle) {
        tocTitle.addEventListener('input', () => {
          if (!documentTOC) documentTOC = {};
          documentTOC.title = tocTitle.value.trim() || '√çndice';
          updateCode();
        });
      }
    }
    
    // Attach listeners para Watermark (apenas texto)
    function attachWatermarkListeners() {
      const watermarkText = document.getElementById('watermarkText');
      const watermarkFontSize = document.getElementById('watermarkFontSize');
      const watermarkColor = document.getElementById('watermarkColor');
      const watermarkColorText = document.getElementById('watermarkColorText');
      const watermarkOpacity = document.getElementById('watermarkOpacity');
      const watermarkAngle = document.getElementById('watermarkAngle');
      
      if (watermarkText) {
        watermarkText.addEventListener('input', () => {
          const text = watermarkText.value.trim();
          if (text) {
            if (!documentWatermark) documentWatermark = {};
            documentWatermark.text = text;
        } else {
            documentWatermark = null;
          }
          updateCode();
        });
      }
      
      if (watermarkFontSize) {
        watermarkFontSize.addEventListener('input', () => {
          if (!documentWatermark) documentWatermark = {};
          documentWatermark.fontSize = parseInt(watermarkFontSize.value) || 48;
          updateCode();
        });
      }
      
      if (watermarkColor && watermarkColorText) {
        watermarkColor.addEventListener('input', () => {
          watermarkColorText.value = watermarkColor.value;
          if (!documentWatermark) documentWatermark = {};
          documentWatermark.color = watermarkColor.value;
          updateCode();
        });
        watermarkColorText.addEventListener('input', () => {
          if (/^#[0-9A-F]{6}$/i.test(watermarkColorText.value)) {
            watermarkColor.value = watermarkColorText.value;
            if (!documentWatermark) documentWatermark = {};
            documentWatermark.color = watermarkColorText.value;
            updateCode();
          }
        });
      }
      
      if (watermarkOpacity) {
        watermarkOpacity.addEventListener('input', () => {
          if (!documentWatermark) documentWatermark = {};
          documentWatermark.opacity = parseFloat(watermarkOpacity.value) || 0.3;
          updateCode();
        });
      }
      
      if (watermarkAngle) {
        watermarkAngle.addEventListener('input', () => {
          if (!documentWatermark) documentWatermark = {};
          documentWatermark.angle = parseInt(watermarkAngle.value) || -45;
          updateCode();
        });
      }
    }
    
    function clearWatermark() {
      documentWatermark = null;
      renderPageInspector();
      updateCode();
    }
    window.clearWatermark = clearWatermark;
    
    // Attach listeners para Security
    function attachSecurityListeners() {
      const securityEnabled = document.getElementById('securityEnabled');
      const securityUserPassword = document.getElementById('securityUserPassword');
      const securityOwnerPassword = document.getElementById('securityOwnerPassword');
      const securityPrinting = document.getElementById('securityPrinting');
      const securityModifying = document.getElementById('securityModifying');
      const securityCopying = document.getElementById('securityCopying');
      const securityAnnotating = document.getElementById('securityAnnotating');
      const securityOptions = document.getElementById('securityOptions');
      
      if (securityEnabled) {
        securityEnabled.addEventListener('change', () => {
          if (!documentSecurity) documentSecurity = {};
          documentSecurity.enabled = securityEnabled.checked;
          if (securityOptions) securityOptions.style.display = documentSecurity.enabled ? '' : 'none';
          if (!documentSecurity.enabled) documentSecurity = null;
          updateCode();
        });
      }
      
      if (securityUserPassword) {
        securityUserPassword.addEventListener('input', () => {
          if (!documentSecurity) documentSecurity = {};
          documentSecurity.userPassword = securityUserPassword.value;
          if (!documentSecurity.userPassword && !documentSecurity.ownerPassword) documentSecurity = null;
          updateCode();
        });
      }
      
      if (securityOwnerPassword) {
        securityOwnerPassword.addEventListener('input', () => {
          if (!documentSecurity) documentSecurity = {};
          documentSecurity.ownerPassword = securityOwnerPassword.value;
          updateCode();
        });
      }
      
      if (securityPrinting) {
        securityPrinting.addEventListener('change', () => {
          if (!documentSecurity) documentSecurity = {};
          if (!documentSecurity.permissions) documentSecurity.permissions = {};
          documentSecurity.permissions.printing = securityPrinting.checked;
          updateCode();
        });
      }
      
      if (securityModifying) {
        securityModifying.addEventListener('change', () => {
          if (!documentSecurity) documentSecurity = {};
          if (!documentSecurity.permissions) documentSecurity.permissions = {};
          documentSecurity.permissions.modifying = securityModifying.checked;
          updateCode();
        });
      }
      
      if (securityCopying) {
        securityCopying.addEventListener('change', () => {
          if (!documentSecurity) documentSecurity = {};
          if (!documentSecurity.permissions) documentSecurity.permissions = {};
          documentSecurity.permissions.copying = securityCopying.checked;
          updateCode();
        });
      }
      
      if (securityAnnotating) {
        securityAnnotating.addEventListener('change', () => {
          if (!documentSecurity) documentSecurity = {};
          if (!documentSecurity.permissions) documentSecurity.permissions = {};
          documentSecurity.permissions.annotating = securityAnnotating.checked;
          updateCode();
        });
      }
    }
    
    // Attach listeners para Page Info (Metadados) e Compress
    function attachPageInfoListeners() {
      const pageInfoAuthor = document.getElementById('pageInfoAuthor');
      const pageInfoTitle = document.getElementById('pageInfoTitle');
      const pageInfoSubject = document.getElementById('pageInfoSubject');
      const pageInfoKeywords = document.getElementById('pageInfoKeywords');
      const pageCompress = document.getElementById('pageCompress');
      
      if (pageInfoAuthor) {
        pageInfoAuthor.addEventListener('input', () => {
          if (!documentPageInfo) documentPageInfo = {};
          documentPageInfo.author = pageInfoAuthor.value.trim();
          if (!documentPageInfo.author && !documentPageInfo.title && !documentPageInfo.subject && !documentPageInfo.keywords) {
            documentPageInfo = null;
          }
          updateCode();
        });
      }
      
      if (pageInfoTitle) {
        pageInfoTitle.addEventListener('input', () => {
          if (!documentPageInfo) documentPageInfo = {};
          documentPageInfo.title = pageInfoTitle.value.trim();
          if (!documentPageInfo.author && !documentPageInfo.title && !documentPageInfo.subject && !documentPageInfo.keywords) {
            documentPageInfo = null;
          }
          updateCode();
        });
      }
      
      if (pageInfoSubject) {
        pageInfoSubject.addEventListener('input', () => {
          if (!documentPageInfo) documentPageInfo = {};
          documentPageInfo.subject = pageInfoSubject.value.trim();
          if (!documentPageInfo.author && !documentPageInfo.title && !documentPageInfo.subject && !documentPageInfo.keywords) {
            documentPageInfo = null;
          }
          updateCode();
        });
      }
      
      if (pageInfoKeywords) {
        pageInfoKeywords.addEventListener('input', () => {
          if (!documentPageInfo) documentPageInfo = {};
          documentPageInfo.keywords = pageInfoKeywords.value.trim();
          if (!documentPageInfo.author && !documentPageInfo.title && !documentPageInfo.subject && !documentPageInfo.keywords) {
            documentPageInfo = null;
          }
          updateCode();
        });
      }
      
      if (pageCompress) {
        pageCompress.addEventListener('change', () => {
          documentCompress = pageCompress.checked;
          updateCode();
        });
      }
    }
    
    // Fun√ß√£o antiga mantida para compatibilidade (n√£o ser√° mais usada)
    function renderHeaderFooterInspector() {
      const inspector = document.getElementById('headerFooterInspector');
      if (!inspector) return;
      
      inspector.innerHTML = `
        <h3 style="margin-bottom: 1rem; font-size: 1.125rem; font-weight: 600; color: #111827;">Cabe√ßalho da P√°gina</h3>
        <div class="inspector-field">
          <label>Texto do Cabe√ßalho</label>
          <textarea id="headerText" placeholder="Ex: T√≠tulo do Documento ou deixe vazio para desabilitar" style="min-height: 60px;">${escapeHtml(documentHeader?.text || '')}</textarea>
          <div class="smallNote">Use {{pageNumber}} para n√∫mero da p√°gina atual e {{totalPages}} para total de p√°ginas</div>
              </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Tamanho da Fonte</label>
              <input type="number" id="headerFontSize" value="${documentHeader?.fontSize || 10}" min="6" max="24">
            </div>
            <div>
              <label class="smallNote">Alinhamento</label>
              <select id="headerAlignment">
                <option value="left" ${documentHeader?.alignment === 'left' ? 'selected' : ''}>Esquerda</option>
                <option value="center" ${documentHeader?.alignment === 'center' || !documentHeader ? 'selected' : ''}>Centro</option>
                <option value="right" ${documentHeader?.alignment === 'right' ? 'selected' : ''}>Direita</option>
              </select>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Cor do Texto</label>
          <div style="display: flex; gap: 0.5rem; align-items: center;">
            <input type="color" id="headerColor" value="${documentHeader?.color || '#000000'}" style="width: 60px; height: 38px; cursor: pointer;">
            <input type="text" id="headerColorText" value="${documentHeader?.color || '#000000'}" placeholder="#000000" style="flex: 1;">
          </div>
        </div>
        
        <div style="margin-top: 2rem; padding-top: 1.5rem; border-top: 1px solid #e5e7eb;">
          <h3 style="margin-bottom: 1rem; font-size: 1.125rem; font-weight: 600; color: #111827;">Rodap√© da P√°gina</h3>
          <div class="inspector-field">
            <label>Texto do Rodap√©</label>
            <textarea id="footerText" placeholder="Ex: P√°gina {{pageNumber}} de {{totalPages}} ou deixe vazio para desabilitar" style="min-height: 60px;">${escapeHtml(documentFooter?.text || '')}</textarea>
            <div class="smallNote">Use {{pageNumber}} para n√∫mero da p√°gina atual e {{totalPages}} para total de p√°ginas</div>
          </div>
          <div class="inspector-field">
            <div class="row">
              <div>
                <label class="smallNote">Tamanho da Fonte</label>
                <input type="number" id="footerFontSize" value="${documentFooter?.fontSize || 10}" min="6" max="24">
              </div>
              <div>
                <label class="smallNote">Alinhamento</label>
                <select id="footerAlignment">
                  <option value="left" ${documentFooter?.alignment === 'left' ? 'selected' : ''}>Esquerda</option>
                  <option value="center" ${documentFooter?.alignment === 'center' || !documentFooter ? 'selected' : ''}>Centro</option>
                  <option value="right" ${documentFooter?.alignment === 'right' ? 'selected' : ''}>Direita</option>
                </select>
              </div>
            </div>
          </div>
          <div class="inspector-field">
            <label class="smallNote">Cor do Texto</label>
            <div style="display: flex; gap: 0.5rem; align-items: center;">
              <input type="color" id="footerColor" value="${documentFooter?.color || '#000000'}" style="width: 60px; height: 38px; cursor: pointer;">
              <input type="text" id="footerColorText" value="${documentFooter?.color || '#000000'}" placeholder="#000000" style="flex: 1;">
            </div>
              </div>
            </div>
          `;
      
      // Attach listeners ap√≥s renderizar
      attachHeaderFooterListeners();
    }
    
    // Attach listeners para Header/Footer
    function attachHeaderFooterListeners() {
      // Header Toggle
      const headerEnabled = document.getElementById('headerEnabled');
      const headerHeight = document.getElementById('headerHeight');
      const headerOptions = document.getElementById('headerOptions');
      
      if (headerEnabled) {
        headerEnabled.addEventListener('change', () => {
          documentHeader.enabled = headerEnabled.checked;
          if (!documentHeader.root) {
            documentHeader.root = createHeaderFooterRoot();
          }
          if (headerOptions) {
            headerOptions.style.display = documentHeader.enabled ? '' : 'none';
          }
          adjustPageMargins();
          renderAll();
          saveState();
        });
      }
      
      if (headerHeight) {
        headerHeight.addEventListener('input', () => {
          documentHeader.height = parseInt(headerHeight.value) || 60;
          adjustPageMargins();
          updateCode();
        });
      }
      
      // Footer Toggle
      const footerEnabled = document.getElementById('footerEnabled');
      const footerHeight = document.getElementById('footerHeight');
      const footerOptions = document.getElementById('footerOptions');
      
      if (footerEnabled) {
        footerEnabled.addEventListener('change', () => {
          documentFooter.enabled = footerEnabled.checked;
          if (!documentFooter.root) {
            documentFooter.root = createHeaderFooterRoot();
          }
          if (footerOptions) {
            footerOptions.style.display = documentFooter.enabled ? '' : 'none';
          }
          adjustPageMargins();
          renderAll();
          saveState();
        });
      }
      
      if (footerHeight) {
        footerHeight.addEventListener('input', () => {
          documentFooter.height = parseInt(footerHeight.value) || 60;
          adjustPageMargins();
          updateCode();
        });
      }
    }
    
    // Fun√ß√µes para limpar header/footer
    function clearHeader() {
      showConfirmModal(
        'Limpar Cabe√ßalho',
        'Tem certeza que deseja limpar todo o conte√∫do do cabe√ßalho?',
        () => {
          documentHeader.root = createHeaderFooterRoot();
          renderAll();
          saveState();
        }
      );
    }
    window.clearHeader = clearHeader;
    
    function clearFooter() {
      showConfirmModal(
        'Limpar Rodap√©',
        'Tem certeza que deseja limpar todo o conte√∫do do rodap√©?',
        () => {
          documentFooter.root = createHeaderFooterRoot();
          renderAll();
          saveState();
        }
      );
    }
    window.clearFooter = clearFooter;
    
    // Ajustar pageMargins baseado na altura do header/footer
    function adjustPageMargins() {
      const minTopMargin = documentHeader.enabled ? documentHeader.height + 20 : 60;
      const minBottomMargin = documentFooter.enabled ? documentFooter.height + 20 : 60;
      
      // Ajustar apenas se necess√°rio
      if (pageMargins[1] < minTopMargin) {
        pageMargins[1] = minTopMargin;
        if (mT) mT.value = minTopMargin;
      }
      if (pageMargins[3] < minBottomMargin) {
        pageMargins[3] = minBottomMargin;
        if (mB) mB.value = minBottomMargin;
      }
    }
    window.switchTab = switchTab;

    // -----------------------
    // UI bindings
    // -----------------------
    function renderAll() {
      // mant√©m selected id v√°lido
      if (selectedElementId && !findNodeById(selectedElementId)) {
        selectedElementId = getRootGroup() ? getRootGroup().id : null;
      }
      renderCanvas();
      renderInspector();
      updateCode();
      // Salvar estado automaticamente ap√≥s renderizar
      saveState();
    }

    function clearAll() {
      // Limpar elementos principais
      elements = [];
      selectedElementId = null;
      
      // Limpar header/footer
      if (documentHeader.root) {
        documentHeader.root.properties.children = [];
      }
      if (documentFooter.root) {
        documentFooter.root.properties.children = [];
      }
      documentHeader.enabled = false;
      documentFooter.enabled = false;
      
      // Limpar estado salvo tamb√©m
      clearSavedState();
      
      // Atualizar UI
      if (pageSizeSel) pageSizeSel.value = 'A4';
      if (orientationSel) orientationSel.value = 'portrait';
      if (mL) mL.value = 40;
      if (mT) mT.value = 60;
      if (mR) mR.value = 40;
      if (mB) mB.value = 60;
      pageSize = 'A4';
      orientation = 'portrait';
      pageMargins = [40, 60, 40, 60];
      
      renderAll();
    }

    // Page settings binds
    pageSizeSel.addEventListener('change', () => { pageSize = pageSizeSel.value; renderAll(); });
    orientationSel.addEventListener('change', () => { orientation = orientationSel.value; renderAll(); });

    function updateMargins() {
      pageMargins = [
        Number(mL.value || 0),
        Number(mT.value || 0),
        Number(mR.value || 0),
        Number(mB.value || 0),
      ];
      renderAll();
    }
    [mL, mT, mR, mB].forEach(inp => inp.addEventListener('input', updateMargins));

    // zoom
    zoomRange.addEventListener('input', () => {
      const val = Number(zoomRange.value || 100);
      zoomLabel.textContent = val + '%';
      zoom = val / 100;
      applyZoom();
    });

    previewBtn.addEventListener('click', () => {
      const dd = buildDocDefinition();
      const pdfDoc = pdfMake.createPdf(dd);
      
      // Gerar PDF como blob e exibir no modal
      pdfDoc.getBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const previewModal = document.getElementById('previewModal');
        const previewIframe = document.getElementById('previewIframe');
        
        if (previewIframe) {
          previewIframe.src = url;
        }
        
        if (previewModal) {
          previewModal.classList.add('active');
        }
      });
    });
    
    function getCodToSend() {
        return codeEditor.textContent || '';
    }       

    function sendCod() {
        const cod = getCodToSend();
        frame.contentWindow.postMessage({ type: "SET_COD", cod }, BUBBLE_ORIGIN);
    }

    // Bot√£o Teste Bubble
    bubbleTestBtn.addEventListener('click', () => {
      const bubbleModal = document.getElementById('bubbleTestModal');
      const bubbleIframe = document.getElementById('bubbleTestIframe');
      
      if (bubbleIframe) {
        bubbleIframe.src = BUBBLE_ORIGIN + '/version-test/preview_pdf';
      }
      
      if (bubbleModal) {
        bubbleModal.classList.add('active');
      }
    });

    clearBtn.addEventListener('click', () => {
      clearAll();
    });

    // copy in code tab
    if (copyBtn) copyBtn.addEventListener('click', copyCode);

    // Canvas click to deselect
    canvas.addEventListener('click', (e) => {
      if (e.target === canvas || e.target === elementsList || e.target === canvasEmpty) {
        const rootGroup = getRootGroup();
        const newSelectedId = rootGroup ? rootGroup.id : null;
        
        // Evitar re-renderiza√ß√£o desnecess√°ria se j√° est√° selecionado
        if (selectedElementId === newSelectedId) {
          return;
        }
        
        selectedElementId = newSelectedId;
        renderAll();
      }
    });

    // init
    function closeModal(){ const m=document.getElementById('modal'); if(m) m.classList.remove('active'); }
    function openModal(){ const m=document.getElementById('modal'); if(m) m.classList.add('active'); }

    function init() {
      // Tentar carregar estado salvo do localStorage
      const loaded = loadState();
      
      // Se n√£o houver estado salvo, usar defaults
      if (!loaded) {
        pageSizeSel.value = pageSize;
        orientationSel.value = orientation;
        mL.value = pageMargins[0];
        mT.value = pageMargins[1];
        mR.value = pageMargins[2];
        mB.value = pageMargins[3];
        zoomRange.value = 100;
        zoomLabel.textContent = '100%';
        zoom = 1;
      } else {
        // Estado carregado - os valores j√° foram restaurados em loadState()
        // Apenas garantir que os inputs do DOM est√£o sincronizados
        if (pageSizeSel) pageSizeSel.value = pageSize;
        if (orientationSel) orientationSel.value = orientation;
        if (mL) mL.value = pageMargins[0];
        if (mT) mT.value = pageMargins[1];
        if (mR) mR.value = pageMargins[2];
        if (mB) mB.value = pageMargins[3];
        if (zoomRange) {
          zoomRange.value = Math.round(zoom * 100);
          if (zoomLabel) zoomLabel.textContent = Math.round(zoom * 100) + '%';
        }
        
        // Restaurar c√≥digo gerado se existir
        try {
          const savedCode = localStorage.getItem(STORAGE_CODE_KEY);
          if (savedCode && codeEditor) {
            codeEditor.textContent = savedCode;
          }
        } catch (e) {
          console.warn('Erro ao restaurar c√≥digo do localStorage:', e);
        }
        
        // Mostrar mensagem de restaura√ß√£o (opcional - pode ser removido se n√£o quiser)
        console.log('Estado restaurado do localStorage');
      }

      // Renderizar tudo (vai gerar novo c√≥digo se n√£o houver c√≥digo salvo)
      renderAll();
      
      // Aplicar zoom ap√≥s renderizar
    applyZoom();
    }

    init();
    
    // Salvar estado antes de fechar/recarregar a p√°gina
    window.addEventListener('beforeunload', () => {
      saveState();
    });
    
    // Salvar periodicamente (a cada 30 segundos) como backup
    setInterval(() => {
      saveState();
    }, 30000);
  </script>


  <!-- Modal de Confirma√ß√£o -->
  <div id="confirmModal" class="custom-modal">
    <div class="custom-modal-overlay" onclick="closeConfirmModal()"></div>
    <div class="custom-modal-content">
      <div class="custom-modal-header">
        <h3 id="confirmModalTitle">Confirmar a√ß√£o</h3>
      </div>
      <div class="custom-modal-body">
        <p id="confirmModalMessage">Tem certeza que deseja realizar esta a√ß√£o?</p>
      </div>
      <div class="custom-modal-footer">
        <button class="custom-modal-btn custom-modal-btn-cancel" onclick="closeConfirmModal()">Cancelar</button>
        <button class="custom-modal-btn custom-modal-btn-confirm" id="confirmModalOkBtn" onclick="confirmModalAction()">OK</button>
      </div>
    </div>
  </div>

  <!-- Modal de Alerta -->
  <div id="alertModal" class="custom-modal">
    <div class="custom-modal-overlay" onclick="closeAlertModal()"></div>
    <div class="custom-modal-content">
      <div class="custom-modal-header">
        <h3>Aviso</h3>
      </div>
      <div class="custom-modal-body">
        <p id="alertModalMessage">Mensagem de alerta</p>
      </div>
      <div class="custom-modal-footer">
        <button class="custom-modal-btn custom-modal-btn-confirm" onclick="closeAlertModal()" style="width: 100%;">OK</button>
      </div>
    </div>
  </div>

  <!-- Modal de Preview do PDF -->
  <div id="previewModal" class="custom-modal">
    <div class="custom-modal-overlay" onclick="closePreviewModal()"></div>
    <div class="preview-modal-content">
      <div class="preview-modal-header">
        <h3>Pr√©-visualiza√ß√£o do PDF</h3>
        <button class="preview-modal-close" onclick="closePreviewModal()">Fechar</button>
      </div>
      <div class="preview-modal-body">
        <iframe
          id="previewIframe"
          class="preview-modal-iframe"
          frameborder="0"
          style="overflow:hidden;overflow-x:hidden;overflow-y:hidden;height:100%;width:100%;position:absolute;top:0px;left:0px;right:0px;bottom:0px"
          height="100%"
          width="100%">
        </iframe>
      </div>
    </div>
  </div>

  <div id="bubbleTestModal" class="custom-modal">
    <div class="custom-modal-overlay" onclick="closeBubbleTestModal()"></div>
    <div class="preview-modal-content">
      <div class="preview-modal-header">
        <h3>Teste Bubble</h3>
        <button class="preview-modal-close" onclick="closeBubbleTestModal()">Fechar</button>
      </div>
      <div class="preview-modal-body">
        <iframe
          id="bubbleTestIframe"
          class="preview-modal-iframe"
          frameborder="0"
          style="overflow:hidden;overflow-x:hidden;overflow-y:hidden;height:100%;width:100%;position:absolute;top:0px;left:0px;right:0px;bottom:0px"
          height="100%"
          width="100%">
        </iframe>
      </div>
    </div>
  </div>
</body>
</html>
