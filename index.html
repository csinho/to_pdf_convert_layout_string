<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lab PDF - Editor visual</title>
  <link rel="icon" type="image/svg+xml"
    href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20viewBox%3D%22275%20140%20520%20895%22%20width%3D%2220%22%20height%3D%2220%22%20style%3D%22display%3A%20block%3B%22%20preserveAspectRatio%3D%22xMidYMid%20meet%22%3E%3Cpath%20fill%3D%22%23FAFCFD%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M429.856%20175.351C418.007%20175.432%20404.43%20175.416%20404.944%20159.07C405.484%20141.893%20422.09%20143.81%20434.299%20143.762L462.99%20143.652L517.68%20143.603C528.367%20143.614%20547.719%20142.342%20558.044%20145.905C562.78%20147.539%20567.098%20156.604%20566.161%20161.238C564.544%20176.41%20551.928%20175.61%20540.846%20175.464L541.071%20289.871L541.09%20290.79L541.599%20298.698C549.781%20334.269%20571.643%20334.734%20597.759%20353.88C637.448%20382.975%20665.192%20425.553%20675.654%20473.704C683.657%20509.401%20681.974%20551.694%20668.473%20585.908C664.923%20598.03%20655.577%20615.556%20648.725%20626.174C621.109%20668.968%20578.565%20700.686%20528.825%20711.995C478.018%20723.695%20424.641%20714.421%20380.757%20686.27C296.788%20633.389%20268.514%20522.834%20308.574%20433.819C311.231%20427.916%20314.317%20421.553%20317.763%20416.086C319.912%20411.662%20324.518%20405.023%20327.473%20400.914C343.217%20379.026%20362.794%20359.841%20385.829%20345.722C395.491%20339.381%20406.668%20336.056%20414.968%20327.799C431.373%20311.478%20429.417%20292.631%20429.542%20271.735C429.73%20257.414%20429.794%20243.092%20429.735%20228.77C429.696%20211.184%20429.304%20192.853%20429.856%20175.351Z%22%2F%3E%3Cdefs%3E%3ClinearGradient%20id%3D%22gradient_0%22%20gradientUnits%3D%22userSpaceOnUse%22%20x1%3D%22489.79175%22%20y1%3D%22506.99503%22%20x2%3D%22566.86169%22%20y2%3D%22280.49115%22%3E%3Cstop%20offset%3D%220%22%20stop-color%3D%22%23217597%22%2F%3E%3Cstop%20offset%3D%221%22%20stop-color%3D%22%232ECAC1%22%2F%3E%3C%2FlinearGradient%3E%3C%2Fdefs%3E%3Cpath%20fill%3D%22url%28%23gradient_0%29%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M429.856%20175.351C418.007%20175.432%20404.43%20175.416%20404.944%20159.07C405.484%20141.893%20422.09%20143.81%20434.299%20143.762L462.99%20143.652L517.68%20143.603C528.367%20143.614%20547.719%20142.342%20558.044%20145.905C562.78%20147.539%20567.098%20156.604%20566.161%20161.238C564.544%20176.41%20551.928%20175.61%20540.846%20175.464L541.071%20289.871L541.09%20290.79L541.599%20298.698C549.781%20334.269%20571.643%20334.734%20597.759%20353.88C637.448%20382.975%20665.192%20425.553%20675.654%20473.704C683.657%20509.401%20681.974%20551.694%20668.473%20585.908C667.678%20582.355%20673.475%20567.059%20674.517%20562.468C674.612%20562.301%20674.706%20562.134%20674.8%20561.967C674.419%20559.733%20675.704%20558.58%20675.331%20555.729C668.886%20549.775%20650.631%20564.362%20640.911%20558.524L640.529%20558.389C641.393%20565.132%20638.318%20574.807%20636.216%20581.119L635.876%20580.854C635.808%20578.539%20637.764%20573.599%20638.781%20571.401C636.779%20569.559%20624.561%20570.497%20621.025%20570.576C620.976%20573.539%20621.087%20579.926%20620.303%20582.444C620.193%20585.986%20620.174%20589.53%20620.247%20593.073C613.502%20593.441%20595.173%20593.812%20588.728%20593.123L588.709%20590.808C588.766%20583.669%20588.741%20576.529%20588.634%20569.39C588.302%20566.645%20588.539%20564.098%20588.698%20561.349L588.726%20545.882L588.626%20542.957L588.704%20536.36C587.883%20528.39%20588.405%20513.05%20588.494%20504.625L588.478%20489.501L588.365%20448.866C588.293%20440.366%20587.911%20428.185%20588.583%20419.93C577.994%20408.398%20566.234%20397.477%20555.248%20386.291C551.774%20382.753%20547.97%20379.115%20544.259%20375.849C529.468%20375.036%20506.392%20375.84%20490.922%20375.852C452.864%20376.05%20414.805%20375.897%20376.749%20375.392C376.66%20386.484%20376.647%20397.577%20376.71%20408.669C375.986%20405.454%20376.646%20401.455%20375.971%20399.077L375.566%20400.928L374.909%20401.105C373.762%20400.122%20373.893%20400.055%20373.456%20398.564C369.087%20399.004%20359.215%20410.786%20356.752%20413.838C353.31%20418.103%20338.846%20442.021%20337.704%20446.541L337.115%20446.674C337.301%20443.544%20339.488%20443.014%20339.333%20440.65C338.251%20440.132%20332.711%20437.554%20332.161%20436.996C326.178%20430.942%20317.403%20425.528%20317.763%20416.086C319.912%20411.662%20324.518%20405.023%20327.473%20400.914C343.217%20379.026%20362.794%20359.841%20385.829%20345.722C395.491%20339.381%20406.668%20336.056%20414.968%20327.799C431.373%20311.478%20429.417%20292.631%20429.542%20271.735C429.73%20257.414%20429.794%20243.092%20429.735%20228.77C429.696%20211.184%20429.304%20192.853%20429.856%20175.351Z%22%2F%3E%3Cdefs%3E%3ClinearGradient%20id%3D%22gradient_1%22%20gradientUnits%3D%22userSpaceOnUse%22%20x1%3D%22458.75131%22%20y1%3D%22272.79367%22%20x2%3D%22499.2218%22%20y2%3D%22129.75377%22%3E%3Cstop%20offset%3D%220%22%20stop-color%3D%22%232CC3BF%22%2F%3E%3Cstop%20offset%3D%221%22%20stop-color%3D%22%2330F1D6%22%2F%3E%3C%2FlinearGradient%3E%3C%2Fdefs%3E%3Cpath%20fill%3D%22url%28%23gradient_1%29%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M429.856%20175.351C418.007%20175.432%20404.43%20175.416%20404.944%20159.07C405.484%20141.893%20422.09%20143.81%20434.299%20143.762L462.99%20143.652L517.68%20143.603C528.367%20143.614%20547.719%20142.342%20558.044%20145.905C562.78%20147.539%20567.098%20156.604%20566.161%20161.238C564.544%20176.41%20551.928%20175.61%20540.846%20175.464L541.071%20289.871L540.803%20290.55C539.464%20291.332%20537.557%20293.551%20536.374%20294.753L535.573%20294.666C533.261%20285.471%20525.132%20293.801%20519.855%20285.866C519.807%20285.793%20504.567%20284.439%20504.049%20278.043C503.277%20278.664%20503.625%20278.345%20503.343%20279.705C502.163%20280.053%20497.126%20277.134%20495.599%20276.454C486.748%20272.508%20477.392%20272.316%20468.959%20267.098C463.583%20263.771%20460.534%20258.462%20455.54%20255.211C448.421%20250.577%20439.35%20248.487%20433.779%20241.464C430.145%20237.092%20432.025%20232.523%20429.735%20228.77C429.696%20211.184%20429.304%20192.853%20429.856%20175.351Z%22%2F%3E%3Cpath%20fill%3D%22%2349C3D2%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M588.583%20419.93C589.106%20428.132%20588.684%20439.182%20588.741%20447.631C598.691%20447.591%20610.294%20447.288%20620.128%20447.559C620.16%20455.664%20620.15%20463.769%20620.1%20471.874C625.738%20471.841%20636.634%20471.029%20641.168%20472.709C642.428%20474.046%20642.028%20473.732%20642.301%20475.988C642.353%20478.666%20642.272%20494.08%20643.046%20495.345L643.956%20495.557C644.899%20495.78%20645.164%20495.848%20646.063%20496.272C646.162%20497.567%20646.347%20497.02%20645.831%20498.049C645.105%20498.247%20643.052%20498.633%20642.953%20499.072C642.038%20503.134%20642.235%20515.473%20642.405%20519.485C645.008%20519.763%20644.758%20519.322%20646.433%20520.707C645.749%20522.605%20644.315%20522.338%20642.471%20522.429C642.423%20525.807%20641.79%20540.944%20643.059%20542.754L644.043%20542.985C645.483%20543.74%20645.596%20543.48%20646.161%20544.662C644.277%20546.446%20642.594%20545.533%20642.369%20548.189C642.122%20551.097%20643.246%20556.333%20640.911%20558.524L640.529%20558.389C641.393%20565.132%20638.318%20574.807%20636.216%20581.119L635.876%20580.854C635.808%20578.539%20637.764%20573.599%20638.781%20571.401C636.779%20569.559%20624.561%20570.497%20621.025%20570.576C620.976%20573.539%20621.087%20579.926%20620.303%20582.444C620.193%20585.986%20620.174%20589.53%20620.247%20593.073C613.502%20593.441%20595.173%20593.812%20588.728%20593.123L588.709%20590.808C588.766%20583.669%20588.741%20576.529%20588.634%20569.39C588.302%20566.645%20588.539%20564.098%20588.698%20561.349L588.726%20545.882L588.626%20542.957L588.704%20536.36C587.883%20528.39%20588.405%20513.05%20588.494%20504.625L588.478%20489.501L588.365%20448.866C588.293%20440.366%20587.911%20428.185%20588.583%20419.93Z%22%2F%3E%3Cdefs%3E%3ClinearGradient%20id%3D%22gradient_2%22%20gradientUnits%3D%22userSpaceOnUse%22%20x1%3D%22628.013%22%20y1%3D%22485.62463%22%20x2%3D%22591.10583%22%20y2%3D%22446.87042%22%3E%3Cstop%20offset%3D%220%22%20stop-color%3D%22%2341BCC9%22%2F%3E%3Cstop%20offset%3D%221%22%20stop-color%3D%22%235EDDE0%22%2F%3E%3C%2FlinearGradient%3E%3C%2Fdefs%3E%3Cpath%20fill%3D%22url%28%23gradient_2%29%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M588.583%20419.93C589.106%20428.132%20588.684%20439.182%20588.741%20447.631C598.691%20447.591%20610.294%20447.288%20620.128%20447.559C620.16%20455.664%20620.15%20463.769%20620.1%20471.874C625.738%20471.841%20636.634%20471.029%20641.168%20472.709C642.428%20474.046%20642.028%20473.732%20642.301%20475.988L639.824%20474.401C634.314%20474.938%20625.989%20474.758%20620.223%20474.777C620.211%20481.387%20620.334%20488.481%20620.171%20495.048C618.998%20494.668%20618.819%20494.859%20617.458%20494.995C617.138%20488.542%20617.283%20480.966%20617.265%20474.421C612.291%20473.858%20602.744%20474.157%20597.437%20474.221C597.513%20478.984%20597.693%20483.816%20597.294%20488.557C597.117%20484.13%20597.026%20479.7%20597.02%20475.27L596.257%20475.453C595.795%20479.348%20595.909%20485.766%20595.862%20489.867C595.804%20486.94%20595.863%20476.921%20595.358%20474.739C592.834%20474.468%20591.328%20474.517%20588.836%20474.585C588.84%20479.4%20588.936%20484.606%20588.837%20489.39L588.478%20489.501L588.365%20448.866C588.293%20440.366%20587.911%20428.185%20588.583%20419.93Z%22%2F%3E%3Cpath%20fill%3D%22%232487A1%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M588.799%20450.03C598.307%20450.13%20607.816%20450.182%20617.324%20450.186L617.318%20471.732L597.954%20471.769C598.018%20468.467%20598.368%20454.939%20597.18%20452.839L596.269%20452.752C593.869%20456.002%20596.84%20469.357%20594.716%20471.721C592.633%20471.881%20591.614%20472.116%20589.643%20471.57C588.028%20469.311%20588.813%20453.9%20588.799%20450.03Z%22%2F%3E%3Cpath%20fill%3D%22%2325719C%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M588.634%20569.39L594.985%20569.319C594.986%20573.137%20594.567%20581.3%20596.339%20584.359L596.98%20584.022C598.374%20579.388%20598.066%20574.496%20598.045%20569.652C604.356%20569.641%20610.985%20569.529%20617.268%20569.658L617.352%20590.488C607.566%20590.858%20598.288%20590.547%20588.709%20590.808C588.766%20583.669%20588.741%20576.529%20588.634%20569.39Z%22%2F%3E%3Cpath%20fill%3D%22%2325719C%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M598.02%20498.471L617.416%20498.448C617.367%20502.362%20617.342%20506.276%20617.342%20510.19C617.909%20513.879%20617.562%20519.401%20618.178%20521.997L617.663%20522.355C611.124%20522.396%20604.585%20522.355%20598.047%20522.232L595.118%20522.003C592.954%20522.032%20591.2%20521.739%20589.581%20522.988C587.696%20526.03%20589.001%20531.428%20588.704%20536.36C587.883%20528.39%20588.405%20513.05%20588.494%20504.625L588.848%20504.734C588.926%20509.029%20587.737%20516.279%20589.668%20518.695C591.286%20519.709%20593.371%20519.344%20595.363%20519.272L597.99%20519.417C598.196%20512.758%20598.021%20505.201%20598.02%20498.471Z%22%2F%3E%3Cpath%20fill%3D%22%2349C3D2%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M588.494%20504.625L588.848%20504.734C588.926%20509.029%20587.737%20516.279%20589.668%20518.695C591.286%20519.709%20593.371%20519.344%20595.363%20519.272L597.99%20519.417C601.278%20518.952%20613.285%20519.112%20617.225%20519.084L617.342%20510.19C617.909%20513.879%20617.562%20519.401%20618.178%20521.997L617.663%20522.355C611.124%20522.396%20604.585%20522.355%20598.047%20522.232L595.118%20522.003C592.954%20522.032%20591.2%20521.739%20589.581%20522.988C587.696%20526.03%20589.001%20531.428%20588.704%20536.36C587.883%20528.39%20588.405%20513.05%20588.494%20504.625Z%22%2F%3E%3Cpath%20fill%3D%22%2325719C%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M620.201%20546.105L639.817%20546.098C639.814%20550.038%20639.638%20554.626%20640.529%20558.389C641.393%20565.132%20638.318%20574.807%20636.216%20581.119L635.876%20580.854C635.808%20578.539%20637.764%20573.599%20638.781%20571.401C636.779%20569.559%20624.561%20570.497%20621.025%20570.576C620.976%20573.539%20621.087%20579.926%20620.303%20582.444L620.085%20569.626C624.727%20569.591%20632.736%20569.819%20636.894%20568.463L637.149%20567.835C633.541%20566.22%20624.425%20566.717%20620.154%20566.761C620.123%20559.875%20620.139%20552.99%20620.201%20546.105Z%22%2F%3E%3Cpath%20fill%3D%22%2325719C%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M620.223%20474.777C625.989%20474.758%20634.314%20474.938%20639.824%20474.401L639.691%20495.423C636.741%20495.448%20622.331%20495.777%20620.171%20495.048C620.334%20488.481%20620.211%20481.387%20620.223%20474.777Z%22%2F%3E%3Cpath%20fill%3D%22%2325719C%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M598.047%20522.232C604.585%20522.355%20611.124%20522.396%20617.663%20522.355C616.869%20525.802%20617.253%20538.941%20617.297%20542.959C610.979%20543.071%20604.352%20542.96%20598.009%20542.948L598.047%20522.232Z%22%2F%3E%3Cpath%20fill%3D%22%2325719C%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M598.116%20474.789C603.853%20474.77%20611.731%20474.931%20617.265%20474.421C617.283%20480.966%20617.138%20488.542%20617.458%20494.995C614.444%20495.787%20601.776%20495.238%20598.053%20495.121C598.181%20488.419%20598.106%20481.508%20598.116%20474.789Z%22%2F%3E%3Cpath%20fill%3D%22%2325719C%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M588.726%20545.882C590.783%20545.907%20592.966%20545.981%20595.009%20545.862C595.191%20552.907%20595.211%20559.957%20595.068%20567.003C593.149%20567.105%20590.913%20567.519%20589.375%20566.554C588.533%20565.087%20588.722%20563.115%20588.698%20561.349L588.726%20545.882Z%22%2F%3E%3Cpath%20fill%3D%22%2325719C%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M588.848%20504.734C588.814%20502.721%20588.457%20500.474%20589.578%20498.937C591.194%20498.043%20593.228%20498.225%20595.133%20498.181C595.188%20505.03%20595.118%20512.463%20595.363%20519.272C593.371%20519.344%20591.286%20519.709%20589.668%20518.695C587.737%20516.279%20588.926%20509.029%20588.848%20504.734Z%22%2F%3E%3Cpath%20fill%3D%22%2325719C%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M588.704%20536.36C589.001%20531.428%20587.696%20526.03%20589.581%20522.988C591.2%20521.739%20592.954%20522.032%20595.118%20522.003C595.169%20528.804%20595.363%20536.25%20595.043%20542.984L588.626%20542.957L588.704%20536.36Z%22%2F%3E%3Cpath%20fill%3D%22%2325719C%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M588.836%20474.585C591.328%20474.517%20592.834%20474.468%20595.358%20474.739C594.905%20480.68%20595.17%20489.056%20595.258%20495.172C593.252%20495.289%20591.218%20495.691%20589.544%20494.723C588.493%20493.167%20588.796%20491.333%20588.837%20489.39C588.936%20484.606%20588.84%20479.4%20588.836%20474.585Z%22%2F%3E%3Cpath%20fill%3D%22%2325719C%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M620.193%20498.465L639.71%20498.597C639.894%20505.404%20639.821%20512.45%20639.83%20519.279L620.254%20519.141L620.193%20498.465Z%22%2F%3E%3Cpath%20fill%3D%22%2325719C%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M620.296%20522.429C626.822%20522.327%20633.349%20522.271%20639.875%20522.263C639.927%20529.098%20639.806%20536.074%20639.754%20542.922L620.23%20542.913L620.296%20522.429Z%22%2F%3E%3Cpath%20fill%3D%22%2325719C%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M598.09%20546.075L617.282%20546.047L617.332%20566.747C611.47%20567.026%20604.038%20566.803%20598.062%20566.776L598.09%20546.075Z%22%2F%3E%3Cpath%20fill%3D%22%2325719C%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M642.471%20522.429C644.33%20522.63%20645.349%20522.361%20646.375%20523.382C646.749%20526.899%20646.591%20539.387%20645.185%20542.317L644.043%20542.985L643.059%20542.754C641.79%20540.944%20642.423%20525.807%20642.471%20522.429Z%22%2F%3E%3Cpath%20fill%3D%22%2325719C%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M642.405%20519.485C642.235%20515.473%20642.038%20503.134%20642.953%20499.072C643.052%20498.633%20645.105%20498.247%20645.831%20498.049C645.927%20501.838%20646.949%20516.637%20645.761%20518.847C644.635%20519.082%20643.545%20519.328%20642.405%20519.485Z%22%2F%3E%3Cpath%20fill%3D%22%2357E0E3%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M541.599%20298.698C541.392%20299.306%20541.555%20298.933%20540.971%20299.744C538.929%20297.26%20539.123%20293.191%20541.09%20290.79L541.599%20298.698Z%22%2F%3E%3Cdefs%3E%3ClinearGradient%20id%3D%22gradient_3%22%20gradientUnits%3D%22userSpaceOnUse%22%20x1%3D%22413.8266%22%20y1%3D%22702.08923%22%20x2%3D%22510.21185%22%20y2%3D%22452.74323%22%3E%3Cstop%20offset%3D%220%22%20stop-color%3D%22%2318276F%22%2F%3E%3Cstop%20offset%3D%221%22%20stop-color%3D%22%2323839F%22%2F%3E%3C%2FlinearGradient%3E%3C%2Fdefs%3E%3Cpath%20fill%3D%22url%28%23gradient_3%29%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M317.763%20416.086C317.403%20425.528%20326.178%20430.942%20332.161%20436.996C332.711%20437.554%20338.251%20440.132%20339.333%20440.65C339.488%20443.014%20337.301%20443.544%20337.115%20446.674L337.704%20446.541C338.846%20442.021%20353.31%20418.103%20356.752%20413.838C359.215%20410.786%20369.087%20399.004%20373.456%20398.564C373.893%20400.055%20373.762%20400.122%20374.909%20401.105L375.566%20400.928L375.971%20399.077C376.646%20401.455%20375.986%20405.454%20376.71%20408.669L376.792%20463.801C376.797%20472.991%20377.187%20485.826%20376.733%20494.791C377.619%20521.945%20376.335%20549.646%20376.882%20576.847C376.977%20581.587%20376.994%20586.758%20376.802%20591.492L376.922%20593.504L376.889%20596.278C376.773%20611.238%20376.814%20626.198%20377.014%20641.157C383.338%20641.407%20389.881%20641.245%20396.226%20641.296C460.307%20641.813%20524.589%20640.64%20588.646%20641.319C589.177%20625.439%20588.239%20609.125%20588.728%20593.123C595.173%20593.812%20613.502%20593.441%20620.247%20593.073C620.174%20589.53%20620.193%20585.986%20620.303%20582.444C621.087%20579.926%20620.976%20573.539%20621.025%20570.576C624.561%20570.497%20636.779%20569.559%20638.781%20571.401C637.764%20573.599%20635.808%20578.539%20635.876%20580.854L636.216%20581.119C638.318%20574.807%20641.393%20565.132%20640.529%20558.389L640.911%20558.524C650.631%20564.362%20668.886%20549.775%20675.331%20555.729C675.704%20558.58%20674.419%20559.733%20674.8%20561.967C674.706%20562.134%20674.612%20562.301%20674.517%20562.468C673.475%20567.059%20667.678%20582.355%20668.473%20585.908C664.923%20598.03%20655.577%20615.556%20648.725%20626.174C621.109%20668.968%20578.565%20700.686%20528.825%20711.995C478.018%20723.695%20424.641%20714.421%20380.757%20686.27C296.788%20633.389%20268.514%20522.834%20308.574%20433.819C311.231%20427.916%20314.317%20421.553%20317.763%20416.086Z%22%2F%3E%3Cpath%20fill%3D%22%2349C3D2%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M376.922%20593.504L376.889%20596.278C373.192%20596.309%20353.158%20597.018%20351.001%20595.969L350.807%20595.181C353.653%20593.22%20372.578%20593.588%20376.922%20593.504Z%22%2F%3E%3Cpath%20fill%3D%22%2349C3D2%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M376.596%20497.305C374.239%20497.425%20371.273%20498.052%20369.66%20496.131L370.216%20495.334C372.404%20494.273%20374.243%20494.658%20376.733%20494.791C377.619%20521.945%20376.335%20549.646%20376.882%20576.847C376.977%20581.587%20376.994%20586.758%20376.802%20591.492C376.053%20586.437%20376.436%20565.389%20376.45%20559.403L376.596%20497.305Z%22%2F%3E%3Cpath%20fill%3D%22%2349C3D2%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M333.136%20531.333C337.453%20531.097%20359.66%20531.071%20362.635%20532.457L362.673%20533.482C358.556%20534.053%20338.068%20534.202%20333.77%20533.882C332.685%20532.743%20333.09%20533.446%20333.136%20531.333Z%22%2F%3E%3Cpath%20fill%3D%22%2349C3D2%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M347.622%20442.124C351.914%20441.89%20368.04%20441.374%20371.239%20442.416C371.748%20443.827%20371.706%20443.099%20371.142%20444.674C366.38%20444.486%20350.151%20445.266%20346.955%20443.9L346.689%20442.907L347.622%20442.124Z%22%2F%3E%3Cdefs%3E%3ClinearGradient%20id%3D%22gradient_4%22%20gradientUnits%3D%22userSpaceOnUse%22%20x1%3D%22468.72772%22%20y1%3D%22631.01733%22%20x2%3D%22575.09564%22%20y2%3D%22402.43958%22%3E%3Cstop%20offset%3D%220%22%20stop-color%3D%22%231A3875%22%2F%3E%3Cstop%20offset%3D%221%22%20stop-color%3D%22%232B9DAA%22%2F%3E%3C%2FlinearGradient%3E%3C%2Fdefs%3E%3Cpath%20fill%3D%22url%28%23gradient_4%29%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M470.797%20383.08C492.946%20383.205%20515.096%20383.184%20537.244%20383.016C537.237%20386.203%20537.366%20390.664%20537.174%20393.748C537.218%20402.164%20537.2%20410.581%20537.121%20418.997L537.317%20426.171C551.886%20426.351%20566.594%20426.027%20581.129%20426.349L581.171%20634.081C545.454%20634.179%20508.722%20633.634%20473.115%20634.204L468.248%20634.122C457.204%20634.925%20436.856%20634.075%20425.153%20634.234C415.874%20634.359%20392.775%20634.814%20384.309%20633.981C384.777%20622.9%20384.223%20608.141%20384.18%20596.652C383.955%20586.434%20384.004%20571.472%20384.225%20561.249L384.216%20550.741C383.962%20546.346%20383.936%20540.775%20384.09%20536.329C385.012%20509.602%20382.924%20481.028%20384.528%20454.521C384.42%20440.945%20384.17%20428.079%20384.464%20414.496L384.543%20412.475C384.652%20402.757%20384.327%20392.929%20384.416%20383.154C396.284%20382.919%20408.748%20383.109%20420.671%20383.091L424.08%20383.099C438.298%20383.181%20454.07%20383.515%20468.22%20383.086L470.797%20383.08Z%22%2F%3E%3Cdefs%3E%3ClinearGradient%20id%3D%22gradient_5%22%20gradientUnits%3D%22userSpaceOnUse%22%20x1%3D%22405.44955%22%20y1%3D%22599.94165%22%20x2%3D%22446.71878%22%20y2%3D%22490.88556%22%3E%3Cstop%20offset%3D%220%22%20stop-color%3D%22%231B3E79%22%2F%3E%3Cstop%20offset%3D%221%22%20stop-color%3D%22%23226A91%22%2F%3E%3C%2FlinearGradient%3E%3C%2Fdefs%3E%3Cpath%20fill%3D%22url%28%23gradient_5%29%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M384.216%20550.741C383.962%20546.346%20383.936%20540.775%20384.09%20536.329C385.012%20509.602%20382.924%20481.028%20384.528%20454.521C385.155%20467.552%20384.419%20481.582%20384.645%20494.701C396.671%20494.599%20408.697%20494.557%20420.723%20494.576C420.676%20489.188%20420.113%20479.527%20421.843%20474.738L422.463%20474.455C424.435%20478.481%20423.813%20489.724%20423.758%20494.64L452.348%20494.656C456.446%20494.661%20463.821%20494.482%20467.765%20494.823L467.472%20496.023C468.449%20497.577%20467.776%20496.957%20469.813%20497.631L470.76%20497.229L470.844%20497.549L470.828%20563.285C470.826%20568.494%20470.417%20589.865%20470.94%20593.739L470.502%20596.577C471.199%20604.908%20470.719%20614.401%20470.94%20622.829C471.007%20625.378%20470.665%20631.137%20471.065%20633.405C471.904%20633.773%20472.236%20633.945%20473.115%20634.204L468.248%20634.122C457.204%20634.925%20436.856%20634.075%20425.153%20634.234C415.874%20634.359%20392.775%20634.814%20384.309%20633.981C384.777%20622.9%20384.223%20608.141%20384.18%20596.652C383.955%20586.434%20384.004%20571.472%20384.225%20561.249L384.216%20550.741Z%22%2F%3E%3Cpath%20fill%3D%22%231B3F78%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M421.116%20596.572L424.163%20596.651C438.73%20596.344%20453.702%20596.64%20468.333%20596.568L468.403%20606.239C468.343%20610.579%20468.749%20630.664%20468.371%20633.792L468.248%20634.122C457.204%20634.925%20436.856%20634.075%20425.153%20634.234C415.874%20634.359%20392.775%20634.814%20384.309%20633.981C384.777%20622.9%20384.223%20608.141%20384.18%20596.652C387.321%20596.331%20393.421%20596.539%20396.833%20596.545L421.116%20596.572Z%22%2F%3E%3Cpath%20fill%3D%22%231B3F78%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M384.18%20596.652C387.321%20596.331%20393.421%20596.539%20396.833%20596.545L421.116%20596.572C421.163%20608.222%20421.546%20622.358%20421.032%20633.869C410.378%20633.798%20394.672%20633.223%20384.309%20633.981C384.777%20622.9%20384.223%20608.141%20384.18%20596.652Z%22%2F%3E%3Cpath%20fill%3D%22%2348ACC9%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M421.116%20596.572L424.163%20596.651C424.142%20609.033%20424.367%20621.588%20424.238%20633.932C438.385%20633.813%20454.495%20634.226%20468.371%20633.792L468.248%20634.122C457.204%20634.925%20436.856%20634.075%20425.153%20634.234C415.874%20634.359%20392.775%20634.814%20384.309%20633.981C394.672%20633.223%20410.378%20633.798%20421.032%20633.869C421.546%20622.358%20421.163%20608.222%20421.116%20596.572Z%22%2F%3E%3Cpath%20fill%3D%22%2349C3D2%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M384.216%20550.741C383.962%20546.346%20383.936%20540.775%20384.09%20536.329C385.012%20509.602%20382.924%20481.028%20384.528%20454.521C385.155%20467.552%20384.419%20481.582%20384.645%20494.701C396.671%20494.599%20408.697%20494.557%20420.723%20494.576C420.676%20489.188%20420.113%20479.527%20421.843%20474.738L422.463%20474.455C424.435%20478.481%20423.813%20489.724%20423.758%20494.64L452.348%20494.656C456.446%20494.661%20463.821%20494.482%20467.765%20494.823L467.472%20496.023C468.449%20497.577%20467.776%20496.957%20469.813%20497.631L470.76%20497.229L470.844%20497.549L470.828%20563.285C470.826%20568.494%20470.417%20589.865%20470.94%20593.739L470.502%20596.577C471.199%20604.908%20470.719%20614.401%20470.94%20622.829C471.007%20625.378%20470.665%20631.137%20471.065%20633.405C471.904%20633.773%20472.236%20633.945%20473.115%20634.204L468.248%20634.122L468.371%20633.792C468.749%20630.664%20468.343%20610.579%20468.403%20606.239C469.882%20604.308%20469.066%20589.813%20468.307%20586.992C467.844%20578.802%20468.214%20565.883%20468.219%20557.431C468.36%20537.489%20468.338%20517.545%20468.155%20497.603L423.773%20497.593C423.834%20502.231%20424.222%20508.186%20422.819%20512.495L422.18%20512.748C420.324%20509.498%20420.731%20501.506%20420.735%20497.508C408.604%20497.686%20396.471%20497.626%20384.342%20497.329C384.896%20511.677%20385.001%20536.349%20384.216%20550.741Z%22%2F%3E%3Cpath%20fill%3D%22%2348ACC9%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M384.225%20561.249C385.118%20570.412%20384.686%20584.36%20384.613%20593.899L421.215%20593.691C421.126%20588.765%20420.531%20580.372%20422.154%20575.988L422.838%20575.936C424.564%20579.958%20424.095%20588.938%20424.133%20593.634C437.18%20594.152%20455.049%20593.99%20468.283%20593.717L468.307%20586.992C469.066%20589.813%20469.882%20604.308%20468.403%20606.239L468.333%20596.568C453.702%20596.64%20438.73%20596.344%20424.163%20596.651L421.116%20596.572L396.833%20596.545C393.421%20596.539%20387.321%20596.331%20384.18%20596.652C383.955%20586.434%20384.004%20571.472%20384.225%20561.249Z%22%2F%3E%3Cpath%20fill%3D%22%23FAFCFD%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M404.763%20541.69C415.533%20541.812%20426.304%20541.853%20437.075%20541.814L437.089%20571.65C426.302%20571.816%20415.513%20571.743%20404.729%20571.43C404.547%20561.517%20404.558%20551.602%20404.763%20541.69Z%22%2F%3E%3Cpath%20fill%3D%22%231B3F78%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M410.027%20547.042L431.524%20546.967L431.589%20566.225L410.015%20566.228C410.131%20559.833%20410.135%20553.437%20410.027%20547.042Z%22%2F%3E%3Cdefs%3E%3ClinearGradient%20id%3D%22gradient_6%22%20gradientUnits%3D%22userSpaceOnUse%22%20x1%3D%22412.84955%22%20y1%3D%22501.15778%22%20x2%3D%22439.28961%22%20y2%3D%22407.85077%22%3E%3Cstop%20offset%3D%220%22%20stop-color%3D%22%2320618A%22%2F%3E%3Cstop%20offset%3D%221%22%20stop-color%3D%22%2324859D%22%2F%3E%3C%2FlinearGradient%3E%3C%2Fdefs%3E%3Cpath%20fill%3D%22url%28%23gradient_6%29%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M420.671%20383.091L424.08%20383.099C424.164%20392.903%20424.064%20402.708%20423.778%20412.509L431.332%20412.553L430.802%20412.671C428.203%20413.23%20426.375%20413.39%20423.739%20413.638L423.523%20413.088L422.068%20413.519L422.312%20413.417L422.698%20413.839L422.881%20413.357L423.19%20413.909L423.47%20413.361L423.691%20413.955L424.025%20413.405C426.759%20413.654%20428.68%20413.75%20431.355%20414.508C443.414%20414.688%20456.306%20414.233%20468.126%20414.597L468.239%20469.583C468.246%20473.54%20468.538%20492.066%20467.765%20494.823C463.821%20494.482%20456.446%20494.661%20452.348%20494.656L423.758%20494.64C423.813%20489.724%20424.435%20478.481%20422.463%20474.455L421.843%20474.738C420.113%20479.527%20420.676%20489.188%20420.723%20494.576C408.697%20494.557%20396.671%20494.599%20384.645%20494.701C384.419%20481.582%20385.155%20467.552%20384.528%20454.521C384.42%20440.945%20384.17%20428.079%20384.464%20414.496L384.543%20412.475C384.652%20402.757%20384.327%20392.929%20384.416%20383.154C396.284%20382.919%20408.748%20383.109%20420.671%20383.091Z%22%2F%3E%3Cpath%20fill%3D%22%232487A1%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M420.671%20383.091L424.08%20383.099C424.164%20392.903%20424.064%20402.708%20423.778%20412.509L431.332%20412.553L430.802%20412.671C428.203%20413.23%20426.375%20413.39%20423.739%20413.638L423.523%20413.088L422.068%20413.519L422.312%20413.417L422.698%20413.839L422.881%20413.357L423.19%20413.909L423.47%20413.361L423.691%20413.955L424.025%20413.405C426.759%20413.654%20428.68%20413.75%20431.355%20414.508L423.841%20414.662L421.086%20414.71C418.311%20414.512%20414.667%20414.575%20411.816%20414.544C402.699%20414.598%20393.581%20414.582%20384.464%20414.496L384.543%20412.475C384.652%20402.757%20384.327%20392.929%20384.416%20383.154C396.284%20382.919%20408.748%20383.109%20420.671%20383.091Z%22%2F%3E%3Cpath%20fill%3D%22%2349C3D2%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M420.671%20383.091L424.08%20383.099C424.164%20392.903%20424.064%20402.708%20423.778%20412.509L431.332%20412.553L430.802%20412.671C428.203%20413.23%20426.375%20413.39%20423.739%20413.638L423.523%20413.088L422.068%20413.519L422.312%20413.417L422.698%20413.839L422.881%20413.357L423.19%20413.909L423.47%20413.361L423.691%20413.955L424.025%20413.405C426.759%20413.654%20428.68%20413.75%20431.355%20414.508L423.841%20414.662L421.086%20414.71C418.311%20414.512%20414.667%20414.575%20411.816%20414.544C414.137%20413.93%20417.559%20413.455%20419.97%20413.756C419.286%20413.25%20417.284%20413.222%20415.9%20412.836L414.961%20412.568L421.275%20412.417C421.205%20403.363%20421.376%20391.996%20420.671%20383.091Z%22%2F%3E%3Cpath%20fill%3D%22%2357E0E3%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M384.543%20412.475C394.188%20412.467%20405.443%20412.174%20414.961%20412.568L415.9%20412.836C417.284%20413.222%20419.286%20413.25%20419.97%20413.756C417.559%20413.455%20414.137%20413.93%20411.816%20414.544C402.699%20414.598%20393.581%20414.582%20384.464%20414.496L384.543%20412.475Z%22%2F%3E%3Cpath%20fill%3D%22%2349C3D2%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M421.086%20414.71L423.841%20414.662C423.866%20418.297%20424.434%20430.89%20422.397%20433.232C420.482%20431.125%20421.055%20418.132%20421.086%20414.71Z%22%2F%3E%3Cpath%20fill%3D%22%23FAFCFD%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M404.438%20439.853C415.134%20439.623%20425.819%20439.949%20436.59%20439.634C436.727%20449.983%20436.754%20460.333%20436.672%20470.683C425.935%20470.539%20415.133%20470.928%20404.412%20470.376C404.308%20460.202%20404.317%20450.027%20404.438%20439.853Z%22%2F%3E%3Cpath%20fill%3D%22%2325719C%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M409.941%20445.294C416.985%20445.386%20424.159%20445.322%20431.215%20445.329C431.085%20451.838%20431.18%20458.606%20431.185%20465.136L409.885%20465.111L409.941%20445.294Z%22%2F%3E%3Cpath%20fill%3D%22%232487A1%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M424.08%20383.099C438.298%20383.181%20454.07%20383.515%20468.22%20383.086C468.482%20392.722%20467.912%20402.932%20468.235%20412.177C465.542%20412.772%20436.222%20412.516%20431.332%20412.553L423.778%20412.509C424.064%20402.708%20424.164%20392.903%20424.08%20383.099Z%22%2F%3E%3Cpath%20fill%3D%22%2349C3D2%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M468.126%20414.597L470.733%20414.756L470.687%20466.731C470.68%20474.109%20470.352%20487.732%20470.969%20494.588L470.76%20497.229L469.813%20497.631C467.776%20496.957%20468.449%20497.577%20467.472%20496.023L467.765%20494.823C468.538%20492.066%20468.246%20473.54%20468.239%20469.583L468.126%20414.597Z%22%2F%3E%3Cpath%20fill%3D%22%2357E0E3%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M468.235%20412.177C470.09%20411.994%20469.329%20411.751%20470.822%20412.41C479.001%20412.536%20488.092%20412.286%20496.099%20412.8L496.487%20413.25C489.929%20416.38%20478.271%20413.418%20470.733%20414.756L468.126%20414.597C456.306%20414.233%20443.414%20414.688%20431.355%20414.508C428.68%20413.75%20426.759%20413.654%20424.025%20413.405L423.691%20413.955L423.47%20413.361L423.19%20413.909L422.881%20413.357L422.698%20413.839L422.312%20413.417L422.068%20413.519L423.523%20413.088L423.739%20413.638C426.375%20413.39%20428.203%20413.23%20430.802%20412.671L431.332%20412.553C436.222%20412.516%20465.542%20412.772%20468.235%20412.177Z%22%2F%3E%3Cpath%20fill%3D%22%2349C3D2%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M468.22%20383.086L470.797%20383.08C470.722%20392.856%20470.73%20402.633%20470.822%20412.41C469.329%20411.751%20470.09%20411.994%20468.235%20412.177C467.912%20402.932%20468.482%20392.722%20468.22%20383.086Z%22%2F%3E%3Cpath%20fill%3D%22%2349C3D2%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M470.969%20494.588C475.485%20494.619%20484.878%20494.279%20488.715%20495.914L488.484%20496.505C483.918%20497.878%20475.851%20497.564%20470.844%20497.549L470.76%20497.229L470.969%20494.588Z%22%2F%3E%3Cpath%20fill%3D%22%2348ACC9%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M470.94%20593.739C475.118%20593.737%20483.411%20593.335%20486.887%20595.076L486.659%20595.638C482.002%20597.115%20475.492%20596.695%20470.502%20596.577L470.94%20593.739Z%22%2F%3E%3Cpath%20fill%3D%22%2348ACC9%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M537.121%20418.997C536.13%20416.02%20536.667%20412.433%20536.107%20409.444C534.862%20402.792%20531.317%20399.308%20537.174%20393.748C537.218%20402.164%20537.2%20410.581%20537.121%20418.997Z%22%2F%3E%3Cpath%20fill%3D%22%23FAFCFD%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M495.427%20579.048L560.959%20579.098C561.093%20591.787%20561.102%20604.476%20560.986%20617.165L495.477%20617.162C495.394%20604.289%20495.217%20591.928%20495.427%20579.048Z%22%2F%3E%3Cpath%20fill%3D%22%231B3F78%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M501.576%20584.772C519.306%20584.678%20537.037%20584.7%20554.767%20584.838L554.753%20611.251C537.503%20611.748%20518.747%20611.44%20501.446%20611.197L501.576%20584.772Z%22%2F%3E%3Cpath%20fill%3D%22%23FAFCFD%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M496.544%20491.94C508.566%20492.079%20520.503%20491.89%20532.549%20492.155L532.613%20521.747L496.537%20521.706C496.462%20511.784%20496.464%20501.862%20496.544%20491.94Z%22%2F%3E%3Cpath%20fill%3D%22%2325719C%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M502.058%20497.57C510.216%20497.769%20518.713%20497.664%20526.898%20497.674L526.847%20515.995C518.617%20516.071%20510.387%20515.965%20502.162%20515.678L502.058%20497.57Z%22%2F%3E%3Cpath%20fill%3D%22%23FAFCFD%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M494.674%20541.962L539.548%20541.96C544.023%20541.97%20556.717%20541.69%20560.454%20542.288C561.256%20543.962%20560.98%20546.223%20560.943%20548.152L494.821%20548.126L494.674%20541.962Z%22%2F%3E%3Cpath%20fill%3D%22%23FAFCFD%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M494.548%20557.845C503.007%20557.811%20555.289%20556.645%20560.671%20558.23C561.419%20560.216%20561.093%20561.792%20560.942%20563.94C545.963%20563.152%20529.825%20564.052%20514.768%20563.783C510.715%20563.711%20498.144%20564.198%20495.101%20563.3C494.191%20561.609%20494.482%20559.804%20494.548%20557.845Z%22%2F%3E%3Cpath%20fill%3D%22%23FAFCFD%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M496.543%20453.779L560.768%20453.761L560.801%20459.814L519.918%20459.936C513.75%20459.942%20502.782%20460.259%20496.95%20459.699C496.199%20458.185%20496.5%20455.579%20496.543%20453.779Z%22%2F%3E%3Cpath%20fill%3D%22%23FAFCFD%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M496.704%20468.988C517.626%20469.47%20539.461%20469.147%20560.479%20469.129C560.671%20471.049%20560.762%20473.148%20560.887%20475.088C545.528%20474.622%20529.742%20475.203%20514.366%20475.034C511.111%20474.998%20499.235%20475.377%20496.822%20474.797C496.178%20473.096%20496.562%20470.87%20496.704%20468.988Z%22%2F%3E%3Cpath%20fill%3D%22%23FAFCFD%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M497.226%20438.505C507.942%20438.45%20521.032%20438.011%20531.53%20438.515C532.545%20440.02%20532.298%20442.395%20532.009%20444.166L531.118%20444.519C519.539%20444.566%20507.959%20444.536%20496.381%20444.428C496.219%20442.373%20495.79%20440.014%20497.226%20438.505Z%22%2F%3E%3Cpath%20fill%3D%22%23F47819%22%20transform%3D%22matrix%281.08669%200%200%201.08712%200%20-3.05176e-05%29%22%20d%3D%22M544.474%20385.961C545.766%20386.931%20554.418%20395.627%20555.715%20397.002C561.922%20403.585%20571.233%20411.799%20576.726%20418.717C566.075%20419.392%20555.563%20419.337%20544.905%20419.348C544.419%20408.501%20544.504%20396.866%20544.474%20385.961Z%22%2F%3E%3C%2Fsvg%3E">

  <!-- pdfmake (client-side) requires pdfmake + vfs_fonts + teste -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.12/pdfmake.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.12/vfs_fonts.js"></script>
  <!-- JsBarcode for barcode generation -->
  <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js"></script>
  <!-- Chart.js for chart generation -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    /* Variáveis CSS para modo claro */
    :root {
      --bg-primary: #f3f4f6;
      --bg-secondary: #ffffff;
      --bg-tertiary: #f9fafb;
      --bg-hover: #f3f4f6;
      --text-primary: #111827;
      --text-secondary: #374151;
      --text-tertiary: #6b7280;
      --border-color: #e5e7eb;
      --border-hover: #d1d5db;
      --shadow: rgba(0, 0, 0, 0.1);
      --modal-overlay: rgba(0, 0, 0, 0.5);
    }

    /* Variáveis CSS para modo escuro */
    [data-theme="dark"] {
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-tertiary: #334155;
      --bg-hover: #4b5563;
      --text-primary: #f9fafb;
      --text-secondary: #e5e7eb;
      --text-tertiary: #9ca3af;
      --border-color: #374151;
      --border-hover: #4b5563;
      --shadow: rgba(0, 0, 0, 0.3);
      --modal-overlay: rgba(0, 0, 0, 0.7);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      height: 100vh;
      overflow: hidden;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    /* Header */
    .header {
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      padding: 1rem 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      transition: background-color 0.3s ease, border-color 0.3s ease;
    }

    .header-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .header-left h1 {
      font-size: 1.25rem;
      font-weight: bold;
      color: var(--text-primary);
    }

    .header-left p {
      font-size: 0.875rem;
      color: var(--text-tertiary);
    }

    .header-right {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    /* Botão Dark Mode */
    .dark-mode-toggle {
      padding: 10px 16px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
      color: var(--text-primary);
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      font-size: 0.875rem;
      min-width: 40px;
      height: auto;
    }

    .dark-mode-toggle:hover {
      background: var(--bg-hover);
      border-color: var(--border-hover);
    }

    .dark-mode-toggle svg {
      width: 20px;
      height: 20px;
      stroke: currentColor;
    }

    /* Por padrão, mostrar lua (modo claro) e esconder sol */
    #sunIcon {
      display: none;
    }

    #moonIcon {
      display: block;
    }

    /* Quando estiver no modo dark, mostrar sol e esconder lua */
    [data-theme="dark"] #sunIcon {
      display: block !important;
    }

    [data-theme="dark"] #moonIcon {
      display: none !important;
    }

    .orientation-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .orientation-group label {
      font-size: 0.875rem;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .button-group {
      display: flex;
      gap: 0.5rem;
    }

    button {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 0.375rem;
      cursor: pointer;
      font-size: 0.875rem;
      font-weight: 500;
      transition: all 0.2s;
    }

    .btn-portrait,
    .btn-landscape {
      background: #d1d5db;
      color: #374151;
    }

    .btn-portrait.active,
    .btn-landscape.active {
      background: #2563eb;
      color: white;
    }

    .btn-portrait:hover,
    .btn-landscape:hover {
      background: #9ca3af;
    }

    .btn-portrait.active:hover,
    .btn-landscape.active:hover {
      background: #1d4ed8;
    }

    .btn-clear {
      background: #fee2e2;
      color: #991b1b;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .btn-clear:hover {
      background: #fecaca;
    }

    /* Toolbar */
    .toolbar {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: flex-end;
      padding-top: 0.5rem;
      height: 80px;
    }

    .chip {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      background: var(--bg-tertiary);
      border-radius: 999px;
      color: var(--text-secondary);
      font-size: 12px;
      transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }

    .chip span {
      font-weight: 500;
      color: var(--text-tertiary);
    }

    .chip select,
    .chip input {
      background: transparent;
      color: var(--text-primary);
      border: none;
      outline: none;
      font-size: 12px;
      width: auto;
      font-family: inherit;
    }

    .chip select {
      cursor: pointer;
    }

    .chip input {
      width: 64px;
      text-align: center;
      padding: 2px 4px;
    }

    .btn {
      padding: 10px 16px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
      color: var(--text-secondary);
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.875rem;
    }

    .btn:hover {
      background: var(--bg-hover);
      border-color: var(--border-hover);
    }

    .btn:active {
      transform: translateY(1px);
    }

    .btn.primary {
      border-color: #2563eb;
      background: #2563eb;
      color: white;
    }

    .btn.primary:hover {
      background: #1d4ed8;
      border-color: #1d4ed8;
    }

    .btn.good {
      border-color: #10b981;
      background: #10b981;
      color: white;
    }

    .btn.good:hover {
      background: #059669;
      border-color: #059669;
    }

    /* V1 - Replicação com IA desabilitada
    #aiReplicateBtn:hover {
      background: #fef2f2;
      border-color: #e2574c;
      color: #e2574c;
    }

    #aiReplicateBtn:active {
      background: #fee2e2;
    }
    */

    /* Main Layout */
    .main {
      display: flex;
      flex: 1;
      overflow: hidden;
      position: relative;
    }

    /* Ajustar canvas-area quando code-panel está visível */
    .canvas-area {
      margin-right: 0;
      /* Margem removida pois o painel agora é flutuante (position: fixed) */
    }

    /* Sidebar */
    .sidebar {
      width: 16rem;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border-color);
      padding: 1rem;
      overflow-y: auto;
      transition: background-color 0.3s ease, border-color 0.3s ease;
    }

    .sidebar h2 {
      font-size: 1.125rem;
      font-weight: bold;
      margin-bottom: 1rem;
      color: var(--text-primary);
    }

    .elements-grid {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .element-btn {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.75rem;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 0.5rem;
      cursor: move;
      transition: all 0.2s;
      font-size: 0.875rem;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .element-btn:hover {
      background: var(--bg-hover);
      border-color: var(--border-hover);
    }

    .element-icon {
      width: 2rem;
      height: 2rem;
      border-radius: 0.375rem;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 1.125rem;
    }

    .icon-text {
      background: #3b82f6;
    }

    .icon-header {
      background: #a855f7;
    }

    .icon-image {
      background: #10b981;
    }

    .icon-table {
      background: #f97316;
    }

    .icon-columns {
      background: #22830a;
    }

    .icon-list {
      background: #06b6d4;
    }

    .icon-margin {
      background: #6b7280;
    }

    .icon-pagebreak {
      background: #ef4444;
    }

    .icon-checkbox {
      background: #ef4444;
    }

    .icon-stamp {
      background: #08af61;
    }

    .icon-radio {
      background: #162cf3;
    }

    .icon-line {
      background: #f39e08;
    }

    .icon-chart {
      background: #f31862;
    }

    .icon-qr {
      background: #ff2f2f;
    }

    .icon-svg {
      background: #fc2fff;
    }

    .icon-barcode {
      background: #b113fa;
    }

    .icon-group {
      background: #8b5cf6;
    }

    .info-box {
      margin-top: 1.5rem;
      padding: 1rem;
      background: var(--bg-tertiary);
      border-radius: 0.5rem;
      border: 1px solid var(--border-color);
      transition: background-color 0.3s ease, border-color 0.3s ease;
    }

    .info-box h3 {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.5rem;
    }

    .info-box ol {
      font-size: 0.75rem;
      color: var(--text-secondary);
      list-style-position: inside;
    }

    .info-box li {
      margin-bottom: 0.25rem;
    }

    /* Canvas */
    .canvas-area {
      flex: 1;
      background: var(--bg-primary);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      transition: background-color 0.3s ease;
    }

    .canvas-tools {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border-color);
      background: var(--bg-secondary);
      transition: background-color 0.3s ease, border-color 0.3s ease;
    }

    .canvas-tools-right {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .zoom {
      display: flex;
      gap: 8px;
      align-items: center;
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      border-radius: 999px;
      color: var(--text-tertiary);
      font-size: 12px;
      background: var(--bg-tertiary);
      transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }

    .zoom span:first-child {
      font-weight: 500;
      color: var(--text-secondary);
    }

    .zoom input[type="range"] {
      width: 120px;
      cursor: pointer;
    }

    .zoom-btn {
      width: 24px;
      height: 24px;
      border: 1px solid var(--border-color);
      border-radius: 100px;
      background: var(--bg-secondary);
      color: var(--text-secondary);
      font-size: 18px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      transition: all 0.2s;
    }

    .zoom-btn:hover {
      background: var(--bg-hover);
      border-color: var(--border-hover);
    }

    .zoom-btn:active {
      background: #62ba45;
      transform: scale(0.95);
    }

    .zoom span:last-child {
      min-width: 40px;
      text-align: center;
      font-weight: 600;
      color: var(--text-primary);
    }

    .canvas-wrapper {
      flex: 1;
      overflow: auto;
      padding: 1.5rem;
      display: flex;
      align-items: flex-start;
      justify-content: center;
    }

    .canvas-wrapper::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    .canvas-wrapper::-webkit-scrollbar-track {
      background: var(--bg-primary);
    }

    .canvas-wrapper::-webkit-scrollbar-thumb {
      background: var(--border-hover);
      border-radius: 4px;
    }

    .canvas-wrapper::-webkit-scrollbar-thumb:hover {
      background: var(--text-tertiary);
    }

    .canvas {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 0.5rem;
      padding: 2rem;
      /* width e max-width são controlados dinamicamente via JavaScript (adjustCanvasSize) */
      /* Removido aspect-ratio fixo para permitir crescimento dinâmico */
      overflow: visible;
      box-shadow: 0 4px 6px var(--shadow);
      min-height: 842px;
      /* Altura mínima inicial (tamanho A4 portrait) */
      min-width: 595px;
      /* Largura mínima inicial (tamanho A4 portrait) */
      /* Altura e largura máximas não definidas - canvas cresce conforme necessário */
      transition: border-color 0.2s, transform 0.2s, background-color 0.3s ease, box-shadow 0.3s ease;
      position: relative;
      color: var(--text-primary);
    }

    /* Garantir que todos os elementos dentro do canvas herdem a cor de texto */
    .canvas * {
      color: inherit;
    }

    /* Exceções: elementos que devem manter suas próprias cores */
    .canvas .preview-image-box,
    .canvas .element-image,
    .canvas button {
      color: var(--text-primary);
    }

    .canvas.drag-over {
      border: 4px dashed #2563eb;
    }

    .canvas-empty {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-tertiary);
      text-align: center;
      pointer-events: none;
      width: 100%;
    }

    .canvas-empty p:first-child {
      font-size: 1.125rem;
      margin-bottom: 0.5rem;
    }

    .canvas-empty p:last-child {
      font-size: 0.875rem;
    }

    .elements-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .element-item {
      position: relative;
      padding: 1rem;
      border: 2px solid var(--border-color);
      border-radius: 0.375rem;
      transition: all 0.2s;
      background: var(--bg-secondary);
      box-shadow: 0 2px 4px var(--shadow);
      cursor: move;
      width: 100%;
      color: var(--text-primary);
    }

    .element-item:hover {
      border-color: var(--border-hover);
    }

    .element-item.dragging {
      opacity: 0.7;
      cursor: grabbing;
    }

    .element-group {
      background: rgba(139, 92, 246, 0.05) !important;
      min-height: 200px;
      padding: 0;
      box-sizing: border-box;
      width: 100% !important;
    }

    [data-theme="dark"] .element-group {
      background: rgba(139, 92, 246, 0.15) !important;
    }

    .element-group.drag-over {
      border-color: #6366f1 !important;
      background: rgba(99, 102, 241, 0.15) !important;
    }

    [data-theme="dark"] .element-group.drag-over {
      background: rgba(99, 102, 241, 0.3) !important;
    }

    /* Elemento de imagem - container invisível (já aplicado acima com .element-item.element-image) */
    .element-image {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: auto !important;
      margin: 0;
    }

    .element-image .element-preview {
      padding: 0 !important;
      margin: 0 !important;
      width: 100%;
      height: 100%;
      background: transparent !important;
      border: none !important;
      box-shadow: none !important;
      border-radius: 0 !important;
      min-height: 0 !important;
      min-width: 0 !important;
      line-height: 0 !important;
      font-size: 0 !important;
      color: transparent !important;
      overflow: hidden;
    }

    .group-children {
      display: flex;
      gap: 10px;
      width: 100%;
      /* Sempre ocupa 100% da largura */
      height: auto;
      min-height: 120px;
      box-sizing: border-box;
      align-items: flex-start;
    }

    .group-children.orientation-row {
      flex-direction: row;
      align-items: flex-start;
      flex-wrap: nowrap;
      width: 100%;
      box-sizing: border-box;
    }

    .group-children.orientation-column {
      flex-direction: column;
      align-items: flex-start;
    }

    .group-child-item {
      padding: 0.5rem;
      border: 1px solid var(--border-color);
      border-radius: 0.5rem;
      background: var(--bg-secondary);
      position: relative;
      cursor: pointer;
      transition: all 0.2s;
      box-sizing: border-box;
      color: var(--text-primary);
    }

    .group-children.orientation-column .group-child-item {
      width: 100%;
    }

    .group-children.orientation-row .group-child-item {
      /* Largura será definida inline via style baseado em child.width */
      min-width: 0;
      /* Permite que elementos encolham abaixo do conteúdo mínimo */
      box-sizing: border-box;
      overflow: hidden;
      /* Previne que conteúdo ultrapasse o container */
    }

    .group-child-item:hover {
      border-color: var(--border-hover);
    }

    .group-child-item.selected {
      border-color: #2563eb;
      background: var(--bg-tertiary);
    }

    [data-theme="dark"] .group-child-item.selected {
      background: rgba(37, 99, 235, 0.2);
    }

    /* Quando group-child-item contém uma imagem, tornar invisível */
    .group-child-item.group-child-sem-abas {
      padding: 50 !important;
      border: none !important;
      border-radius: 0 !important;
      background: transparent !important;
      box-shadow: none !important;
      margin: 0 !important;
    }

    .group-child-item.group-child-sem-abas:hover {
      border: none !important;
      background: transparent !important;
    }

    .group-child-item.group-child-sem-abas.selected {
      border: none !important;
      background: transparent !important;
    }

    .group-placeholder {
      color: var(--text-tertiary);
      text-align: center;
      padding: 2rem;
      width: 100%;
      border-radius: 0.75rem;
      box-sizing: border-box;
      transition: color 0.3s ease;
    }

    /* Botão de remover removido - agora está no editor */

    .smallNote {
      font-size: 0.75rem;
      color: var(--text-tertiary);
      margin-top: 0.5rem;
      line-height: 1.4;
      transition: color 0.3s ease;
    }

    .element-item:hover {
      border-color: var(--border-hover);
    }

    .element-item.selected {
      border-color: #2563eb;
      background: var(--bg-tertiary);
    }

    [data-theme="dark"] .element-item.selected {
      background: rgba(37, 99, 235, 0.2);
    }


    [data-theme="dark"] .text_lab {      
       fill: #FFFFFF !important; 
    }


    /* Sobrescrever estilos do .element-item quando for imagem */
    .element-item.element-image {
      padding: 0 !important;
      border: none !important;
      border-radius: 0 !important;
      background: transparent !important;
      box-shadow: none !important;
      width: auto !important;
      margin: 0 !important;
      min-width: 0 !important;
      min-height: 0 !important;
      display: inline-block;
      line-height: 0 !important;
      font-size: 0 !important;
    }

    /* Quando imagem está em posição absoluta, garantir que não interfira com outros elementos */
    .element-item.element-image[style*="position: absolute"],
    .element-item.element-image[style*="position:absolute"] {
      z-index: 10;
    }

    .element-item.element-image:hover {
      border: none !important;
      background: transparent !important;
      box-shadow: none !important;
    }

    .element-item.element-image.selected {
      border: none !important;
      background: transparent !important;
      box-shadow: none !important;
      outline: 2px dashed #2563eb;
      outline-offset: 2px;
    }

    /* Garantir que nenhum estilo de seleção padrão seja aplicado */
    .element-item.element-image.selected::before,
    .element-item.element-image.selected::after {
      display: none !important;
    }

    .element-item.element-image.dragging {
      opacity: 0.7;
      cursor: grabbing;
    }

    .element-item {
      cursor: pointer;
    }

    .element-controls {
      position: absolute;
      top: -0.75rem;
      right: 0.5rem;
      display: none !important;
      gap: 0.25rem;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 10;
    }

    .element-btn-small {
      width: 1.75rem;
      height: 1.75rem;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 0.25rem;
      border: none;
      cursor: pointer;
      color: white;
      font-size: 0.875rem;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      padding: 0;
      z-index: 11;
      position: relative;
    }

    .btn-config {
      background: #2563eb;
    }

    .btn-config:hover {
      background: #1d4ed8;
    }

    .btn-up,
    .btn-down {
      background: #4b5563;
    }

    .btn-up:hover,
    .btn-down:hover {
      background: #374151;
    }

    .btn-remove {
      background: #ef4444;
    }

    .btn-remove:hover {
      background: #dc2626;
    }

    .element-preview {
      font-size: 0.875rem;
      color: var(--text-primary);
      transition: color 0.3s ease;
    }

    /* Para imagens, remover qualquer espaço de texto */
    .element-image .element-preview {
      font-size: 0 !important;
      line-height: 0 !important;
      color: transparent !important;
    }

    .preview-text {
      color: var(--text-primary);
      transition: color 0.3s ease;
    }

    .preview-header {
      font-size: 1.25rem;
      font-weight: bold;
      text-align: center;
      color: var(--text-primary);
      transition: color 0.3s ease;
    }

    .preview-image {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 0 !important;
      padding: 0 !important;
      min-height: 0 !important;
      width: 100%;
      height: 100%;
      background: transparent !important;
      border: none !important;
      box-shadow: none !important;
      line-height: 0 !important;
      font-size: 0 !important;
    }

    .preview-image img {
      display: block;
      object-fit: contain;
      border-radius: 0.25rem;
      box-shadow: none;
      max-width: 100%;
      max-height: 100%;
      margin: 0;
      padding: 0;
    }

    .preview-image-box {
      background: var(--bg-tertiary);
      border: 2px dashed var(--border-color);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-tertiary);
      font-size: 0.75rem;
      transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }

    /* Quando a imagem está dentro de um elemento-image, tornar o preview-image-box também invisível se necessário */
    .element-image .preview-image-box {
      background: transparent;
      border: 2px dashed var(--border-color);
    }

    .preview-table {
      /* width controlado dinamicamente - pode crescer além de 100% se necessário */
      border-collapse: collapse;
      margin: 0.5rem 0;
      /* Permitir que a tabela tenha largura natural quando necessário */
      min-width: 100%;
      width: auto;
    }

    .preview-table th,
    .preview-table td {
      /* Bordas padrão - serão sobrescritas pelo layout customizado se aplicável */
      border: 1px solid var(--border-color);
      padding: 0.5rem;
      font-size: 0.75rem;
      color: var(--text-primary);
      background: var(--bg-secondary);
      transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }

    .preview-table th {
      background: var(--bg-tertiary);
      font-weight: 600;
      color: var(--text-primary);
    }

    .preview-columns {
      display: flex;
      gap: 1rem;
      margin: 0.5rem 0;
    }

    .preview-column {
      flex: 1;
      padding: 0.5rem;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 0.25rem;
      font-size: 0.875rem;
      color: var(--text-primary);
      transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }

    .preview-list {
      margin-left: 1.5rem;
      font-size: 0.875rem;
      color: var(--text-primary);
    }

    .preview-list li {
      margin-bottom: 0.25rem;
      cursor: pointer;
      transition: background-color 0.2s, border-color 0.2s, color 0.3s ease;
      color: var(--text-primary);
    }

    .preview-list li:hover {
      background-color: var(--bg-hover);
    }

    .preview-margin {
      text-align: center;
      color: var(--text-tertiary);
      font-size: 0.875rem;
      font-style: italic;
    }

    .preview-pagebreak {
      text-align: center;
      color: var(--text-tertiary);
      font-size: 0.875rem;
      font-style: italic;
      border-top: 2px dashed var(--border-color);
      padding-top: 0.5rem;
      margin-top: 0.5rem;
    }

    /* Code Panel */
    .code-panel {
      width: 24rem;
      max-width: 600px;
      min-width: 300px;
      background: var(--bg-secondary);
      color: var(--text-primary);
      padding: 0;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      border-left: 1px solid var(--border-color);
      border-radius: 10px;
      transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease, box-shadow 0.3s ease;
      position: fixed;
      top: 0;
      right: 0;
      z-index: 1000;
      box-shadow: -2px 0 8px rgba(0, 0, 0, 0.1);
      will-change: transform;
      height: 70vh;
      max-height: 70vh;
    }

    [data-theme="dark"] .code-panel {
      border: 1px solid rgba(255, 255, 255, 0.3) !important;
      box-shadow: -2px 0 12px rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 255, 255, 0.15), 2px 0 8px rgba(0, 0, 0, 0.3) !important;
    }

    @media (max-width: 1024px) {
      .code-panel {
        width: 20rem;
        max-width: 500px;
      }
    }

    @media (max-width: 768px) {
      .code-panel {
        width: 90vw;
        max-width: 90vw;
        min-width: 280px;
      }
    }

    .code-panel.dragging {
      cursor: grabbing;
      user-select: none;
      pointer-events: auto;
    }

    body.panel-dragging {
      user-select: none;
      cursor: grabbing;
      overflow: hidden;
    }

    body.panel-dragging .main {
      pointer-events: none;
      user-select: none;
    }

    body.panel-dragging .canvas-area,
    body.panel-dragging .canvas,
    body.panel-dragging .element-item,
    body.panel-dragging .sidebar {
      pointer-events: none;
      user-select: none;
    }

    body.panel-dragging .code-panel {
      pointer-events: auto;
    }

    .code-header {
      display: flex;
      flex-direction: column;
      margin-bottom: 0;
      padding: 0;
      border-bottom: 1px solid var(--border-color);
      background: #0f172a;
      transition: background-color 0.2s ease;
      cursor: grab;
      user-select: none;
    }

    .code-header:hover {
      background: #0f172a;
    }

    .code-header:active {
      cursor: grabbing;
    }

    .header-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem 1rem;
      background: #ffffff00;
    }

    .element-type-title {
      font-size: 0.875rem;
      font-weight: 600;
      color: #ffffff;
    }

    .element-type-title strong {
      color: #ffffff;
      font-weight: 600;
    }

    .code-header .tabs {
      width: 100%;
      display: flex;
      gap: 0;
      background: #0f172a;
      padding: 0;
    }

    .close-panel-btn {
      width: 32px;
      height: 32px;
      display: flex !important;
      align-items: center;
      justify-content: center;
      background: rgba(239, 68, 68, 0.15);
      border: 1px solid rgba(239, 68, 68, 0.3);
      cursor: pointer;
      border-radius: 0.375rem;
      transition: all 0.2s ease;
      flex-shrink: 0;
      overflow: visible !important;
      position: relative;
      z-index: 10;
    }

    .close-panel-btn svg {
      transition: all 0.2s ease;
      display: block !important;
      width: 10px !important;
      height: 10px !important;
      fill: #ef4444 !important;
      visibility: visible !important;
      opacity: 1 !important;
      overflow: visible !important;
      position: relative;
      z-index: 1;
    }

    .close-panel-btn svg path {
      fill: #ef4444 !important;
      visibility: visible !important;
      opacity: 1 !important;
      stroke: none !important;
    }

    .close-panel-btn:hover {
      background: rgba(239, 68, 68, 0.25);
      border-color: rgba(239, 68, 68, 0.5);
      transform: scale(1.05);
    }

    .close-panel-btn:hover svg {
      fill: #dc2626 !important;
    }

    .close-panel-btn:hover svg path {
      fill: #dc2626 !important;
    }

    .close-panel-btn:active {
      transform: scale(0.95);
    }


    .code-panel.hidden {
      display: none;
    }

    .code-header h2 {
      font-size: 1.125rem;
      font-weight: bold;
      color: var(--text-primary);
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 0;
      flex: 1;
    }

    .tab-btn {
      flex: 1;
      padding: 0.625rem 0.75rem;
      background: transparent;
      border: none;
      color: #ffffff;
      border-radius: 0;
      cursor: pointer;
      font-size: 0.875rem;
      transition: all 0.2s;
      position: relative;
      border-bottom: 2px solid transparent;
    }

    .tab-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: #ffffff;
    }

    .tab-btn.active {
      background: transparent;
      color: #ffffff;
      border-bottom-color: #2563eb;
      font-weight: 500;
    }

    .tab-content {
      display: none;
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      min-height: 0;
      max-height: calc(70vh - 120px);
      -webkit-overflow-scrolling: touch;
      padding: 0;
      position: relative;
    }

    .tab-content.active {
      display: block;
    }

    .tab-content>* {
      padding: 1rem;
      position: relative;
      z-index: 1;
    }


    #tabContentCode {
      background: var(--bg-secondary);
    }

    #tabContentCode>div:first-child {
      padding: 1rem;
      border-bottom: 1px solid var(--border-color);
    }

    /* Inspector */
    .inspector {
      width: 100%;
      padding: 0.5rem;
      overflow-y: visible;
      overflow-x: hidden;
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
      height: auto !important;
      min-height: auto !important;
    }

    .inspector * {
      visibility: visible !important;
      opacity: 1 !important;
    }

    .inspector-field {
      display: block !important;
      visibility: visible !important;
    }

    .inspector-field input,
    .inspector-field textarea,
    .inspector-field select {
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
    }

    .inspector-field:last-child {
      margin-bottom: 0;
    }

    .inspector .muted {
      color: var(--text-tertiary);
      font-size: 0.875rem;
    }

    .inspector-field {
      margin-bottom: 1rem;
    }

    .inspector-field label {
      display: block;
      font-size: 0.875rem;
      font-weight: 500;
      color: var(--text-secondary);
      margin-bottom: 0.5rem;
    }

    .inspector-field .smallNote {
      font-size: 0.75rem;
      color: var(--text-tertiary);
      margin-top: 0.25rem;
    }

    .inspector-field input,
    .inspector-field select,
    .inspector-field textarea {
      width: 100%;
      padding: 0.5rem 0.75rem;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 0.375rem;
      color: var(--text-primary);
      font-size: 0.875rem;
      font-family: inherit;
      transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
      box-sizing: border-box;
    }

    .inspector-field textarea {
      min-height: 120px;
      resize: vertical;
      font-family: 'Courier New', monospace;
    }

    .inspector-field textarea::placeholder {
      color: var(--text-tertiary);
      opacity: 0.7;
    }

    /* Estilos para as opções dos selects - garantir contraste */
    .inspector-field select option {
      background: white !important;
      color: #111827 !important;
      padding: 0.5rem;
    }

    /* Quando o select está aberto/focado, garantir que tenha fundo branco e texto escuro */
    .inspector-field select:focus,
    .inspector-field select:active {
      background: white !important;
      color: #111827 !important;
    }

    /* Garantir que o select tenha fundo branco quando estiver aberto */
    .inspector-field select {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
    }

    /* Estilo para o dropdown aberto - garantir que as opções sejam visíveis */
    .inspector-field select option:checked,
    .inspector-field select option:hover {
      background: #f3f4f6 !important;
      color: #111827 !important;
    }

    .inspector-field input:focus,
    .inspector-field textarea:focus {
      outline: none;
      border-color: #2563eb;
      background: var(--bg-hover);
    }


    .inspector-field .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .inspector-field .row>div {
      display: flex;
      flex-direction: column;
    }

    .btn-copy {
      background: #2563eb;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      border: none;
      cursor: pointer;
      transition: background 0.2s;
      font-weight: 500;
    }

    .btn-copy:hover {
      background: #1d4ed8;
    }

    .btn-copy.copied {
      background: #16a34a;
    }

    .btn-remove-large {
      background: #ef4444;
      color: white;
      border: none;
      border-radius: 0.5rem;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s;
    }

    .btn-remove-large:hover {
      background: #dc2626;
    }

    /* Modal personalizado */
    .custom-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10000;
      align-items: center;
      justify-content: center;
    }

    .custom-modal.active {
      display: flex;
    }

    .custom-modal-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(2px);
    }

    .custom-modal-content {
      position: relative;
      background: var(--bg-secondary);
      border-radius: 0.75rem;
      box-shadow: 0 20px 25px -5px var(--shadow), 0 10px 10px -5px var(--shadow);
      max-width: 500px;
      transition: background-color 0.3s ease, box-shadow 0.3s ease;
      width: 90%;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      z-index: 10001;
    }

    .custom-modal-header {
      padding: 1.5rem;
      border-bottom: 1px solid var(--border-color);
      transition: border-color 0.3s ease;
    }

    .custom-modal-header h3 {
      margin: 0;
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .custom-modal-body {
      padding: 1.5rem;
      flex: 1;
      overflow-y: auto;
    }

    .custom-modal-body p {
      margin: 0;
      font-size: 1rem;
      color: var(--text-secondary);
      line-height: 1.5;
    }

    .custom-modal-footer {
      padding: 1rem 1.5rem;
      border-top: 1px solid var(--border-color);
      display: flex;
      gap: 0.75rem;
      justify-content: flex-end;
      transition: border-color 0.3s ease;
    }

    .custom-modal-btn {
      padding: 0.625rem 1.25rem;
      border-radius: 0.5rem;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      border: none;
      transition: all 0.2s;
    }

    .custom-modal-btn-cancel {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    .custom-modal-btn-cancel:hover {
      background: var(--bg-hover);
    }

    .custom-modal-btn-confirm {
      background: #2563eb;
      color: white;
    }

    .custom-modal-btn-confirm:hover {
      background: #1d4ed8;
    }

    /* Modal de Preview do PDF */
    .preview-modal-content {
      position: relative;
      background: var(--bg-secondary);
      border-radius: 0.75rem;
      box-shadow: 0 20px 25px -5px var(--shadow), 0 10px 10px -5px var(--shadow);
      max-width: 95%;
      width: 95%;
      max-height: 95vh;
      height: 95vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      z-index: 10001;
      transition: background-color 0.3s ease, box-shadow 0.3s ease;
    }

    .preview-modal-header {
      padding: 1.5rem;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
      background: var(--bg-secondary);
      transition: background-color 0.3s ease, border-color 0.3s ease;
    }

    .preview-modal-header h3 {
      margin: 0;
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .preview-modal-close {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      border: none;
      border-radius: 0.5rem;
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .preview-modal-close:hover {
      background: var(--bg-hover);
    }

    .preview-modal-body {
      flex: 1;
      overflow: hidden;
      position: relative;
      padding: 0;
    }

    .preview-modal-iframe {
      width: 100%;
      height: 100%;
      border: none;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }

    .code-editor {
      flex: 1;
      background: var(--bg-secondary);
      border-radius: 0.375rem;
      padding: 1rem;
      overflow: auto;
      margin: 1rem;
      margin-bottom: 1rem;
      font-family: 'Courier New', monospace;
      font-size: 0.75rem;
      line-height: 1.5;
      white-space: pre-wrap;
      word-wrap: break-word;
      color: var(--text-primary);
    }

    .code-instructions {
      padding: 0.75rem 1rem;
      margin: 0 1rem 1rem 1rem;
      font-size: 0.75rem;
      background: #dbeafe;
      border-left: 3px solid #2563eb;
      border-radius: 0.25rem;
      color: #071c5f;
    }

    .code-instructions p {
      color: #1e40af;
      margin-bottom: 0.5rem;
    }

    .code-instructions ol {
      list-style-position: inside;
      color: #1e40af;
    }

    .code-instructions li {
      margin-bottom: 0.25rem;
    }

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      inset: 0;
      background: var(--modal-overlay);
      z-index: 50;
      align-items: center;
      justify-content: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: var(--bg-secondary);
      border-radius: 0.5rem;
      box-shadow: 0 20px 25px var(--shadow);
      width: 100%;
      max-width: 28rem;
      max-height: 80vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      transition: background-color 0.3s ease, box-shadow 0.3s ease;
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem;
      border-bottom: 1px solid var(--border-color);
      transition: border-color 0.3s ease;
    }

    .modal-header h3 {
      font-size: 1.125rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .btn-close {
      background: none;
      border: none;
      color: var(--text-tertiary);
      cursor: pointer;
      font-size: 1.25rem;
      transition: color 0.3s ease;
      padding: 0;
      width: auto;
      height: auto;
    }

    .btn-close:hover {
      color: var(--text-secondary);
    }

    .modal-body {
      padding: 1rem;
      overflow-y: auto;
      flex: 1;
      color: var(--text-primary);
    }

    .form-group {
      margin-bottom: 1rem;
    }

    .form-group label {
      display: block;
      font-size: 0.875rem;
      font-weight: 500;
      margin-bottom: 0.25rem;
      color: var(--text-secondary);
    }

    .form-group input,
    .form-group select,
    .form-group textarea {
      width: 100%;
      padding: 0.5rem 0.75rem;
      border: 1px solid var(--border-color);
      border-radius: 0.375rem;
      font-size: 0.875rem;
      font-family: inherit;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }

    .form-group textarea {
      resize: vertical;
      min-height: 100px;
    }

    .form-group input:focus,
    .form-group select:focus,
    .form-group textarea:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
    }

    .checkbox-group {
      display: flex;
      gap: 1rem;
      margin-top: 0.5rem;
    }

    .checkbox-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .checkbox-item input[type="checkbox"] {
      width: auto;
      margin: 0;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
    }

    .image-preview-container {
      margin-top: 1rem;
      padding: 1rem;
      border: 1px solid var(--border-color);
      border-radius: 0.375rem;
      background: var(--bg-tertiary);
      text-align: center;
      transition: background-color 0.3s ease, border-color 0.3s ease;
    }

    .image-preview-container img {
      max-width: 100%;
      max-height: 200px;
      border-radius: 0.25rem;
      box-shadow: 0 2px 4px var(--shadow);
    }

    .image-preview-container .no-preview {
      color: var(--text-tertiary);
      font-size: 0.875rem;
      padding: 2rem;
    }

    .file-input-wrapper {
      position: relative;
      display: inline-block;
      width: 100%;
    }

    .file-input-wrapper input[type="file"] {
      width: 100%;
      padding: 0.5rem 0.75rem;
      border: 1px solid var(--border-color);
      border-radius: 0.375rem;
      font-size: 0.875rem;
      cursor: pointer;
      background: var(--bg-tertiary);
      color: var(--text-primary);
      transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }

    .file-input-wrapper input[type="file"]:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
    }

    .divider-text {
      text-align: center;
      margin: 1rem 0;
      color: var(--text-tertiary);
      font-size: 0.75rem;
      position: relative;
    }

    .divider-text::before,
    .divider-text::after {
      content: '';
      position: absolute;
      top: 50%;
      width: 40%;
      height: 1px;
      background: var(--border-color);
    }

    .divider-text::before {
      left: 0;
    }

    .divider-text::after {
      right: 0;
    }

    .modal-footer {
      padding: 1rem;
      border-top: 1px solid var(--border-color);
      display: flex;
      justify-content: flex-end;
      transition: border-color 0.3s ease;
    }

    .btn-apply {
      background: #2563eb;
      color: white;
      padding: 0.5rem 1rem;
    }

    .btn-apply:hover {
      background: #1d4ed8;
    }

    /* Utilities */
    .flex-center {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-primary);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border-hover);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-tertiary);
    }

    /* Responsividade - Sidebar compacto quando width <= 1250px */
    @media (max-width: 1250px) {
      .sidebar {
        width: 4rem;
        padding: 0.5rem;
        overflow-x: hidden;
      }

      .sidebar h2 {
        display: none;
      }

      .element-btn {
        justify-content: center;
        padding: 0.5rem;
        position: relative;
        min-height: auto;
      }

      .element-btn span {
        display: none;
      }

      .element-icon {
        margin: 0 auto;
        width: 1.5rem;
        height: 1.5rem;
        font-size: 0.875rem;
        flex-shrink: 0;
      }

      .element-icon svg,
      .element-icon svg * {
        width: 1.1rem !important;
        height: 1.1rem !important;
        max-width: 1.1rem !important;
        max-height: 1.1rem !important;
      }

      /* Ajustar SVGs específicos que podem ter tamanhos inline */
      .element-icon svg[width],
      .element-icon svg[height] {
        width: 1.1rem !important;
        height: 1.1rem !important;
      }

      .info-box {
        display: none;
      }

      /* Tooltip para mostrar nome do elemento no hover */
      .element-btn::after {
        content: attr(data-tooltip);
        position: absolute;
        left: calc(100% + 0.5rem);
        top: 50%;
        transform: translateY(-50%);
        background: var(--bg-secondary);
        color: var(--text-primary);
        padding: 0.5rem 0.75rem;
        border-radius: 0.375rem;
        font-size: 0.875rem;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s;
        z-index: 1000;
        box-shadow: 0 4px 6px var(--shadow);
        border: 1px solid var(--border-color);
      }

      .element-btn:hover::after {
        opacity: 1;
      }

      /* Ajustar canvas area para compensar sidebar menor */
      .canvas-area {
        flex: 1;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <div class="header-top">
        <div class="header-left">
          <div style="width: 80px; height: 80px; flex-shrink: 0;">
            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="275 140 520 895" width="80" height="80" style="display: block;" preserveAspectRatio="xMidYMid meet"><path fill="#FAFCFD" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M429.856 175.351C418.007 175.432 404.43 175.416 404.944 159.07C405.484 141.893 422.09 143.81 434.299 143.762L462.99 143.652L517.68 143.603C528.367 143.614 547.719 142.342 558.044 145.905C562.78 147.539 567.098 156.604 566.161 161.238C564.544 176.41 551.928 175.61 540.846 175.464L541.071 289.871L541.09 290.79L541.599 298.698C549.781 334.269 571.643 334.734 597.759 353.88C637.448 382.975 665.192 425.553 675.654 473.704C683.657 509.401 681.974 551.694 668.473 585.908C664.923 598.03 655.577 615.556 648.725 626.174C621.109 668.968 578.565 700.686 528.825 711.995C478.018 723.695 424.641 714.421 380.757 686.27C296.788 633.389 268.514 522.834 308.574 433.819C311.231 427.916 314.317 421.553 317.763 416.086C319.912 411.662 324.518 405.023 327.473 400.914C343.217 379.026 362.794 359.841 385.829 345.722C395.491 339.381 406.668 336.056 414.968 327.799C431.373 311.478 429.417 292.631 429.542 271.735C429.73 257.414 429.794 243.092 429.735 228.77C429.696 211.184 429.304 192.853 429.856 175.351Z"/><defs><linearGradient id="gradient_0" gradientUnits="userSpaceOnUse" x1="489.79175" y1="506.99503" x2="566.86169" y2="280.49115"><stop offset="0" stop-color="#217597"/><stop offset="1" stop-color="#2ECAC1"/></linearGradient></defs><path fill="url(#gradient_0)" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M429.856 175.351C418.007 175.432 404.43 175.416 404.944 159.07C405.484 141.893 422.09 143.81 434.299 143.762L462.99 143.652L517.68 143.603C528.367 143.614 547.719 142.342 558.044 145.905C562.78 147.539 567.098 156.604 566.161 161.238C564.544 176.41 551.928 175.61 540.846 175.464L541.071 289.871L541.09 290.79L541.599 298.698C549.781 334.269 571.643 334.734 597.759 353.88C637.448 382.975 665.192 425.553 675.654 473.704C683.657 509.401 681.974 551.694 668.473 585.908C667.678 582.355 673.475 567.059 674.517 562.468C674.612 562.301 674.706 562.134 674.8 561.967C674.419 559.733 675.704 558.58 675.331 555.729C668.886 549.775 650.631 564.362 640.911 558.524L640.529 558.389C641.393 565.132 638.318 574.807 636.216 581.119L635.876 580.854C635.808 578.539 637.764 573.599 638.781 571.401C636.779 569.559 624.561 570.497 621.025 570.576C620.976 573.539 621.087 579.926 620.303 582.444C620.193 585.986 620.174 589.53 620.247 593.073C613.502 593.441 595.173 593.812 588.728 593.123L588.709 590.808C588.766 583.669 588.741 576.529 588.634 569.39C588.302 566.645 588.539 564.098 588.698 561.349L588.726 545.882L588.626 542.957L588.704 536.36C587.883 528.39 588.405 513.05 588.494 504.625L588.478 489.501L588.365 448.866C588.293 440.366 587.911 428.185 588.583 419.93C577.994 408.398 566.234 397.477 555.248 386.291C551.774 382.753 547.97 379.115 544.259 375.849C529.468 375.036 506.392 375.84 490.922 375.852C452.864 376.05 414.805 375.897 376.749 375.392C376.66 386.484 376.647 397.577 376.71 408.669C375.986 405.454 376.646 401.455 375.971 399.077L375.566 400.928L374.909 401.105C373.762 400.122 373.893 400.055 373.456 398.564C369.087 399.004 359.215 410.786 356.752 413.838C353.31 418.103 338.846 442.021 337.704 446.541L337.115 446.674C337.301 443.544 339.488 443.014 339.333 440.65C338.251 440.132 332.711 437.554 332.161 436.996C326.178 430.942 317.403 425.528 317.763 416.086C319.912 411.662 324.518 405.023 327.473 400.914C343.217 379.026 362.794 359.841 385.829 345.722C395.491 339.381 406.668 336.056 414.968 327.799C431.373 311.478 429.417 292.631 429.542 271.735C429.73 257.414 429.794 243.092 429.735 228.77C429.696 211.184 429.304 192.853 429.856 175.351Z"/><defs><linearGradient id="gradient_1" gradientUnits="userSpaceOnUse" x1="458.75131" y1="272.79367" x2="499.2218" y2="129.75377"><stop offset="0" stop-color="#2CC3BF"/><stop offset="1" stop-color="#30F1D6"/></linearGradient></defs><path fill="url(#gradient_1)" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M429.856 175.351C418.007 175.432 404.43 175.416 404.944 159.07C405.484 141.893 422.09 143.81 434.299 143.762L462.99 143.652L517.68 143.603C528.367 143.614 547.719 142.342 558.044 145.905C562.78 147.539 567.098 156.604 566.161 161.238C564.544 176.41 551.928 175.61 540.846 175.464L541.071 289.871L540.803 290.55C539.464 291.332 537.557 293.551 536.374 294.753L535.573 294.666C533.261 285.471 525.132 293.801 519.855 285.866C519.807 285.793 504.567 284.439 504.049 278.043C503.277 278.664 503.625 278.345 503.343 279.705C502.163 280.053 497.126 277.134 495.599 276.454C486.748 272.508 477.392 272.316 468.959 267.098C463.583 263.771 460.534 258.462 455.54 255.211C448.421 250.577 439.35 248.487 433.779 241.464C430.145 237.092 432.025 232.523 429.735 228.77C429.696 211.184 429.304 192.853 429.856 175.351Z"/><path fill="#49C3D2" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M588.583 419.93C589.106 428.132 588.684 439.182 588.741 447.631C598.691 447.591 610.294 447.288 620.128 447.559C620.16 455.664 620.15 463.769 620.1 471.874C625.738 471.841 636.634 471.029 641.168 472.709C642.428 474.046 642.028 473.732 642.301 475.988C642.353 478.666 642.272 494.08 643.046 495.345L643.956 495.557C644.899 495.78 645.164 495.848 646.063 496.272C646.162 497.567 646.347 497.02 645.831 498.049C645.105 498.247 643.052 498.633 642.953 499.072C642.038 503.134 642.235 515.473 642.405 519.485C645.008 519.763 644.758 519.322 646.433 520.707C645.749 522.605 644.315 522.338 642.471 522.429C642.423 525.807 641.79 540.944 643.059 542.754L644.043 542.985C645.483 543.74 645.596 543.48 646.161 544.662C644.277 546.446 642.594 545.533 642.369 548.189C642.122 551.097 643.246 556.333 640.911 558.524L640.529 558.389C641.393 565.132 638.318 574.807 636.216 581.119L635.876 580.854C635.808 578.539 637.764 573.599 638.781 571.401C636.779 569.559 624.561 570.497 621.025 570.576C620.976 573.539 621.087 579.926 620.303 582.444C620.193 585.986 620.174 589.53 620.247 593.073C613.502 593.441 595.173 593.812 588.728 593.123L588.709 590.808C588.766 583.669 588.741 576.529 588.634 569.39C588.302 566.645 588.539 564.098 588.698 561.349L588.726 545.882L588.626 542.957L588.704 536.36C587.883 528.39 588.405 513.05 588.494 504.625L588.478 489.501L588.365 448.866C588.293 440.366 587.911 428.185 588.583 419.93Z"/><defs><linearGradient id="gradient_2" gradientUnits="userSpaceOnUse" x1="628.013" y1="485.62463" x2="591.10583" y2="446.87042"><stop offset="0" stop-color="#41BCC9"/><stop offset="1" stop-color="#5EDDE0"/></linearGradient></defs><path fill="url(#gradient_2)" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M588.583 419.93C589.106 428.132 588.684 439.182 588.741 447.631C598.691 447.591 610.294 447.288 620.128 447.559C620.16 455.664 620.15 463.769 620.1 471.874C625.738 471.841 636.634 471.029 641.168 472.709C642.428 474.046 642.028 473.732 642.301 475.988L639.824 474.401C634.314 474.938 625.989 474.758 620.223 474.777C620.211 481.387 620.334 488.481 620.171 495.048C618.998 494.668 618.819 494.859 617.458 494.995C617.138 488.542 617.283 480.966 617.265 474.421C612.291 473.858 602.744 474.157 597.437 474.221C597.513 478.984 597.693 483.816 597.294 488.557C597.117 484.13 597.026 479.7 597.02 475.27L596.257 475.453C595.795 479.348 595.909 485.766 595.862 489.867C595.804 486.94 595.863 476.921 595.358 474.739C592.834 474.468 591.328 474.517 588.836 474.585C588.84 479.4 588.936 484.606 588.837 489.39L588.478 489.501L588.365 448.866C588.293 440.366 587.911 428.185 588.583 419.93Z"/><path fill="#2487A1" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M588.799 450.03C598.307 450.13 607.816 450.182 617.324 450.186L617.318 471.732L597.954 471.769C598.018 468.467 598.368 454.939 597.18 452.839L596.269 452.752C593.869 456.002 596.84 469.357 594.716 471.721C592.633 471.881 591.614 472.116 589.643 471.57C588.028 469.311 588.813 453.9 588.799 450.03Z"/><path fill="#25719C" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M588.634 569.39L594.985 569.319C594.986 573.137 594.567 581.3 596.339 584.359L596.98 584.022C598.374 579.388 598.066 574.496 598.045 569.652C604.356 569.641 610.985 569.529 617.268 569.658L617.352 590.488C607.566 590.858 598.288 590.547 588.709 590.808C588.766 583.669 588.741 576.529 588.634 569.39Z"/><path fill="#25719C" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M598.02 498.471L617.416 498.448C617.367 502.362 617.342 506.276 617.342 510.19C617.909 513.879 617.562 519.401 618.178 521.997L617.663 522.355C611.124 522.396 604.585 522.355 598.047 522.232L595.118 522.003C592.954 522.032 591.2 521.739 589.581 522.988C587.696 526.03 589.001 531.428 588.704 536.36C587.883 528.39 588.405 513.05 588.494 504.625L588.848 504.734C588.926 509.029 587.737 516.279 589.668 518.695C591.286 519.709 593.371 519.344 595.363 519.272L597.99 519.417C598.196 512.758 598.021 505.201 598.02 498.471Z"/><path fill="#49C3D2" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M588.494 504.625L588.848 504.734C588.926 509.029 587.737 516.279 589.668 518.695C591.286 519.709 593.371 519.344 595.363 519.272L597.99 519.417C601.278 518.952 613.285 519.112 617.225 519.084L617.342 510.19C617.909 513.879 617.562 519.401 618.178 521.997L617.663 522.355C611.124 522.396 604.585 522.355 598.047 522.232L595.118 522.003C592.954 522.032 591.2 521.739 589.581 522.988C587.696 526.03 589.001 531.428 588.704 536.36C587.883 528.39 588.405 513.05 588.494 504.625Z"/><path fill="#25719C" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M620.201 546.105L639.817 546.098C639.814 550.038 639.638 554.626 640.529 558.389C641.393 565.132 638.318 574.807 636.216 581.119L635.876 580.854C635.808 578.539 637.764 573.599 638.781 571.401C636.779 569.559 624.561 570.497 621.025 570.576C620.976 573.539 621.087 579.926 620.303 582.444L620.085 569.626C624.727 569.591 632.736 569.819 636.894 568.463L637.149 567.835C633.541 566.22 624.425 566.717 620.154 566.761C620.123 559.875 620.139 552.99 620.201 546.105Z"/><path fill="#25719C" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M620.223 474.777C625.989 474.758 634.314 474.938 639.824 474.401L639.691 495.423C636.741 495.448 622.331 495.777 620.171 495.048C620.334 488.481 620.211 481.387 620.223 474.777Z"/><path fill="#25719C" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M598.047 522.232C604.585 522.355 611.124 522.396 617.663 522.355C616.869 525.802 617.253 538.941 617.297 542.959C610.979 543.071 604.352 542.96 598.009 542.948L598.047 522.232Z"/><path fill="#25719C" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M598.116 474.789C603.853 474.77 611.731 474.931 617.265 474.421C617.283 480.966 617.138 488.542 617.458 494.995C614.444 495.787 601.776 495.238 598.053 495.121C598.181 488.419 598.106 481.508 598.116 474.789Z"/><path fill="#25719C" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M588.726 545.882C590.783 545.907 592.966 545.981 595.009 545.862C595.191 552.907 595.211 559.957 595.068 567.003C593.149 567.105 590.913 567.519 589.375 566.554C588.533 565.087 588.722 563.115 588.698 561.349L588.726 545.882Z"/><path fill="#25719C" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M588.848 504.734C588.814 502.721 588.457 500.474 589.578 498.937C591.194 498.043 593.228 498.225 595.133 498.181C595.188 505.03 595.118 512.463 595.363 519.272C593.371 519.344 591.286 519.709 589.668 518.695C587.737 516.279 588.926 509.029 588.848 504.734Z"/><path fill="#25719C" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M588.704 536.36C589.001 531.428 587.696 526.03 589.581 522.988C591.2 521.739 592.954 522.032 595.118 522.003C595.169 528.804 595.363 536.25 595.043 542.984L588.626 542.957L588.704 536.36Z"/><path fill="#25719C" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M588.836 474.585C591.328 474.517 592.834 474.468 595.358 474.739C594.905 480.68 595.17 489.056 595.258 495.172C593.252 495.289 591.218 495.691 589.544 494.723C588.493 493.167 588.796 491.333 588.837 489.39C588.936 484.606 588.84 479.4 588.836 474.585Z"/><path fill="#25719C" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M620.193 498.465L639.71 498.597C639.894 505.404 639.821 512.45 639.83 519.279L620.254 519.141L620.193 498.465Z"/><path fill="#25719C" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M620.296 522.429C626.822 522.327 633.349 522.271 639.875 522.263C639.927 529.098 639.806 536.074 639.754 542.922L620.23 542.913L620.296 522.429Z"/><path fill="#25719C" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M598.09 546.075L617.282 546.047L617.332 566.747C611.47 567.026 604.038 566.803 598.062 566.776L598.09 546.075Z"/><path fill="#25719C" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M642.471 522.429C644.33 522.63 645.349 522.361 646.375 523.382C646.749 526.899 646.591 539.387 645.185 542.317L644.043 542.985L643.059 542.754C641.79 540.944 642.423 525.807 642.471 522.429Z"/><path fill="#25719C" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M642.405 519.485C642.235 515.473 642.038 503.134 642.953 499.072C643.052 498.633 645.105 498.247 645.831 498.049C645.927 501.838 646.949 516.637 645.761 518.847C644.635 519.082 643.545 519.328 642.405 519.485Z"/><path fill="#57E0E3" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M541.599 298.698C541.392 299.306 541.555 298.933 540.971 299.744C538.929 297.26 539.123 293.191 541.09 290.79L541.599 298.698Z"/><defs><linearGradient id="gradient_3" gradientUnits="userSpaceOnUse" x1="413.8266" y1="702.08923" x2="510.21185" y2="452.74323"><stop offset="0" stop-color="#18276F"/><stop offset="1" stop-color="#23839F"/></linearGradient></defs><path fill="url(#gradient_3)" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M317.763 416.086C317.403 425.528 326.178 430.942 332.161 436.996C332.711 437.554 338.251 440.132 339.333 440.65C339.488 443.014 337.301 443.544 337.115 446.674L337.704 446.541C338.846 442.021 353.31 418.103 356.752 413.838C359.215 410.786 369.087 399.004 373.456 398.564C373.893 400.055 373.762 400.122 374.909 401.105L375.566 400.928L375.971 399.077C376.646 401.455 375.986 405.454 376.71 408.669L376.792 463.801C376.797 472.991 377.187 485.826 376.733 494.791C377.619 521.945 376.335 549.646 376.882 576.847C376.977 581.587 376.994 586.758 376.802 591.492L376.922 593.504L376.889 596.278C376.773 611.238 376.814 626.198 377.014 641.157C383.338 641.407 389.881 641.245 396.226 641.296C460.307 641.813 524.589 640.64 588.646 641.319C589.177 625.439 588.239 609.125 588.728 593.123C595.173 593.812 613.502 593.441 620.247 593.073C620.174 589.53 620.193 585.986 620.303 582.444C621.087 579.926 620.976 573.539 621.025 570.576C624.561 570.497 636.779 569.559 638.781 571.401C637.764 573.599 635.808 578.539 635.876 580.854L636.216 581.119C638.318 574.807 641.393 565.132 640.529 558.389L640.911 558.524C650.631 564.362 668.886 549.775 675.331 555.729C675.704 558.58 674.419 559.733 674.8 561.967C674.706 562.134 674.612 562.301 674.517 562.468C673.475 567.059 667.678 582.355 668.473 585.908C664.923 598.03 655.577 615.556 648.725 626.174C621.109 668.968 578.565 700.686 528.825 711.995C478.018 723.695 424.641 714.421 380.757 686.27C296.788 633.389 268.514 522.834 308.574 433.819C311.231 427.916 314.317 421.553 317.763 416.086Z"/><path fill="#49C3D2" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M376.922 593.504L376.889 596.278C373.192 596.309 353.158 597.018 351.001 595.969L350.807 595.181C353.653 593.22 372.578 593.588 376.922 593.504Z"/><path fill="#49C3D2" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M376.596 497.305C374.239 497.425 371.273 498.052 369.66 496.131L370.216 495.334C372.404 494.273 374.243 494.658 376.733 494.791C377.619 521.945 376.335 549.646 376.882 576.847C376.977 581.587 376.994 586.758 376.802 591.492C376.053 586.437 376.436 565.389 376.45 559.403L376.596 497.305Z"/><path fill="#49C3D2" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M333.136 531.333C337.453 531.097 359.66 531.071 362.635 532.457L362.673 533.482C358.556 534.053 338.068 534.202 333.77 533.882C332.685 532.743 333.09 533.446 333.136 531.333Z"/><path fill="#49C3D2" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M347.622 442.124C351.914 441.89 368.04 441.374 371.239 442.416C371.748 443.827 371.706 443.099 371.142 444.674C366.38 444.486 350.151 445.266 346.955 443.9L346.689 442.907L347.622 442.124Z"/><defs><linearGradient id="gradient_4" gradientUnits="userSpaceOnUse" x1="468.72772" y1="631.01733" x2="575.09564" y2="402.43958"><stop offset="0" stop-color="#1A3875"/><stop offset="1" stop-color="#2B9DAA"/></linearGradient></defs><path fill="url(#gradient_4)" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M470.797 383.08C492.946 383.205 515.096 383.184 537.244 383.016C537.237 386.203 537.366 390.664 537.174 393.748C537.218 402.164 537.2 410.581 537.121 418.997L537.317 426.171C551.886 426.351 566.594 426.027 581.129 426.349L581.171 634.081C545.454 634.179 508.722 633.634 473.115 634.204L468.248 634.122C457.204 634.925 436.856 634.075 425.153 634.234C415.874 634.359 392.775 634.814 384.309 633.981C384.777 622.9 384.223 608.141 384.18 596.652C383.955 586.434 384.004 571.472 384.225 561.249L384.216 550.741C383.962 546.346 383.936 540.775 384.09 536.329C385.012 509.602 382.924 481.028 384.528 454.521C384.42 440.945 384.17 428.079 384.464 414.496L384.543 412.475C384.652 402.757 384.327 392.929 384.416 383.154C396.284 382.919 408.748 383.109 420.671 383.091L424.08 383.099C438.298 383.181 454.07 383.515 468.22 383.086L470.797 383.08Z"/><defs><linearGradient id="gradient_5" gradientUnits="userSpaceOnUse" x1="405.44955" y1="599.94165" x2="446.71878" y2="490.88556"><stop offset="0" stop-color="#1B3E79"/><stop offset="1" stop-color="#226A91"/></linearGradient></defs><path fill="url(#gradient_5)" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M384.216 550.741C383.962 546.346 383.936 540.775 384.09 536.329C385.012 509.602 382.924 481.028 384.528 454.521C385.155 467.552 384.419 481.582 384.645 494.701C396.671 494.599 408.697 494.557 420.723 494.576C420.676 489.188 420.113 479.527 421.843 474.738L422.463 474.455C424.435 478.481 423.813 489.724 423.758 494.64L452.348 494.656C456.446 494.661 463.821 494.482 467.765 494.823L467.472 496.023C468.449 497.577 467.776 496.957 469.813 497.631L470.76 497.229L470.844 497.549L470.828 563.285C470.826 568.494 470.417 589.865 470.94 593.739L470.502 596.577C471.199 604.908 470.719 614.401 470.94 622.829C471.007 625.378 470.665 631.137 471.065 633.405C471.904 633.773 472.236 633.945 473.115 634.204L468.248 634.122C457.204 634.925 436.856 634.075 425.153 634.234C415.874 634.359 392.775 634.814 384.309 633.981C384.777 622.9 384.223 608.141 384.18 596.652C383.955 586.434 384.004 571.472 384.225 561.249L384.216 550.741Z"/><path fill="#1B3F78" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M421.116 596.572L424.163 596.651C438.73 596.344 453.702 596.64 468.333 596.568L468.403 606.239C468.343 610.579 468.749 630.664 468.371 633.792L468.248 634.122C457.204 634.925 436.856 634.075 425.153 634.234C415.874 634.359 392.775 634.814 384.309 633.981C384.777 622.9 384.223 608.141 384.18 596.652C387.321 596.331 393.421 596.539 396.833 596.545L421.116 596.572Z"/><path fill="#1B3F78" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M384.18 596.652C387.321 596.331 393.421 596.539 396.833 596.545L421.116 596.572C421.163 608.222 421.546 622.358 421.032 633.869C410.378 633.798 394.672 633.223 384.309 633.981C384.777 622.9 384.223 608.141 384.18 596.652Z"/><path fill="#48ACC9" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M421.116 596.572L424.163 596.651C424.142 609.033 424.367 621.588 424.238 633.932C438.385 633.813 454.495 634.226 468.371 633.792L468.248 634.122C457.204 634.925 436.856 634.075 425.153 634.234C415.874 634.359 392.775 634.814 384.309 633.981C394.672 633.223 410.378 633.798 421.032 633.869C421.546 622.358 421.163 608.222 421.116 596.572Z"/><path fill="#49C3D2" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M384.216 550.741C383.962 546.346 383.936 540.775 384.09 536.329C385.012 509.602 382.924 481.028 384.528 454.521C385.155 467.552 384.419 481.582 384.645 494.701C396.671 494.599 408.697 494.557 420.723 494.576C420.676 489.188 420.113 479.527 421.843 474.738L422.463 474.455C424.435 478.481 423.813 489.724 423.758 494.64L452.348 494.656C456.446 494.661 463.821 494.482 467.765 494.823L467.472 496.023C468.449 497.577 467.776 496.957 469.813 497.631L470.76 497.229L470.844 497.549L470.828 563.285C470.826 568.494 470.417 589.865 470.94 593.739L470.502 596.577C471.199 604.908 470.719 614.401 470.94 622.829C471.007 625.378 470.665 631.137 471.065 633.405C471.904 633.773 472.236 633.945 473.115 634.204L468.248 634.122L468.371 633.792C468.749 630.664 468.343 610.579 468.403 606.239C469.882 604.308 469.066 589.813 468.307 586.992C467.844 578.802 468.214 565.883 468.219 557.431C468.36 537.489 468.338 517.545 468.155 497.603L423.773 497.593C423.834 502.231 424.222 508.186 422.819 512.495L422.18 512.748C420.324 509.498 420.731 501.506 420.735 497.508C408.604 497.686 396.471 497.626 384.342 497.329C384.896 511.677 385.001 536.349 384.216 550.741Z"/><path fill="#48ACC9" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M384.225 561.249C385.118 570.412 384.686 584.36 384.613 593.899L421.215 593.691C421.126 588.765 420.531 580.372 422.154 575.988L422.838 575.936C424.564 579.958 424.095 588.938 424.133 593.634C437.18 594.152 455.049 593.99 468.283 593.717L468.307 586.992C469.066 589.813 469.882 604.308 468.403 606.239L468.333 596.568C453.702 596.64 438.73 596.344 424.163 596.651L421.116 596.572L396.833 596.545C393.421 596.539 387.321 596.331 384.18 596.652C383.955 586.434 384.004 571.472 384.225 561.249Z"/><path fill="#FAFCFD" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M404.763 541.69C415.533 541.812 426.304 541.853 437.075 541.814L437.089 571.65C426.302 571.816 415.513 571.743 404.729 571.43C404.547 561.517 404.558 551.602 404.763 541.69Z"/><path fill="#1B3F78" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M410.027 547.042L431.524 546.967L431.589 566.225L410.015 566.228C410.131 559.833 410.135 553.437 410.027 547.042Z"/><defs><linearGradient id="gradient_6" gradientUnits="userSpaceOnUse" x1="412.84955" y1="501.15778" x2="439.28961" y2="407.85077"><stop offset="0" stop-color="#20618A"/><stop offset="1" stop-color="#24859D"/></linearGradient></defs><path fill="url(#gradient_6)" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M420.671 383.091L424.08 383.099C424.164 392.903 424.064 402.708 423.778 412.509L431.332 412.553L430.802 412.671C428.203 413.23 426.375 413.39 423.739 413.638L423.523 413.088L422.068 413.519L422.312 413.417L422.698 413.839L422.881 413.357L423.19 413.909L423.47 413.361L423.691 413.955L424.025 413.405C426.759 413.654 428.68 413.75 431.355 414.508C443.414 414.688 456.306 414.233 468.126 414.597L468.239 469.583C468.246 473.54 468.538 492.066 467.765 494.823C463.821 494.482 456.446 494.661 452.348 494.656L423.758 494.64C423.813 489.724 424.435 478.481 422.463 474.455L421.843 474.738C420.113 479.527 420.676 489.188 420.723 494.576C408.697 494.557 396.671 494.599 384.645 494.701C384.419 481.582 385.155 467.552 384.528 454.521C384.42 440.945 384.17 428.079 384.464 414.496L384.543 412.475C384.652 402.757 384.327 392.929 384.416 383.154C396.284 382.919 408.748 383.109 420.671 383.091Z"/><path fill="#2487A1" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M420.671 383.091L424.08 383.099C424.164 392.903 424.064 402.708 423.778 412.509L431.332 412.553L430.802 412.671C428.203 413.23 426.375 413.39 423.739 413.638L423.523 413.088L422.068 413.519L422.312 413.417L422.698 413.839L422.881 413.357L423.19 413.909L423.47 413.361L423.691 413.955L424.025 413.405C426.759 413.654 428.68 413.75 431.355 414.508L423.841 414.662L421.086 414.71C418.311 414.512 414.667 414.575 411.816 414.544C402.699 414.598 393.581 414.582 384.464 414.496L384.543 412.475C384.652 402.757 384.327 392.929 384.416 383.154C396.284 382.919 408.748 383.109 420.671 383.091Z"/><path fill="#49C3D2" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M420.671 383.091L424.08 383.099C424.164 392.903 424.064 402.708 423.778 412.509L431.332 412.553L430.802 412.671C428.203 413.23 426.375 413.39 423.739 413.638L423.523 413.088L422.068 413.519L422.312 413.417L422.698 413.839L422.881 413.357L423.19 413.909L423.47 413.361L423.691 413.955L424.025 413.405C426.759 413.654 428.68 413.75 431.355 414.508L423.841 414.662L421.086 414.71C418.311 414.512 414.667 414.575 411.816 414.544C414.137 413.93 417.559 413.455 419.97 413.756C419.286 413.25 417.284 413.222 415.9 412.836L414.961 412.568L421.275 412.417C421.205 403.363 421.376 391.996 420.671 383.091Z"/><path fill="#57E0E3" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M384.543 412.475C394.188 412.467 405.443 412.174 414.961 412.568L415.9 412.836C417.284 413.222 419.286 413.25 419.97 413.756C417.559 413.455 414.137 413.93 411.816 414.544C402.699 414.598 393.581 414.582 384.464 414.496L384.543 412.475Z"/><path fill="#49C3D2" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M421.086 414.71L423.841 414.662C423.866 418.297 424.434 430.89 422.397 433.232C420.482 431.125 421.055 418.132 421.086 414.71Z"/><path fill="#FAFCFD" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M404.438 439.853C415.134 439.623 425.819 439.949 436.59 439.634C436.727 449.983 436.754 460.333 436.672 470.683C425.935 470.539 415.133 470.928 404.412 470.376C404.308 460.202 404.317 450.027 404.438 439.853Z"/><path fill="#25719C" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M409.941 445.294C416.985 445.386 424.159 445.322 431.215 445.329C431.085 451.838 431.18 458.606 431.185 465.136L409.885 465.111L409.941 445.294Z"/><path fill="#2487A1" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M424.08 383.099C438.298 383.181 454.07 383.515 468.22 383.086C468.482 392.722 467.912 402.932 468.235 412.177C465.542 412.772 436.222 412.516 431.332 412.553L423.778 412.509C424.064 402.708 424.164 392.903 424.08 383.099Z"/><path fill="#49C3D2" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M468.126 414.597L470.733 414.756L470.687 466.731C470.68 474.109 470.352 487.732 470.969 494.588L470.76 497.229L469.813 497.631C467.776 496.957 468.449 497.577 467.472 496.023L467.765 494.823C468.538 492.066 468.246 473.54 468.239 469.583L468.126 414.597Z"/><path fill="#57E0E3" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M468.235 412.177C470.09 411.994 469.329 411.751 470.822 412.41C479.001 412.536 488.092 412.286 496.099 412.8L496.487 413.25C489.929 416.38 478.271 413.418 470.733 414.756L468.126 414.597C456.306 414.233 443.414 414.688 431.355 414.508C428.68 413.75 426.759 413.654 424.025 413.405L423.691 413.955L423.47 413.361L423.19 413.909L422.881 413.357L422.698 413.839L422.312 413.417L422.068 413.519L423.523 413.088L423.739 413.638C426.375 413.39 428.203 413.23 430.802 412.671L431.332 412.553C436.222 412.516 465.542 412.772 468.235 412.177Z"/><path fill="#49C3D2" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M468.22 383.086L470.797 383.08C470.722 392.856 470.73 402.633 470.822 412.41C469.329 411.751 470.09 411.994 468.235 412.177C467.912 402.932 468.482 392.722 468.22 383.086Z"/><path fill="#49C3D2" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M470.969 494.588C475.485 494.619 484.878 494.279 488.715 495.914L488.484 496.505C483.918 497.878 475.851 497.564 470.844 497.549L470.76 497.229L470.969 494.588Z"/><path fill="#48ACC9" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M470.94 593.739C475.118 593.737 483.411 593.335 486.887 595.076L486.659 595.638C482.002 597.115 475.492 596.695 470.502 596.577L470.94 593.739Z"/><path fill="#48ACC9" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M537.121 418.997C536.13 416.02 536.667 412.433 536.107 409.444C534.862 402.792 531.317 399.308 537.174 393.748C537.218 402.164 537.2 410.581 537.121 418.997Z"/><path fill="#FAFCFD" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M495.427 579.048L560.959 579.098C561.093 591.787 561.102 604.476 560.986 617.165L495.477 617.162C495.394 604.289 495.217 591.928 495.427 579.048Z"/><path fill="#1B3F78" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M501.576 584.772C519.306 584.678 537.037 584.7 554.767 584.838L554.753 611.251C537.503 611.748 518.747 611.44 501.446 611.197L501.576 584.772Z"/><path fill="#FAFCFD" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M496.544 491.94C508.566 492.079 520.503 491.89 532.549 492.155L532.613 521.747L496.537 521.706C496.462 511.784 496.464 501.862 496.544 491.94Z"/><path fill="#25719C" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M502.058 497.57C510.216 497.769 518.713 497.664 526.898 497.674L526.847 515.995C518.617 516.071 510.387 515.965 502.162 515.678L502.058 497.57Z"/><path fill="#FAFCFD" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M494.674 541.962L539.548 541.96C544.023 541.97 556.717 541.69 560.454 542.288C561.256 543.962 560.98 546.223 560.943 548.152L494.821 548.126L494.674 541.962Z"/><path fill="#FAFCFD" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M494.548 557.845C503.007 557.811 555.289 556.645 560.671 558.23C561.419 560.216 561.093 561.792 560.942 563.94C545.963 563.152 529.825 564.052 514.768 563.783C510.715 563.711 498.144 564.198 495.101 563.3C494.191 561.609 494.482 559.804 494.548 557.845Z"/><path fill="#FAFCFD" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M496.543 453.779L560.768 453.761L560.801 459.814L519.918 459.936C513.75 459.942 502.782 460.259 496.95 459.699C496.199 458.185 496.5 455.579 496.543 453.779Z"/><path fill="#FAFCFD" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M496.704 468.988C517.626 469.47 539.461 469.147 560.479 469.129C560.671 471.049 560.762 473.148 560.887 475.088C545.528 474.622 529.742 475.203 514.366 475.034C511.111 474.998 499.235 475.377 496.822 474.797C496.178 473.096 496.562 470.87 496.704 468.988Z"/><path fill="#FAFCFD" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M497.226 438.505C507.942 438.45 521.032 438.011 531.53 438.515C532.545 440.02 532.298 442.395 532.009 444.166L531.118 444.519C519.539 444.566 507.959 444.536 496.381 444.428C496.219 442.373 495.79 440.014 497.226 438.505Z"/>              <path fill="#F47819" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M544.474 385.961C545.766 386.931 554.418 395.627 555.715 397.002C561.922 403.585 571.233 411.799 576.726 418.717C566.075 419.392 555.563 419.337 544.905 419.348C544.419 408.501 544.504 396.866 544.474 385.961Z"/><path class="text_lab" fill="#0A1B47" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M406.556 783.466C411.835 783.423 417.017 783.35 422.297 783.545C422.936 791.824 422.452 807.394 422.467 816.451C441.809 794.451 475.365 813.051 475.492 839.683C475.551 851.995 473.373 859.204 465.142 868.384C453.078 878.775 432.342 880.973 422.084 867.143C422.016 869.824 422.121 872.825 422.163 875.536L402.581 875.562C403.519 851.298 402.068 826.153 402.692 801.806C402.844 795.841 402.645 790.316 403.2 784.326C404.082 783.321 404.738 783.635 406.556 783.466ZM440.92 859.81C461.912 854.846 458.798 822.965 436.538 824.097C414.833 828.381 418.199 860.993 440.92 859.81Z"/><path fill="#f47819" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M598.853 796.373C605.958 796.281 613.133 796.366 620.333 796.382C650.651 796.449 668.022 827.925 655.017 854.393C652.411 859.697 648.829 863.041 644.306 866.964C628.912 878.378 610.157 874.823 591.319 875.327C590.491 849.821 591.485 822.476 591.133 796.583L598.853 796.373ZM599.387 867.236C615.139 867.215 630.058 869.416 641.881 857.974C653.748 844.863 653.973 825.071 641.002 812.575C630.138 802.108 613.637 803.882 599.608 803.975L599.6 845.522C599.597 850.916 599.888 862.086 599.387 867.236Z"/><path class="text_lab" fill="#0A1B47" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M349.665 807.634C360.131 806.541 370.874 807.45 378.915 814.917C388.914 824.2 387.204 839.547 387.211 851.925C387.188 859.761 387.231 867.598 387.341 875.433L367.738 875.428L367.607 868.407C358.123 878.835 342.331 879.404 331.003 871.653C327.045 867.921 324.415 863.465 324.174 858.056C323.078 833.46 347.71 835.971 364.699 836.2C366.055 836.218 366.739 835.88 367.495 834.906C367.422 833.458 367.167 831.199 366.367 829.975C359.069 818.819 343.213 824.647 334.071 829.346C332.429 824.538 330.197 819.806 328.005 815.228C334.615 810.845 341.892 808.714 349.665 807.634ZM359.414 862.287C366.925 858.622 368.001 855.387 367.534 847.397C362.01 847.244 355.661 847.023 350.145 847.316C335.736 851.24 343.855 866.127 359.414 862.287Z"/><path fill="#f47819" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M519.601 796.316C529.198 795.811 540.339 795.859 549.918 796.197C585.542 797.455 586.619 844.772 549.235 847.526L527.474 847.58L527.517 875.217L519.372 875.223C518.936 866.516 518.06 800.806 519.601 796.316ZM527.58 840.013C539.201 839.723 554.618 841.737 563.423 834.523C569.752 827.304 570.464 814.213 562.384 808.191C553.329 801.444 538.441 804.798 527.773 804.15C526.899 814.515 527.749 829.26 527.58 840.013Z"/><path class="text_lab" fill="#0A1B47" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M256.248 788.601C262.113 788.571 267.745 788.531 273.609 788.767C274.036 795.992 273.772 805.476 273.784 812.97L273.811 858.537C286.302 858.051 306.003 857.364 318.195 858.513C318.541 861.5 319.121 873.034 318.012 875.295L316.703 875.503C296.672 875.499 273.295 874.966 253.505 875.905L253.576 809.456C253.579 806.318 253.144 790.482 254.203 788.866L256.248 788.601Z"/><path fill="#f47819" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M675.53 796.335C690.05 795.718 715.012 795.704 729.502 796.256L729.478 804.218C714.661 803.817 699.235 803.933 684.371 803.85C684.372 812.874 684.236 822.293 684.678 831.273C697.267 831.175 711.952 830.773 724.368 831.329C724.467 833.664 724.197 836.998 724.074 839.407C710.906 839.432 697.738 839.36 684.571 839.19C684.755 851.146 684.617 863.485 684.635 875.472L675.832 875.493C675.419 864.46 675.73 852.606 675.763 841.506L675.53 796.335Z"/><path fill="#f47819" transform="matrix(1.08669 0 0 1.08712 0 -3.05176e-05)" d="M491.381 779.246C494.92 778.545 498.573 779.677 501.097 782.256C503.812 785.031 504.81 789.059 503.703 792.781C502.597 796.502 499.56 799.331 495.77 800.171C492.013 801.004 488.098 799.753 485.52 796.896C482.941 794.039 482.098 790.016 483.311 786.364C484.524 782.712 487.606 779.993 491.381 779.246Z"/></svg>
          </div> 
          <div>
            <h1>Lab PDF</h1>
            <p>Crie PDFs de forma visual e intuitiva</p>
          </div>
        </div>
        <div class="toolbar">
          <!-- V1 - Replicação com IA desabilitada
            <button class="btn" id="aiReplicateBtn" title="Replicar PDF com IA" style="display: flex; align-items: center; gap: 0.5rem; border-color: #e2574c; color: #e2574c; background: white;">
              <svg width="20px" height="20px" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.446 1.367c1.984 0.122 2.88 -0.042 3.505 -0.042 0.581 0 0.855 1.912 0.616 2.476 -0.225 0.532 -4.059 0.554 -4.237 0.343 -0.206 -0.244 -0.087 -1.262 -0.087 -1.612" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M2.458 4.767c-2.725 2.52 0.573 2.07 1.248 2.61" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M2.458 4.767c0.037 0.575 0.071 1.875 0.048 2.055" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M5.208 3.406v-0.321" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M4.432 3.432c-0.007 -0.085 0 -0.279 0 -0.347" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M5.085 6.043c3.717 -0.045 4.287 -0.375 2.728 2.503" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M7.139 8.636c-2.219 -0.09 -3.717 0.72 -2.683 -2.024" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M4.5 8.636c-0.481 -0.352 -1.018 -0.631 -1.484 -1.019" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M5.46 4.754c0.016 0.385 0.03 0.769 0.03 1.154" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M5.46 4.754c0.188 0.297 0.364 0.49 0.585 1.004" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M2.003 2.976c-0.113 0.03 -0.227 0.024 -0.342 0.034" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M1.49 2.737c0.002 0.207 0 0.411 -0.017 0.615" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M6.944 2.891c0.085 -0.009 0.171 -0.02 0.256 -0.034" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M7.285 2.617c0.024 0.136 0.017 0.273 0.017 0.41" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M5.644 2.912c-0.56 -0.062 -1.103 -0.032 -1.641 0.053" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/></svg>
              <span>Replicar com IA</span>
            </button>
            -->
          <div class="chip">
            <span>Formato</span>
            <select id="pageSize">
              <option value="A4" selected>A4</option>
              <option value="A3">A3</option>
              <option value="A5">A5</option>
              <option value="LETTER">LETTER</option>
              <option value="LEGAL">LEGAL</option>
              <option value="TABLOID">TABLOID</option>
            </select>
          </div>

          <div class="chip">
            <span>Orientação</span>
            <select id="orientation">
              <option value="portrait" selected>Retrato</option>
              <option value="landscape">Paisagem</option>
            </select>
          </div>

          <div class="chip" title="pageMargins: [left, top, right, bottom]">
            <span>Margens</span>
            <input id="mL" type="number" value="40" min="0" />
            <input id="mT" type="number" value="60" min="0" />
            <input id="mR" type="number" value="40" min="0" />
            <input id="mB" type="number" value="60" min="0" />
          </div>

          <!--<button class="btn primary" id="previewBtn">Pré-visualizar PDF</button>-->
          <button class="btn" id="loadTemplateBtn" title="Carregar template salvo">📂 Carregar Template</button>
          <button class="btn" id="bubbleTestBtn" title="Pré-visualizar PDF" style="display: none;">
            <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg"
              xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 20 20"
              style="enable-background:new 0 0 512 512;" xml:space="preserve" width="20" height="20">
              <path style="fill:#F4B2B0;" points="337.393,15.391 333.585,15.391 333.585,121.536 451.215,121.536 "
                d="M13.179 0.601h-0.149v4.146h4.595Z" />
              <path style="fill:#B3404A;"
                d="M17.725 7.949a0.6 0.6 0 0 0 -0.601 0.601v10.248H2.875V1.203h9.554v3.545c0 0.332 0.269 0.601 0.601 0.601h4.595a0.601 0.601 0 0 0 0.41 -1.041L13.589 0.161l-0.015 -0.012 -0.021 -0.018 -0.023 -0.017 -0.024 -0.017 -0.023 -0.014 -0.027 -0.015 -0.022 -0.011 -0.031 -0.014 -0.021 -0.008 -0.033 -0.011 -0.023 -0.006 -0.032 -0.008 -0.03 -0.005 -0.027 -0.004A0.667 0.667 0 0 0 13.179 0H2.275a0.6 0.6 0 0 0 -0.601 0.601v18.797c0 0.332 0.269 0.601 0.601 0.601h15.451a0.6 0.6 0 0 0 0.601 -0.601V8.55a0.6 0.6 0 0 0 -0.601 -0.601M13.632 4.147V1.845l2.467 2.301z" />
              <path style="fill:#F4B2B0;" cx="255.44" cy="270.754" r="98.532"
                d="M13.827 10.576a3.849 3.849 0 0 1 -3.849 3.849 3.849 3.849 0 0 1 -3.849 -3.849 3.849 3.849 0 0 1 7.698 0" />
              <g>
                <path style="fill:#B3404A;"
                  d="M9.978 15.025a4.44 4.44 0 0 1 -3.147 -1.301c-1.735 -1.735 -1.735 -4.559 0 -6.293s4.558 -1.735 6.293 0a4.453 4.453 0 0 1 0 6.293 4.44 4.44 0 0 1 -3.147 1.301m0 -7.694a3.24 3.24 0 0 0 -2.297 0.95c-1.266 1.266 -1.266 3.327 0 4.593s3.327 1.266 4.593 0a3.253 3.253 0 0 0 0 -4.593 3.24 3.24 0 0 0 -2.297 -0.95" />
                <path style="fill:#B3404A;"
                  d="M15.08 16.28a0.6 0.6 0 0 1 -0.425 -0.176l-2.381 -2.381a0.601 0.601 0 0 1 0.85 -0.85l2.381 2.381a0.6 0.6 0 0 1 0 0.85 0.6 0.6 0 0 1 -0.425 0.176" />
              </g>
            </svg>
          </button>
          <button id="darkModeToggle" class="dark-mode-toggle" title="Alternar modo escuro/claro">
            <svg id="sunIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
              stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: none;">
              <circle cx="12" cy="12" r="5"></circle>
              <line x1="12" y1="1" x2="12" y2="3"></line>
              <line x1="12" y1="21" x2="12" y2="23"></line>
              <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
              <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
              <line x1="1" y1="12" x2="3" y2="12"></line>
              <line x1="21" y1="12" x2="23" y2="12"></line>
              <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
              <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
            </svg>
            <svg id="moonIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
              stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
            </svg>
          </button>
        </div>
      </div>
    </div>

    <!-- Main Content -->
    <div class="main">
      <!-- Sidebar -->
      <div class="sidebar">
        <h2>Container</h2>
        <div class="elements-grid">
          <div class="element-btn" draggable="true" ondragstart="startDrag('group', event)" data-tooltip="Grupo">
            <div class="element-icon icon-group">
              <svg id="group-icon-template" width="25" height="25" viewBox="0 0 32 32">
                <path fill="#fff" d="M28 28H4a2 2 0 0 1-2-2v-5h2v5h24v-5h2v5a2 2 0 0 1-2 2" />
                <path fill="#fff" d="M7 21h18v2H7zm0-5h18v2H7zm0-5h18v2H7zm0-5h18v2H7z" />
              </svg>
            </div>
            <span>Grupo</span>
          </div>

          <div class="element-btn" draggable="true" ondragstart="startDrag('table', event)" data-tooltip="Tabela">
            <div class="element-icon icon-table">
              <div class="element-icon icon-table">
                <svg id="table-icon-template" width="24" height="24" viewBox="0 0 24 24">
                  <path fill="#fff" d="M11 16H3v5h8zm2 0v5h8v-5zm-2-2V9H3v5zm2 0h8V9h-8zM3 7h18V3H3z" />
                </svg>
              </div>
            </div>
            <span>Tabela</span>
          </div>

          <div class="element-btn" draggable="true" ondragstart="startDrag('columns', event)" data-tooltip="Colunas">
            <div class="element-icon icon-columns">
              <svg id="columns-icon-template" width="25" height="25" viewBox="0 0 24 24">
                <path fill="#fff" d="M3 19V5h5.325v14zm6.325 0V5h5.325v14zm6.325 0V5h5.325v14z" />
              </svg>
            </div>
            <span>Colunas</span>
          </div>
          <div class="element-btn" draggable="true" ondragstart="startDrag('list', event)" data-tooltip="Lista">
            <div class="element-icon icon-list">
              <div class="element-icon icon-list">
                <svg id="list-icon-template" width="24" height="24" viewBox="0 0 24 24">
                  <path fill="#fff"
                    d="M3 8h18V5.5q0-.625-.437-1.062T19.5 4h-15q-.625 0-1.062.438T3 5.5zm0 6h18v-4H3zm1.5 6h15q.625 0 1.063-.437T21 18.5V16H3v2.5q0 .625.438 1.063T4.5 20M5 7q-.425 0-.712-.288T4 6t.288-.712T5 5t.713.288T6 6t-.288.713T5 7m0 6q-.425 0-.712-.288T4 12t.288-.712T5 11t.713.288T6 12t-.288.713T5 13m0 6q-.425 0-.712-.288T4 18t.288-.712T5 17t.713.288T6 18t-.288.713T5 19" />
                </svg>
              </div>
            </div>
            <span>Lista</span>
          </div>
        </div>

        <h2 style="margin-top: 2rem;">Elementos</h2>
        <div class="elements-grid">
          <div class="element-btn" draggable="true" ondragstart="startDrag('header', event)" data-tooltip="Cabeçalho">
            <div class="element-icon icon-header">H</div>
            <span>Cabeçalho</span>
          </div>
          <div class="element-btn" draggable="true" ondragstart="startDrag('text', event)" data-tooltip="Texto">
            <div class="element-icon icon-text">T</div>
            <span>Texto</span>
          </div>
          <div class="element-btn" draggable="true" ondragstart="startDrag('image', event)" data-tooltip="Imagem">
            <div class="element-icon icon-image">🏞️</div>
            <span>Imagem</span>
          </div>
          <div class="element-btn" draggable="true" ondragstart="startDrag('margin', event)" data-tooltip="Espaço">
            <div class="element-icon icon-margin">
              <svg id="margin-icon-template" width="24" height="24" viewBox="0 0 24 24">
                <path fill="#fff"
                  d="M3 22q-.425 0-.712-.288T2 21t.288-.712T3 20h4v-2q0-.425.288-.712T8 17h8q.425 0 .713.288T17 18v2h4q.425 0 .713.288T22 21t-.288.713T21 22zM8 7q-.425 0-.712-.288T7 6V4H3q-.425 0-.712-.288T2 3t.288-.712T3 2h18q.425 0 .713.288T22 3t-.288.713T21 4h-4v2q0 .425-.288.713T16 7z" />
              </svg>
            </div>
            <span>Espaço</span>
          </div>
          <div class="element-btn" draggable="true" ondragstart="startDrag('pageBreak', event)"
            data-tooltip="Quebra Página">
            <div class="element-icon icon-pagebreak">⤵️</div>
            <span>Quebra Página</span>
          </div>
          <div class="element-btn" draggable="true" ondragstart="startDrag('qr', event)" data-tooltip="QR Code">
            <div class="element-icon icon-qr">
              <svg id="qr-icon-template" width="24" height="24" viewBox="0 0 24 24">
                <path fill="#fff"
                  d="M3 7q-.425 0-.712-.288T2 6V3q0-.425.288-.712T3 2h3q.425 0 .713.288T7 3t-.288.713T6 4H4v2q0 .425-.288.713T3 7m0 15q-.425 0-.712-.288T2 21v-3q0-.425.288-.712T3 17t.713.288T4 18v2h2q.425 0 .713.288T7 21t-.288.713T6 22zm15 0q-.425 0-.712-.288T17 21t.288-.712T18 20h2v-2q0-.425.288-.712T21 17t.713.288T22 18v3q0 .425-.288.713T21 22zm3-15q-.425 0-.712-.288T20 6V4h-2q-.425 0-.712-.288T17 3t.288-.712T18 2h3q.425 0 .713.288T22 3v3q0 .425-.288.713T21 7m-3.5 12v-1.5H19V19zm0-3v-1.5H19V16zM16 17.5V16h1.5v1.5zM14.5 19v-1.5H16V19zM13 17.5V16h1.5v1.5zm3-3V13h1.5v1.5zM14.5 16v-1.5H16V16zM13 14.5V13h1.5v1.5zm1-3.5q-.425 0-.712-.288T13 10V6q0-.425.288-.712T14 5h4q.425 0 .713.288T19 6v4q0 .425-.288.713T18 11zm-8 8q-.425 0-.712-.288T5 18v-4q0-.425.288-.712T6 13h4q.425 0 .713.288T11 14v4q0 .425-.288.713T10 19zm0-8q-.425 0-.712-.288T5 10V6q0-.425.288-.712T6 5h4q.425 0 .713.288T11 6v4q0 .425-.288.713T10 11zm.5 6.5h3v-3h-3zm0-8h3v-3h-3zm8 0h3v-3h-3z" />
              </svg>
            </div>
            <span>QR Code</span>
          </div>
          <div class="element-btn" draggable="true" ondragstart="startDrag('svg', event)" data-tooltip="SVG">
            <div class="element-icon icon-svg">🧩</div>
            <span>SVG</span>
          </div>
          <div class="element-btn" draggable="true" ondragstart="startDrag('barcode', event)" data-tooltip="Barcode">
            <div class="element-icon icon-barcode">
              <svg id="barcode-icon-template" width="24" height="24" viewBox="0 0 24 24">
                <path fill="#fff"
                  d="M6 20q0 .425-.288.713T5 21H2q-.425 0-.712-.288T1 20v-3q0-.425.288-.712T2 16t.713.288T3 17v2h2q.425 0 .713.288T6 20m16-4q.425 0 .713.288T23 17v3q0 .425-.288.713T22 21h-3q-.425 0-.712-.288T18 20t.288-.712T19 19h2v-2q0-.425.288-.712T22 16M4.5 18q-.2 0-.35-.15T4 17.5v-11q0-.2.15-.35T4.5 6h1q.2 0 .35.15T6 6.5v11q0 .2-.15.35T5.5 18zm3 0q-.2 0-.35-.15T7 17.5v-11q0-.2.15-.35T7.5 6t.35.15t.15.35v11q0 .2-.15.35T7.5 18m3 0q-.2 0-.35-.15T10 17.5v-11q0-.2.15-.35T10.5 6h1q.2 0 .35.15t.15.35v11q0 .2-.15.35t-.35.15zm3 0q-.2 0-.35-.15T13 17.5v-11q0-.2.15-.35T13.5 6h2q.2 0 .35.15t.15.35v11q0 .2-.15.35t-.35.15zm4 0q-.2 0-.35-.15T17 17.5v-11q0-.2.15-.35T17.5 6t.35.15t.15.35v11q0 .2-.15.35t-.35.15m2 0q-.2 0-.35-.15T19 17.5v-11q0-.2.15-.35T19.5 6t.35.15t.15.35v11q0 .2-.15.35t-.35.15M6 4q0 .425-.288.713T5 5H3v2q0 .425-.288.713T2 8t-.712-.288T1 7V4q0-.425.288-.712T2 3h3q.425 0 .713.288T6 4m12 0q0-.425.288-.712T19 3h3q.425 0 .713.288T23 4v3q0 .425-.288.713T22 8t-.712-.288T21 7V5h-2q-.425 0-.712-.288T18 4" />
              </svg>
            </div>
            <span>Barcode</span>
          </div>
          <div class="element-btn" draggable="true" ondragstart="startDrag('stamp', event)"
            data-tooltip="Carimbo / Selo">
            <div class="element-icon icon-stamp">🪪</div>
            <span>Carimbo / Selo</span>
          </div>
          <div class="element-btn" draggable="true" ondragstart="startDrag('checkbox', event)" data-tooltip="Checkbox">
            <div class="element-icon icon-checkbox">✅</div>
            <span>Checkbox</span>
          </div>
          <div class="element-btn" draggable="true" ondragstart="startDrag('radio', event)" data-tooltip="Radio">
            <div class="element-icon icon-radio">◉</div>
            <span>Radio</span>
          </div>
          <div class="element-btn" draggable="true" ondragstart="startDrag('fillLine', event)"
            data-tooltip="Linha (preenchimento)">
            <div class="element-icon icon-line">✍️</div>
            <span>Linha (preenchimento)</span>
          </div>
          <div class="element-btn" draggable="true" ondragstart="startDrag('chart', event)"
            data-tooltip="Gráfico (Chart.js)">
            <div class="element-icon icon-chart">📈</div>
            <span>Gráfico (Chart.js)</span>
          </div>
        </div>

        <div class="info-box">
          <h3>Como usar:</h3>
          <ol>
            <li>Arraste os elementos</li>
            <li>Configure as propriedades</li>
            <li>Copie e use</li>
          </ol>
        </div>
      </div>

      <!-- Canvas -->
      <div class="canvas-area">
        <div class="canvas-tools">
          <div class="zoom">
            <span>Zoom</span>
            <button class="zoom-btn" id="zoomDecrease" title="Diminuir zoom">−</button>
            <input id="zoomRange" type="range" min="55" max="140" value="100" />
            <button class="zoom-btn" id="zoomIncrease" title="Aumentar zoom">+</button>
            <span id="zoomLabel">100%</span>
          </div>
          <div class="canvas-tools-right">
            <button class="btn" id="saveTemplateBtn" title="Salvar template atual" style="display: none;">💾 Salvar
              Template</button>
            <button class="btn" id="clearBtn" style="display: none;">Limpar</button>
          </div>
        </div>
        <div class="canvas-wrapper">
          <div class="canvas" id="canvas" ondrop="handleDrop(event)" ondragover="handleDragOver(event)"
            ondragleave="handleDragLeave(event)">
            <div class="canvas-empty" id="canvasEmpty">
              <div>
                <p>Arraste um grupo aqui</p>
                <p>para começar a criar seu PDF</p>
              </div>
            </div>
            <div class="elements-list" id="elementsList" style="display: none;"></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Code Panel - Fora do .main para ser independente -->
    <div class="code-panel" id="codePanel">
      <div class="code-header" id="codePanelHeader">
        <div class="header-top">
          <div class="element-type-title" id="elementTypeTitle">Tipo</div>
          <button class="close-panel-btn" id="closePanelBtn" onclick="closePanel()" title="Fechar painel">
            <svg width="12" height="15" viewBox="0 0 0.72 0.72" xmlns="http://www.w3.org/2000/svg"
              preserveAspectRatio="xMidYMid meet"
              style="display: block !important; fill: #ef4444 !important; visibility: visible !important; opacity: 1 !important; width: 24px !important; height: 24px !important; overflow: visible !important;">
              <path
                d="M0.614 0.105a0.359 0.359 0 0 0 -0.255 -0.105C0.161 0 0 0.161 0 0.36c0 0.099 0.04 0.189 0.105 0.255A0.359 0.359 0 0 0 0.36 0.72c0.199 0 0.36 -0.161 0.36 -0.36 0 -0.099 -0.04 -0.189 -0.105 -0.255m-0.046 0.463a0.294 0.294 0 0 1 -0.208 0.086c-0.163 0 -0.295 -0.132 -0.295 -0.295a0.294 0.294 0 0 1 0.086 -0.208 0.294 0.294 0 0 1 0.208 -0.086c0.163 0 0.295 0.132 0.295 0.295a0.294 0.294 0 0 1 -0.086 0.208z"
                fill="#ef4444"
                style="fill: #ef4444 !important; visibility: visible !important; opacity: 1 !important; stroke: none !important;" />
              <path
                d="m0.406 0.36 0.116 -0.116a0.033 0.033 0 0 0 -0.046 -0.046l0 0 -0.116 0.116 -0.116 -0.116A0.033 0.033 0 0 0 0.198 0.244l0 0 0.116 0.116 -0.116 0.116a0.033 0.033 0 1 0 0.046 0.046l0 0 0.116 -0.116 0.116 0.116a0.033 0.033 0 1 0 0.046 -0.046l0 0z"
                fill="#ef4444"
                style="fill: #ef4444 !important; visibility: visible !important; opacity: 1 !important; stroke: none !important;" />
            </svg>
          </button>


        </div>
        <div class="tabs">
          <button class="tab-btn active" id="tabEditor" onclick="switchTab('editor')">⚙️ Editor</button>
          <button class="tab-btn" id="tabPage" onclick="switchTab('page')">📄 Página</button>
          <button class="tab-btn" id="tabCode" onclick="switchTab('code')">💻 Código</button>
        </div>
      </div>

      <!-- Editor Tab -->
      <div class="tab-content active" id="tabContentEditor">
        <div class="inspector" id="inspector">
          <div class="muted" style="padding: 1rem; text-align: center;">
            Selecione um elemento no canvas para editar suas propriedades.
          </div>
        </div>
      </div>

      <!-- Page Tab (combines TOC, Header/Footer, and Watermark) -->
      <div class="tab-content" id="tabContentPage">
        <div class="inspector" id="pageInspector" style="padding: 1rem;">
          <!-- Será preenchido dinamicamente pela função renderPageInspector -->
        </div>
      </div>

      <!-- Code Tab -->
      <div class="tab-content" id="tabContentCode">
        <div style="padding: 1rem; border-bottom: 1px solid #e5e7eb;">
          <button class="btn-copy" id="copyBtn" onclick="copyCode()"
            style="width: 100%; padding: 0.75rem 1rem; font-size: 1rem; border-radius: 0.5rem;">📋 Copiar</button>
        </div>
        <div class="code-editor" id="codeEditor">// Adicione elementos para gerar o código</div>
        <div class="code-instructions">
          <p>Para usar este código:</p>
          <ol>
            <li>Copie o código acima</li>
            <li>Cole em seu projeto</li>
            <li>Execute para gerar</li>
          </ol>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal -->
  <div class="modal" id="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Configurar Elemento</h3>
        <button class="btn-close" onclick="closeModal()">✕</button>
      </div>
      <div class="modal-body" id="modalBody"></div>
      <div class="modal-footer">
        <button class="btn-apply" onclick="closeModal()">Aplicar</button>
      </div>
    </div>
  </div>


  <script>
    /****************************************************
     * PDFMake Visual Editor (Nested containers)
     * - Mantém o layout do gerador_atualizado.html
     * - Adiciona suporte a "elementos dentro de elementos"
     *   (Group / Columns / List / Table) como no index.html
     ****************************************************/

    // -----------------------
    // State
    // -----------------------
    let draggedType = null;

    // Estrutura em árvore:
    // elements = [ rootGroup ]
    let elements = [];
    let selectedElementId = null;

    let orientation = 'portrait';
    let pageSize = 'A4';
    let pageMargins = [40, 60, 40, 60];
    let zoom = 0.95;

    // Headers & Footers - Agora como containers visuais no canvas
    let documentHeader = {
      enabled: false,
      root: null, // Container group com children (como elements)
      height: 60 // Altura estimada para cálculo de margins
    };
    let documentFooter = {
      enabled: false,
      root: null, // Container group com children (como elements)
      height: 60 // Altura estimada para cálculo de margins
    };

    // Watermark (apenas texto - PDFMake não suporta imagens)
    let documentWatermark = null; // { text: '', fontSize: 48, color: '#cccccc', opacity: 0.3, angle: -45 }

    // TOC (Table of Contents)
    let documentTOC = null; // { title: 'Índice', titleStyle: {}, itemStyle: {}, textStyle: {}, numberStyle: {} }

    // Security
    let documentSecurity = null; // { userPassword: '', ownerPassword: '', permissions: { printing: true, modifying: true, copying: true, annotating: true } }

    // Page Info (Metadados) e Compress
    let documentPageInfo = null; // { author: '', title: '', subject: '', keywords: '' }
    let documentCompress = false; // true/false

    // -----------------------
    // Supabase - Configuração e Autenticação
    // -----------------------
    const SUPABASE_URL = "https://ckhqcooulkucxpbcceat.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNraHFjb291bGt1Y3hwYmNjZWF0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY5NTQ3OTQsImV4cCI6MjA4MjUzMDc5NH0.OmdLp5Nf261BqUdZP6id-QpydPrTtPUDtqi3Yi2PVXw";

    let supabaseClient = null; // Usando nome diferente para evitar conflito com variável global do Supabase
    let currentUser = null;
    let currentProfile = null;
    let currentInstallation = null;
    let currentTemplateId = null; // ID do template carregado (null = novo template)

    // Inicializar Supabase quando o script carregar
    function initSupabase() {
      // O Supabase JS v2 expõe createClient no objeto window.supabase
      if (typeof window.supabase !== 'undefined' && typeof window.supabase.createClient === 'function') {
        try {
          supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
          checkAuth();
        } catch (error) {
          console.error('Erro ao inicializar Supabase:', error);
          showLoginModal(); // Mostrar modal mesmo com erro
        }
      } else {
        // Tentar novamente após um pequeno delay (máximo 10 tentativas)
        if (typeof initSupabase.attempts === 'undefined') {
          initSupabase.attempts = 0;
        }
        initSupabase.attempts++;
        if (initSupabase.attempts < 50) { // 5 segundos máximo
          setTimeout(initSupabase, 100);
        } else {
          console.error('Timeout ao carregar Supabase');
          showLoginModal(); // Mostrar modal mesmo se não conseguir carregar
        }
      }
    }

    // Aguardar carregamento do script do Supabase
    window.addEventListener('load', () => {
      setTimeout(initSupabase, 300);
    });

    // -----------------------
    // LocalStorage - Auto-save
    // -----------------------
    const STORAGE_KEY = 'pdfmake_editor_state';
    const STORAGE_CODE_KEY = 'pdfmake_editor_code';

    // Salvar estado completo no localStorage
    // Função para remover propriedades internas (como _base64Preview) antes de salvar
    function cleanElementsForStorage(elements) {
      if (!elements || !Array.isArray(elements)) return elements;

      return elements.map(el => {
        const cleaned = { ...el };
        if (cleaned.properties) {
          cleaned.properties = { ...cleaned.properties };
          // Remover _base64Preview (apenas para preview visual)
          delete cleaned.properties._base64Preview;

          // Limpar recursivamente se houver children
          if (cleaned.properties.children && Array.isArray(cleaned.properties.children)) {
            cleaned.properties.children = cleanElementsForStorage(cleaned.properties.children);
          }

          // Limpar recursivamente se houver columns
          if (cleaned.properties.columns && Array.isArray(cleaned.properties.columns)) {
            cleaned.properties.columns = cleaned.properties.columns.map(col => {
              if (col.children && Array.isArray(col.children)) {
                return { ...col, children: cleanElementsForStorage(col.children) };
              }
              return col;
            });
          }

          // Limpar recursivamente se houver items (listas)
          if (cleaned.properties.items && Array.isArray(cleaned.properties.items)) {
            cleaned.properties.items = cleaned.properties.items.map(item => {
              if (item.kind === 'node' && item.node) {
                return { ...item, node: cleanElementsForStorage([item.node])[0] };
              }
              return item;
            });
          }

          // Limpar recursivamente se houver body (tabelas)
          if (cleaned.properties.body && Array.isArray(cleaned.properties.body)) {
            cleaned.properties.body = cleaned.properties.body.map(row => {
              return row.map(cell => {
                if (cell && cell.children && Array.isArray(cell.children)) {
                  return { ...cell, children: cleanElementsForStorage(cell.children) };
                }
                return cell;
              });
            });
          }
        }
        return cleaned;
      });
    }

    function saveState() {
      try {
        // Limpar elementos removendo propriedades internas antes de salvar
        const cleanedElements = cleanElementsForStorage(elements);

        const state = {
          elements: cleanedElements,
          selectedElementId: selectedElementId,
          orientation: orientation,
          pageSize: pageSize,
          pageMargins: pageMargins,
          zoom: zoom,
          documentHeader: documentHeader,
          documentFooter: documentFooter,
          documentWatermark: documentWatermark,
          documentTOC: documentTOC,
          documentSecurity: documentSecurity,
          documentPageInfo: documentPageInfo,
          documentCompress: documentCompress,
          timestamp: Date.now()
        };

        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));

        // Salvar também o código gerado
        if (codeEditor && codeEditor.textContent) {
          localStorage.setItem(STORAGE_CODE_KEY, codeEditor.textContent);
        }
      } catch (e) {
        console.warn('Erro ao salvar estado no localStorage:', e);
      }
    }

    // Carregar estado do localStorage
    function loadState() {
      try {
        const savedState = localStorage.getItem(STORAGE_KEY);
        if (!savedState) return false;

        const state = JSON.parse(savedState);

        // Verificar se o estado foi limpo (elementos vazios)
        if (!state.elements || !Array.isArray(state.elements) || state.elements.length === 0) {
          // Se elementos estão vazios, limpar estado salvo e não carregar
          clearSavedState();
          return false;
        }

        // Restaurar elementos (deep clone para evitar referências compartilhadas)
        elements = deepClone(state.elements);

        // Restaurar configurações globais
        if (state.selectedElementId) selectedElementId = state.selectedElementId;
        else selectedElementId = null;
        if (state.orientation) orientation = state.orientation;
        if (state.pageSize) pageSize = state.pageSize;
        if (state.pageMargins) pageMargins = state.pageMargins;
        if (state.zoom !== undefined) zoom = state.zoom;

        // Restaurar header/footer
        if (state.documentHeader) {
          documentHeader = state.documentHeader;
          // Garantir que root existe
          if (!documentHeader.root) {
            documentHeader.root = createHeaderFooterRoot();
          }
          // Se enabled mas não tem children, desabilitar
          if (documentHeader.enabled && (!documentHeader.root.properties.children || documentHeader.root.properties.children.length === 0)) {
            documentHeader.enabled = false;
          }
        }
        if (state.documentFooter) {
          documentFooter = state.documentFooter;
          // Garantir que root existe
          if (!documentFooter.root) {
            documentFooter.root = createHeaderFooterRoot();
          }
          // Se enabled mas não tem children, desabilitar
          if (documentFooter.enabled && (!documentFooter.root.properties.children || documentFooter.root.properties.children.length === 0)) {
            documentFooter.enabled = false;
          }
        }

        // Restaurar watermark
        if (state.documentWatermark) documentWatermark = state.documentWatermark;

        // Restaurar TOC
        if (state.documentTOC) documentTOC = state.documentTOC;

        // Restaurar Security
        if (state.documentSecurity) documentSecurity = state.documentSecurity;

        // Restaurar Page Info
        if (state.documentPageInfo) documentPageInfo = state.documentPageInfo;

        // Restaurar Compress
        if (state.documentCompress !== undefined) documentCompress = state.documentCompress;

        // Restaurar valores nos inputs do DOM
        if (pageSizeSel && state.pageSize) pageSizeSel.value = state.pageSize;
        if (orientationSel && state.orientation) orientationSel.value = state.orientation;
        if (mL && state.pageMargins) mL.value = state.pageMargins[0];
        if (mT && state.pageMargins) mT.value = state.pageMargins[1];
        if (mR && state.pageMargins) mR.value = state.pageMargins[2];
        if (mB && state.pageMargins) mB.value = state.pageMargins[3];
        if (zoomRange && state.zoom !== undefined) {
          zoomRange.value = Math.round(state.zoom * 100);
          if (zoomLabel) zoomLabel.textContent = Math.round(state.zoom * 100) + '%';
        }

        return true;
      } catch (e) {
        console.warn('Erro ao carregar estado do localStorage:', e);
        return false;
      }
    }

    // Limpar estado salvo
    function clearSavedState() {
      try {
        localStorage.removeItem(STORAGE_KEY);
        localStorage.removeItem(STORAGE_CODE_KEY);
      } catch (e) {
        console.warn('Erro ao limpar estado do localStorage:', e);
      }
    }

    // Get DOM elements
    const pageSizeSel = document.getElementById("pageSize");
    const orientationSel = document.getElementById("orientation");
    const mL = document.getElementById("mL");
    const mT = document.getElementById("mT");
    const mR = document.getElementById("mR");
    const mB = document.getElementById("mB");
    const zoomRange = document.getElementById("zoomRange");
    const zoomLabel = document.getElementById("zoomLabel");
    // const previewBtn = document.getElementById("previewBtn");
    const bubbleTestBtn = document.getElementById("bubbleTestBtn");
    const clearBtn = document.getElementById("clearBtn");
    const saveTemplateBtn = document.getElementById("saveTemplateBtn");
    const canvas = document.getElementById("canvas");
    const canvasEmpty = document.getElementById("canvasEmpty");
    const elementsList = document.getElementById("elementsList");

    // Code panel
    const codeEditor = document.getElementById("codeEditor");
    const copyBtn = document.getElementById("copyBtn");
    const inspector = document.getElementById("inspector");

    // -----------------------
    // Helpers
    // -----------------------
    const uid = () => "id_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);

    // Função para criar root container de header/footer
    function createHeaderFooterRoot() {
      return {
        id: uid(),
        type: 'group',
        properties: {
          orientation: 'row',
          children: []
        },
        _ui: {}
      };
    }

    // Inicializar roots de header/footer se não existirem
    if (!documentHeader.root) {
      documentHeader.root = createHeaderFooterRoot();
    }
    if (!documentFooter.root) {
      documentFooter.root = createHeaderFooterRoot();
    }

    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }

    function clamp(n, a, b) {
      return Math.max(a, Math.min(b, n));
    }

    function getRootGroup() {
      return elements.find(e => e.type === 'group') || null;
    }

    function isContainerType(type) {
      return ['group', 'columns', 'list', 'table'].includes(type);
    }

    function defaultElement(type) {
      const id = uid();
      const base = { id, type, properties: {}, _ui: {} };

      if (type === 'group') {
        return {
          ...base,
          properties: {
            orientation: 'column', // no editor visual (layout)
            gap: 10,
            children: []
          }
        };
      }

      if (type === 'header') {
        return {
          ...base,
          properties: {
            text: 'Cabeçalho',
            fontSize: 18,
            bold: true,
            alignment: 'center',
            margin: [0, 0, 0, 10]
          }
        };
      }

      if (type === 'text') {
        return {
          ...base,
          properties: {
            text: 'Texto...',
            fontSize: 14,
            alignment: 'left',
            margin: [0, 0, 0, 10]
          }
        };
      }

      if (type === 'image') {
        return {
          ...base,
          properties: {
            url: '',
            width: 200,
            height: 150,
            margin: [0, 0, 0, 10]
          }
        };
      }

      if (type === 'columns') {
        const count = 3;
        return {
          ...base,
          properties: {
            columnsCount: count,
            gap: 10,
            // cada coluna tem children
            columns: Array.from({ length: count }).map(() => ({ width: '*', children: [] })),
            margin: [0, 0, 0, 10]
          }
        };
      }

      if (type === 'list') {
        return {
          ...base,
          properties: {
            listType: 'ul', // ul|ol
            // items: array de {kind:'text', text} OU {kind:'node', node:<element>}
            items: [
              { kind: 'text', text: 'Item 1' },
              { kind: 'text', text: 'Item 2' }
            ],
            margin: [0, 0, 0, 10]
          }
        };
      }

      if (type === 'table') {
        // Template oficial: 4 colunas, 1 headerRows, 1 linha de dados
        const cols = 4;
        const headerRows = 1;

        // Criar body com 2 linhas: header + dados
        const body = [
          // Linha 0 (header): 4 células com text: 'Coluna X', bold: true, alignment: 'center', fontSize: 10
          Array.from({ length: cols }).map((_, colIdx) => ({
            children: [{
              id: uid(),
              type: 'text',
              properties: {
                text: `Coluna ${colIdx + 1}`,
                fontSize: 10,
                bold: true,
                alignment: 'center'
              },
              _ui: {}
            }],
            fontSize: 10,
            alignment: 'center',
            bold: true
          })),
          // Linha 1 (dados): 4 células com text: 'texto X', alignment: 'center', verticalAlignment: 'middle', fontSize: 9
          Array.from({ length: cols }).map((_, colIdx) => ({
            children: [{
              id: uid(),
              type: 'text',
              properties: {
                text: `texto ${colIdx + 1}`,
                fontSize: 9,
                bold: false,
                alignment: 'center'
              },
              _ui: {}
            }],
            fontSize: 9,
            alignment: 'center',
            verticalAlignment: 'middle',
            bold: false
          }))
        ];

        return {
          ...base,
          properties: {
            headerRows: headerRows,
            widths: [40, '*', 40, '*'], // Template oficial: [40, '*', 40, '*']
            body: body,
            layout: 'custom',
            customLayout: {
              // Template oficial: hLineWidth/vLineWidth: 0.6
              hLineWidth: 0.6,
              vLineWidth: 0.6,
              // Template oficial: hLineColor/vLineColor: '#000'
              hLineColor: '#000',
              vLineColor: '#000',
              // Template oficial: paddingLeft/Right = 4, paddingTop/Bottom = 3
              paddingLeft: 4,
              paddingRight: 4,
              paddingTop: 3,
              paddingBottom: 3,
              // Template oficial: fillColor(rowIndex) com cinza #EDEDED somente no header (rowIndex === 0)
              fillColor: true // Será tratado como função na geração
            },
            margin: [0, 0, 0, 10]
          }
        };
      }

      if (type === 'margin') {
        return { ...base, properties: { size: 20 } };
      }

      if (type === 'pageBreak') {
        return { ...base, properties: {} };
      }

      if (type === 'qr') {
        return {
          ...base,
          properties: {
            text: 'https://exemplo.com',
            fit: 100,
            eccLevel: 'M',
            foreground: '#000000',
            background: '#ffffff',
            alignment: 'center',
            margin: [0, 0, 0, 10]
          }
        };
      }

      if (type === 'svg') {
        return {
          ...base,
          properties: {
            svg: '<svg width="100" height="100"><circle cx="50" cy="50" r="40" fill="blue"/></svg>',
            width: 100,
            height: 100,
            color: '#000000',
            alignment: 'center',
            margin: [0, 0, 0, 10]
          }
        };
      }

      if (type === 'stamp') {
        return {
          ...base,
          properties: {
            sourceType: 'image',
            value: '',
            fit: [120, 120],
            alignment: 'center',
            margin: [0, 0, 0, 10],
            opacity: 1
          }
        };
      }

      if (type === 'checkbox') {
        return {
          ...base,
          properties: {
            choiceType: 'checkbox',
            choiceText: 'Texto...',
            choiceChecked: false,
            choiceIconPosition: 'before',
            choiceGap: 8,
            choiceIconSize: 12,
            alignment: 'left',
            margin: [0, 0, 0, 10]
          }
        };
      }

      if (type === 'radio') {
        return {
          ...base,
          properties: {
            choiceType: 'radio',
            choiceText: 'Texto...',
            choiceChecked: false,
            choiceIconPosition: 'before',
            choiceGap: 8,
            choiceIconSize: 12,
            alignment: 'left',
            margin: [0, 0, 0, 10]
          }
        };
      }

      if (type === 'fillLine') {
        return {
          ...base,
          properties: {
            lineWidth: 200,
            thickness: 0.8,
            color: '#000000',
            alignment: 'left',
            margin: [0, 0, 0, 10]
          }
        };
      }

      if (type === 'chart') {
        return {
          ...base,
          properties: {
            chartType: 'bar',
            chartWidth: 400,
            chartHeight: 200,
            chartFit: [400, 200],
            chartBackgroundColor: '#FFFFFF',
            chartDevicePixelRatio: 2,
            chartData: {
              labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May'],
              datasets: [{
                label: 'Dataset 1',
                data: [10, 20, 30, 40, 50],
                backgroundColor: 'rgba(54, 162, 235, 0.5)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1
              }]
            },
            chartOptions: {
              responsive: false,
              animation: { duration: 0 },
              scales: {
                y: { beginAtZero: true }
              }
            },
            alignment: 'center',
            margin: [0, 0, 0, 10]
          }
        };
      }

      if (type === 'barcode') {
        return {
          ...base,
          properties: {
            barcodeValue: 'ABC123456789',
            format: 'CODE128',
            lineWidth: 1.5,
            barHeight: 30,
            displayValue: true,
            fontSize: 10,
            fit: [201, 42],
            alignment: 'center',
            verticalAlignment: 'middle',
            margin: [0, 0, 0, 10]
          }
        };
      }

      return base;
    }

    // -----------------------
    // Tree traversal
    // -----------------------
    function walk(node, fn) {
      if (!node) return;
      fn(node);

      if (node.type === 'group') {
        (node.properties.children || []).forEach(ch => walk(ch, fn));
      }

      if (node.type === 'columns') {
        (node.properties.columns || []).forEach(col => (col.children || []).forEach(ch => walk(ch, fn)));
      }

      if (node.type === 'list') {
        (node.properties.items || []).forEach(it => {
          if (it && it.kind === 'node' && it.node) walk(it.node, fn);
        });
      }

      if (node.type === 'table') {
        (node.properties.body || []).forEach(row => row.forEach(cell => (cell.children || []).forEach(ch => walk(ch, fn))));
      }
    }

    function findNodeById(id) {
      // Verificar header/footer primeiro
      if (documentHeader.root && documentHeader.root.id === id) return documentHeader.root;
      if (documentFooter.root && documentFooter.root.id === id) return documentFooter.root;

      // Verificar filhos do header
      if (documentHeader.root) {
        let found = null;
        walk(documentHeader.root, (n) => {
          if (n.id === id) found = n;
        });
        if (found) return found;
      }

      // Verificar filhos do footer
      if (documentFooter.root) {
        let found = null;
        walk(documentFooter.root, (n) => {
          if (n.id === id) found = n;
        });
        if (found) return found;
      }

      // Verificar conteúdo principal
      const root = getRootGroup();
      if (!root) return null;
      let found = null;
      walk(root, (n) => {
        if (n.id === id) found = n;
      });
      return found;
    }

    // Retorna: { node, parent, ctx }
    // ctx descreve onde o node vive no parent:
    // - { kind:'groupChildren', index }
    // - { kind:'columns', colIndex, index }
    // - { kind:'listItems', index }
    // - { kind:'tableCell', row, col, index }
    function findNodeWithParent(id) {
      function rec(node, parent) {
        if (!node) return null;

        // group children
        if (node.type === 'group') {
          const arr = node.properties.children || [];
          for (let i = 0; i < arr.length; i++) {
            const ch = arr[i];
            if (ch.id === id) return { node: ch, parent: node, ctx: { kind: 'groupChildren', index: i } };
            const r = rec(ch, node);
            if (r) return r;
          }
        }

        // columns
        if (node.type === 'columns') {
          const cols = node.properties.columns || [];
          for (let c = 0; c < cols.length; c++) {
            const children = cols[c].children || [];
            for (let i = 0; i < children.length; i++) {
              const ch = children[i];
              if (ch.id === id) return { node: ch, parent: node, ctx: { kind: 'columns', colIndex: c, index: i } };
              const r = rec(ch, node);
              if (r) return r;
            }
          }
        }

        // list
        if (node.type === 'list') {
          const items = node.properties.items || [];
          for (let i = 0; i < items.length; i++) {
            const it = items[i];
            if (it && it.kind === 'node' && it.node) {
              if (it.node.id === id) return { node: it.node, parent: node, ctx: { kind: 'listItems', index: i } };
              const r = rec(it.node, node);
              if (r) return r;
            }
          }
        }

        // table
        if (node.type === 'table') {
          const body = node.properties.body || [];
          for (let r = 0; r < body.length; r++) {
            for (let c = 0; c < body[r].length; c++) {
              const cell = body[r][c];
              const children = (cell && cell.children) ? cell.children : [];
              for (let i = 0; i < children.length; i++) {
                const ch = children[i];
                if (ch.id === id) return { node: ch, parent: node, ctx: { kind: 'tableCell', row: r, col: c, index: i } };
                const rr = rec(ch, node);
                if (rr) return rr;
              }
            }
          }
        }

        return null;
      }

      // Verificar header
      if (documentHeader.root) {
        if (documentHeader.root.id === id) {
          return { node: documentHeader.root, parent: null, ctx: { kind: 'headerRoot' } };
        }
        const headerResult = rec(documentHeader.root, null);
        if (headerResult) return headerResult;
      }

      // Verificar footer
      if (documentFooter.root) {
        if (documentFooter.root.id === id) {
          return { node: documentFooter.root, parent: null, ctx: { kind: 'footerRoot' } };
        }
        const footerResult = rec(documentFooter.root, null);
        if (footerResult) return footerResult;
      }

      // Verificar conteúdo principal
      const root = getRootGroup();
      if (!root) return null;
      if (root.id === id) return { node: root, parent: null, ctx: null };

      return rec(root, null);
    }

    function deleteSelected() {
      if (!selectedElementId) return;
      // IMPORTANTE: Resetar cache e permitir ajuste de tamanho apenas quando realmente deletamos um elemento
      resetCanvasSizeCache();
      allowCanvasSizeAdjust = true; // Permitir ajuste ao deletar elemento
      const info = findNodeWithParent(selectedElementId);
      if (!info || !info.parent) {
        // Não deleta root do header/footer nem root principal
        if (info && (info.ctx?.kind === 'headerRoot' || info.ctx?.kind === 'footerRoot')) {
          return;
        }
        return;
      }

      const { parent, ctx } = info;
      if (!ctx) return;

      if (ctx.kind === 'groupChildren') {
        parent.properties.children.splice(ctx.index, 1);
      } else if (ctx.kind === 'columns') {
        parent.properties.columns[ctx.colIndex].children.splice(ctx.index, 1);
      } else if (ctx.kind === 'listItems') {
        parent.properties.items.splice(ctx.index, 1);
      } else if (ctx.kind === 'tableCell') {
        parent.properties.body[ctx.row][ctx.col].children.splice(ctx.index, 1);
      }

      selectedElementId = parent.id;
      resetCanvasSizeCache();
      // Renderizar primeiro sem ajustar tamanho
      renderAll(false);
      // Depois, permitir ajuste e fazer ajuste único após um delay
      setTimeout(() => {
        allowCanvasSizeAdjust = true;
        renderAll(true);
        allowCanvasSizeAdjust = false;
        // Atualizar visibilidade do botão "Salvar Template"
        updateSaveTemplateButtonVisibility();
      }, 100);
      saveState();
    }

    function moveNodeUpDown(nodeId, dir) {
      const info = findNodeWithParent(nodeId);
      if (!info || !info.parent || !info.ctx) return;
      const ctx = info.ctx;

      function swap(arr, i, j) {
        if (i < 0 || j < 0 || i >= arr.length || j >= arr.length) return;
        const tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }

      if (ctx.kind === 'groupChildren') {
        swap(info.parent.properties.children, ctx.index, ctx.index + dir);
      } else if (ctx.kind === 'columns') {
        swap(info.parent.properties.columns[ctx.colIndex].children, ctx.index, ctx.index + dir);
      } else if (ctx.kind === 'listItems') {
        swap(info.parent.properties.items, ctx.index, ctx.index + dir);
      } else if (ctx.kind === 'tableCell') {
        swap(info.parent.properties.body[ctx.row][ctx.col].children, ctx.index, ctx.index + dir);
      }

      resetCanvasSizeCache();
      // Renderizar primeiro sem ajustar tamanho
      renderAll(false);
      // Depois, permitir ajuste e fazer ajuste único após um delay
      setTimeout(() => {
        allowCanvasSizeAdjust = true;
        renderAll(true);
        allowCanvasSizeAdjust = false;
      }, 100);
    }

    // -----------------------
    // Drag and Drop
    // -----------------------
    // Funções de drag-and-drop - devem estar disponíveis globalmente ANTES do HTML
    // Definir imediatamente no window para garantir disponibilidade
    window.startDrag = function (type, event) {
      if (typeof draggedType !== 'undefined') {
        draggedType = type;
      }
      if (event && event.dataTransfer) {
        event.dataTransfer.setData("text/plain", type);
        event.dataTransfer.effectAllowed = "move";
      }
    };

    window.handleDragOver = function (e) {
      e.preventDefault();
      e.stopPropagation();
      const canvasEl = document.getElementById("canvas");
      if (canvasEl) canvasEl.classList.add('drag-over');
    };

    window.handleDragLeave = function (e) {
      const canvasEl = document.getElementById("canvas");
      if (canvasEl && e.target === canvasEl) canvasEl.classList.remove('drag-over');
    };

    // Manter referências locais também
    function startDrag(type, event) {
      window.startDrag(type, event);
    }

    function handleDragOver(e) {
      window.handleDragOver(e);
    }

    function handleDragLeave(e) {
      window.handleDragLeave(e);
    }

    function handleDrop(e) {
      e.preventDefault();
      e.stopPropagation();
      if (canvas) canvas.classList.remove('drag-over');

      const type = (e.dataTransfer && e.dataTransfer.getData("text/plain")) || draggedType;
      if (!type) return;

      // Primeiro elemento TEM que ser group, como antes
      if (!getRootGroup()) {
        if (type !== 'group') {
          if (typeof showAlertModal === 'function') {
            showAlertModal(
              'Erro ao Adicionar Elemento',
              'O primeiro elemento no canvas deve ser um Grupo.\n\nPor favor, arraste um Grupo primeiro para começar a criar seu PDF.'
            );
          }
          return;
        }
        resetCanvasSizeCache(); // Resetar cache quando conteúdo muda
        const g = defaultElement('group');
        elements = [g];
        selectedElementId = g.id;
        // Renderizar primeiro sem ajustar tamanho
        renderAll(false);
        // Depois, permitir ajuste e fazer ajuste único após um delay
        setTimeout(() => {
          allowCanvasSizeAdjust = true;
          renderAll(true);
          allowCanvasSizeAdjust = false;
        }, 100);
        return;
      }

      // Se caiu no canvas (fora de qualquer dropzone), insere no group root
      insertIntoTarget({ kind: 'groupChildren', targetId: getRootGroup().id }, type);
    }
    window.handleDrop = handleDrop;

    function insertIntoTarget(target, type) {
      resetCanvasSizeCache(); // Resetar cache quando conteúdo muda
      const root = getRootGroup();
      const newEl = defaultElement(type);

      // Verificar se é header ou footer
      if (target.targetId === documentHeader.root?.id) {
        if (!documentHeader.root.properties.children) {
          documentHeader.root.properties.children = [];
        }
        documentHeader.root.properties.children.push(newEl);
        selectedElementId = newEl.id;
        // Renderizar primeiro sem ajustar tamanho
        renderAll(false);
        // Depois, permitir ajuste e fazer ajuste único após um delay
        setTimeout(() => {
          allowCanvasSizeAdjust = true;
          renderAll(true);
          allowCanvasSizeAdjust = false;
        }, 100);
        saveState();
        return;
      }

      if (target.targetId === documentFooter.root?.id) {
        if (!documentFooter.root.properties.children) {
          documentFooter.root.properties.children = [];
        }
        documentFooter.root.properties.children.push(newEl);
        selectedElementId = newEl.id;
        // Renderizar primeiro sem ajustar tamanho
        renderAll(false);
        // Depois, permitir ajuste e fazer ajuste único após um delay
        setTimeout(() => {
          allowCanvasSizeAdjust = true;
          renderAll(true);
          allowCanvasSizeAdjust = false;
        }, 100);
        saveState();
        return;
      }

      // Regras: se target for um elemento não-container, tenta usar o pai dele como container
      // Aqui target já vem como "dropzone" de container, então é seguro.
      if (!root) return;

      if (target.kind === 'groupChildren') {
        const group = findNodeById(target.targetId);
        if (!group || group.type !== 'group') return;
        group.properties.children.push(newEl);
        selectedElementId = newEl.id;
      }

      if (target.kind === 'columnsCol') {
        const columnsNode = findNodeById(target.targetId);
        if (!columnsNode || columnsNode.type !== 'columns') return;
        const colIndex = clamp(Number(target.colIndex || 0), 0, (columnsNode.properties.columns || []).length - 1);
        columnsNode.properties.columns[colIndex].children.push(newEl);
        selectedElementId = newEl.id;
      }

      if (target.kind === 'listItems') {
        // Adicionar novo item à lista (quando solto no container, não em um item específico)
        const listNode = findNodeById(target.targetId);
        if (!listNode || listNode.type !== 'list') return;
        listNode.properties.items.push({ kind: 'node', node: newEl });
        selectedElementId = newEl.id;
      }

      if (target.kind === 'listItemReplace') {
        // Substituir item existente na lista (quando solto em um item específico)
        const listNode = findNodeById(target.targetId);
        if (!listNode || listNode.type !== 'list') return;
        const itemIndex = target.itemIndex !== undefined ? Number(target.itemIndex) : -1;
        if (itemIndex >= 0 && itemIndex < listNode.properties.items.length) {
          // Substituir o item existente
          listNode.properties.items[itemIndex] = { kind: 'node', node: newEl };
          selectedElementId = newEl.id;
        } else {
          // Fallback: adicionar novo item se índice inválido
          listNode.properties.items.push({ kind: 'node', node: newEl });
          selectedElementId = newEl.id;
        }
      }

      if (target.kind === 'tableCell') {
        const tableNode = findNodeById(target.targetId);
        if (!tableNode || tableNode.type !== 'table') return;
        const r = clamp(Number(target.row || 0), 0, (tableNode.properties.body || []).length - 1);
        const c = clamp(Number(target.col || 0), 0, (tableNode.properties.body[r] || []).length - 1);

        // Verificar se é header ou body (baseado em headerRows)
        const headerRows = tableNode.properties.headerRows || 1;
        const isHeaderRow = r < headerRows;

        // Se o elemento inserido é texto, aplicar propriedades específicas da tabela
        if (newEl.type === 'text') {
          if (isHeaderRow) {
            // Header: fontSize: 10, bold: true, alignment: 'center'
            newEl.properties.fontSize = 10;
            newEl.properties.bold = true;
            newEl.properties.alignment = 'center';
            // Aplicar também na célula
            if (!tableNode.properties.body[r][c].fontSize) {
              tableNode.properties.body[r][c].fontSize = 10;
            }
            if (tableNode.properties.body[r][c].bold === undefined) {
              tableNode.properties.body[r][c].bold = true;
            }
            if (!tableNode.properties.body[r][c].alignment) {
              tableNode.properties.body[r][c].alignment = 'center';
            }
          } else {
            // Body: fontSize: 9, bold: false, alignment: 'center', verticalAlignment: 'middle'
            newEl.properties.fontSize = 9;
            newEl.properties.bold = false;
            newEl.properties.alignment = 'center';
            // Aplicar também na célula
            if (!tableNode.properties.body[r][c].fontSize) {
              tableNode.properties.body[r][c].fontSize = 9;
            }
            if (tableNode.properties.body[r][c].bold === undefined) {
              tableNode.properties.body[r][c].bold = false;
            }
            if (!tableNode.properties.body[r][c].alignment) {
              tableNode.properties.body[r][c].alignment = 'center';
            }
            // verticalAlignment deve estar na célula, não no texto
            if (!tableNode.properties.body[r][c].verticalAlignment) {
              tableNode.properties.body[r][c].verticalAlignment = 'middle';
            }
          }
        }

        tableNode.properties.body[r][c].children.push(newEl);
        selectedElementId = newEl.id;
      }

      // Renderizar primeiro sem ajustar tamanho
      renderAll(false);
      // Depois, permitir ajuste e fazer ajuste único após um delay para garantir que DOM está pronto
      setTimeout(() => {
        allowCanvasSizeAdjust = true;
        renderAll(true);
        allowCanvasSizeAdjust = false;
      }, 100);
      saveState();
    }

    // dropzone handlers (delegação)
    function onDropZoneOver(e) {
      e.preventDefault();
      e.stopPropagation();
      const dz = e.currentTarget;
      dz.classList.add('drag-over');
    }
    function onDropZoneLeave(e) {
      e.preventDefault();
      const dz = e.currentTarget;
      dz.classList.remove('drag-over');
    }
    function onDropZoneDrop(e) {
      e.preventDefault();
      e.stopPropagation();
      const dz = e.currentTarget;
      dz.classList.remove('drag-over');

      // Remover feedback visual se for um item de lista
      if (dz.tagName === 'LI' && dz.style.backgroundColor) {
        dz.style.backgroundColor = '';
        dz.style.borderColor = '#9ca3af';
      }

      const type = (e.dataTransfer && e.dataTransfer.getData("text/plain")) || draggedType;
      if (!type) return;

      const kind = dz.getAttribute('data-drop-kind');
      const targetId = dz.getAttribute('data-target-id');
      const colIndex = dz.getAttribute('data-col-index');
      const row = dz.getAttribute('data-row');
      const col = dz.getAttribute('data-col');
      const itemIndex = dz.getAttribute('data-item-index'); // Para substituir item de lista

      insertIntoTarget({ kind, targetId, colIndex, row, col, itemIndex }, type);
    }

    // -----------------------
    // Rendering
    // -----------------------

    // Função para converter URL de imagem para base64 (apenas para preview visual)
    async function convertImageUrlToBase64(url) {
      try {
        // Se já for base64, retornar como está
        if (url.startsWith('data:image/')) {
          return url;
        }

        // Fazer fetch da imagem
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const blob = await response.blob();

        // Converter blob para base64
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onloadend = () => {
            resolve(reader.result);
          };
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      } catch (error) {
        console.warn('Erro ao converter imagem para base64:', error);
        return null;
      }
    }

    function applyZoom() {
      const z = zoom;
      const canvas = document.getElementById('canvas');
      if (canvas) {
        canvas.style.transformOrigin = 'top center';
        canvas.style.transform = `scale(${z})`;
      }
      // Remover transform do elementsList para evitar duplicação
      if (elementsList) {
        elementsList.style.transform = '';
        elementsList.style.transformOrigin = '';
      }
    }

    function elementLabel(el) {
      const map = {
        group: 'Grupo',
        header: 'Cabeçalho',
        text: 'Texto',
        image: 'Imagem',
        table: 'Tabela',
        columns: 'Colunas',
        list: 'Lista',
        margin: 'Espaço',
        pageBreak: 'Quebra Página'
      };
      return map[el.type] || el.type;
    }

    function createControls(el) {
      const controls = document.createElement('div');
      controls.className = 'element-controls';
      controls.style.display = 'none';
      return controls;
    }
    function renderElementRecursive(el) {
      const wrapper = document.createElement('div');
      wrapper.className = 'element-item';
      wrapper.setAttribute('data-id', el.id);
      wrapper.draggable = false;

      if (el.type === 'group') wrapper.classList.add('element-group');
      if (el.type === 'image') {
        wrapper.classList.add('element-image');
        // Aplicar posicionamento absoluto/relativo no wrapper principal se existir
        if (el.properties.absolutePosition) {
          wrapper.style.position = 'absolute';
          wrapper.style.left = `${el.properties.absolutePosition.x || 0}px`;
          wrapper.style.top = `${el.properties.absolutePosition.y || 0}px`;
          wrapper.style.zIndex = '10';
        } else if (el.properties.relativePosition) {
          wrapper.style.position = 'relative';
          wrapper.style.left = `${el.properties.relativePosition.x || 0}px`;
          wrapper.style.top = `${el.properties.relativePosition.y || 0}px`;
        }
      }

      if (el.id === selectedElementId) wrapper.classList.add('selected');

      wrapper.addEventListener('click', (ev) => {
        ev.stopPropagation();
        selectElement(el.id);
      });

      // (UI) controles inline desabilitados: edição/remoção apenas via painel Editor
      // Preview content
      const preview = document.createElement('div');
      preview.className = 'element-preview';

      // --- Types ---
      if (el.type === 'group') {
        const childWrap = document.createElement('div');
        childWrap.className = 'group-children ' + (el.properties.orientation === 'row' ? 'orientation-row' : 'orientation-column');

        // dropzone do group (children)
        childWrap.setAttribute('data-drop-kind', 'groupChildren');
        childWrap.setAttribute('data-target-id', el.id);
        childWrap.addEventListener('dragover', onDropZoneOver);
        childWrap.addEventListener('dragleave', onDropZoneLeave);
        childWrap.addEventListener('drop', onDropZoneDrop);

        const children = el.properties.children || [];
        if (children.length === 0) {
          const ph = document.createElement('div');
          ph.className = 'group-placeholder';
          ph.textContent = 'Arraste elementos aqui';
          childWrap.appendChild(ph);
        } else {
          children.forEach(ch => {
            const childBox = document.createElement('div');
            //childBox.className = 'group-child-item';

            childBox.className = 'group-child-sem-abas';
            // no modo row, evita "estourar" e respeita a página
            if (el.properties.orientation === 'row') {
              childBox.style.flex = '1 1 0';
              childBox.style.minWidth = '0';
            } else {
              childBox.style.width = '100%';
            }
            childBox.appendChild(renderElementRecursive(ch));
            childWrap.appendChild(childBox);
          });
        }

        preview.appendChild(childWrap);
      }
      else if (el.type === 'header') {
        const div = document.createElement('div');
        div.className = 'preview-header';
        div.textContent = el.properties.text || 'Cabeçalho';
        div.style.textAlign = (el.properties.alignment || 'center');
        if (el.properties.color) div.style.color = el.properties.color;
        if (el.properties.background) div.style.backgroundColor = el.properties.background;
        if (el.properties.fontSize) div.style.fontSize = `${el.properties.fontSize}px`;
        if (el.properties.bold) div.style.fontWeight = 'bold';
        if (el.properties.decoration === 'underline') div.style.textDecoration = 'underline';
        if (el.properties.decoration === 'lineThrough') div.style.textDecoration = 'line-through';
        if (el.properties.decoration === 'overline') div.style.textDecoration = 'overline';
        if (el.properties.link) {
          div.style.cursor = 'pointer';
          div.style.textDecoration = 'underline';
          div.style.color = el.properties.color || '#0066cc';
          div.title = `Link: ${el.properties.link}`;
        }
        preview.appendChild(div);
      }
      else if (el.type === 'text') {
        const div = document.createElement('div');
        div.className = 'preview-text';
        let textContent = el.properties.text || 'Texto...';
        // Se estiver em header/footer e tiver placeholders, mostrar exemplo no preview
        const isInHeader = isElementInHeader(el.id);
        const isInFooter = isElementInFooter(el.id);
        if ((isInHeader || isInFooter) && textContent.includes('{{')) {
          textContent = textContent
            .replace(/\{\{pageNumber\}\}/g, '1')
            .replace(/\{\{totalPages\}\}/g, '10');
        }
        div.textContent = textContent;
        div.style.textAlign = (el.properties.alignment || 'left');
        if (el.properties.color) div.style.color = el.properties.color;
        if (el.properties.background) div.style.backgroundColor = el.properties.background;
        if (el.properties.fontSize) div.style.fontSize = `${el.properties.fontSize}px`;
        if (el.properties.bold) div.style.fontWeight = 'bold';
        if (el.properties.italics) div.style.fontStyle = 'italic';
        if (el.properties.decoration === 'underline') div.style.textDecoration = 'underline';
        if (el.properties.decoration === 'lineThrough') div.style.textDecoration = 'line-through';
        if (el.properties.decoration === 'overline') div.style.textDecoration = 'overline';
        if (el.properties.link) {
          div.style.cursor = 'pointer';
          div.style.textDecoration = 'underline';
          div.style.color = el.properties.color || '#0066cc';
          div.title = `Link: ${el.properties.link}`;
        }
        preview.appendChild(div);
      }
      else if (el.type === 'image') {
        const box = document.createElement('div');
        box.className = 'preview-image';
        const url = el.properties.url || '';
        const borderRadius = el.properties.borderRadius || 0;
        const opacity = el.properties.opacity !== undefined ? el.properties.opacity : 1;

        // Determinar dimensões para preview
        let previewWidth = '200px';
        let previewHeight = 'auto';
        if (el.properties.fit && Array.isArray(el.properties.fit)) {
          previewWidth = `${el.properties.fit[0]}px`;
          previewHeight = `${el.properties.fit[1]}px`;
        } else if (el.properties.cover) {
          previewWidth = `${el.properties.cover.width || 300}px`;
          previewHeight = `${el.properties.cover.height || 150}px`;
        } else {
          if (el.properties.width) previewWidth = `${el.properties.width}px`;
          if (el.properties.height) previewHeight = `${el.properties.height}px`;
        }

        // Aplicar dimensões ao box também para garantir que o wrapper tenha o tamanho correto
        box.style.width = previewWidth;
        if (previewHeight !== 'auto') {
          box.style.height = previewHeight;
        }

        if (url) {
          const img = document.createElement('img');
          // Usar base64 para preview se disponível, senão usar URL original
          const imageSrc = el.properties._base64Preview || url;
          img.src = imageSrc;
          img.style.width = previewWidth;
          img.style.height = previewHeight;
          img.style.opacity = opacity;

          // Aplicar object-fit baseado no modo
          if (el.properties.fit) {
            img.style.objectFit = 'contain';
          } else if (el.properties.cover) {
            img.style.objectFit = 'cover';
          } else {
            img.style.objectFit = 'contain';
          }

          if (borderRadius > 0) {
            img.style.borderRadius = `${borderRadius}px`;
          }

          // Se não há base64 e é uma URL HTTP/HTTPS, tentar converter em background
          if (!el.properties._base64Preview && (url.startsWith('http://') || url.startsWith('https://'))) {
            // Tentar converter para base64 em background (não bloqueia a renderização)
            convertImageUrlToBase64(url).then(base64 => {
              if (base64 && el.properties.url === url) {
                el.properties._base64Preview = base64;
                img.src = base64;
              }
            }).catch(() => {
              // Silenciosamente falhar - manter URL original
            });
          }

          img.onerror = () => {
            img.style.display = 'none';
            const ph = document.createElement('div');
            ph.className = 'preview-image-box';
            ph.style.width = previewWidth;
            ph.style.height = previewHeight === 'auto' ? '150px' : previewHeight;
            ph.textContent = 'Erro ao carregar';
            box.appendChild(ph);
          };
          box.appendChild(img);
        } else {
          const ph = document.createElement('div');
          ph.className = 'preview-image-box';
          ph.style.width = previewWidth;
          ph.style.height = previewHeight === 'auto' ? '150px' : previewHeight;
          ph.textContent = 'Imagem';
          box.appendChild(ph);
        }

        // Posicionamento já aplicado no wrapper principal, não precisa aplicar aqui novamente
        // Apenas garantir que o box não tenha posicionamento próprio
        box.style.position = 'static';

        preview.appendChild(box);
      }
      else if (el.type === 'columns') {
        const colsWrap = document.createElement('div');
        colsWrap.className = 'preview-columns';
        colsWrap.style.gap = (Number(el.properties.gap || 10)) + 'px';

        // Aplicar alinhamento vertical se configurado
        if (el.properties.valign) {
          if (el.properties.valign === 'center') {
            colsWrap.style.alignItems = 'center';
          } else if (el.properties.valign === 'bottom') {
            colsWrap.style.alignItems = 'flex-end';
          } else {
            colsWrap.style.alignItems = 'flex-start';
          }
        }

        const cols = el.properties.columns || [];
        cols.forEach((col, idx) => {
          const colDiv = document.createElement('div');
          colDiv.className = 'preview-column';

          // Aplicar largura da coluna
          const width = col.width || '*';
          if (width === '*' || width === 'auto') {
            colDiv.style.flex = '1 1 0';
          } else if (typeof width === 'number') {
            colDiv.style.width = `${width}px`;
            colDiv.style.flex = '0 0 auto';
          } else if (typeof width === 'string' && width.endsWith('%')) {
            const percent = parseFloat(width.replace('%', '')) || 0;
            colDiv.style.width = `${percent}%`;
            colDiv.style.flex = '0 0 auto';
          } else {
            colDiv.style.flex = '1 1 0';
          }

          // dropzone por coluna
          colDiv.setAttribute('data-drop-kind', 'columnsCol');
          colDiv.setAttribute('data-target-id', el.id);
          colDiv.setAttribute('data-col-index', String(idx));
          colDiv.addEventListener('dragover', onDropZoneOver);
          colDiv.addEventListener('dragleave', onDropZoneLeave);
          colDiv.addEventListener('drop', onDropZoneDrop);

          const kids = col.children || [];
          if (kids.length === 0) {
            const ph = document.createElement('div');
            ph.className = 'smallNote';
            ph.textContent = `Coluna ${idx + 1}: arraste aqui`;
            colDiv.appendChild(ph);
          } else {
            kids.forEach(k => colDiv.appendChild(renderElementRecursive(k)));
          }
          colsWrap.appendChild(colDiv);
        });

        preview.appendChild(colsWrap);
      }
      else if (el.type === 'list') {
        const list = document.createElement(el.properties.listType === 'ol' ? 'ol' : 'ul');
        list.className = 'preview-list';

        // dropzone no container da lista (para adicionar novos itens quando solto fora dos itens existentes)
        list.setAttribute('data-drop-kind', 'listItems');
        list.setAttribute('data-target-id', el.id);
        list.addEventListener('dragover', onDropZoneOver);
        list.addEventListener('dragleave', onDropZoneLeave);
        list.addEventListener('drop', onDropZoneDrop);

        const items = el.properties.items || [];
        if (items.length === 0) {
          const li = document.createElement('li');
          li.textContent = 'Arraste aqui para adicionar item';
          list.appendChild(li);
        } else {
          items.forEach((it, idx) => {
            const li = document.createElement('li');
            li.style.border = '1px dashed #9ca3af';
            li.style.borderRadius = '0.5rem';
            li.style.padding = '0.5rem';
            li.style.marginBottom = '0.5rem';
            li.style.minHeight = '2rem';
            li.style.position = 'relative';

            // Dropzone individual para cada item (permite substituir o conteúdo)
            li.setAttribute('data-drop-kind', 'listItemReplace');
            li.setAttribute('data-target-id', el.id);
            li.setAttribute('data-item-index', String(idx));

            // Handlers separados para garantir que o item tenha prioridade sobre o container
            li.addEventListener('dragover', (e) => {
              e.preventDefault();
              e.stopPropagation(); // Impede que o evento chegue ao container da lista
              li.classList.add('drag-over');
              li.style.backgroundColor = '#e0f2fe';
              li.style.borderColor = '#0284c7';
            });

            li.addEventListener('dragleave', (e) => {
              e.stopPropagation();
              li.classList.remove('drag-over');
              li.style.backgroundColor = '';
              li.style.borderColor = '#9ca3af';
            });

            li.addEventListener('drop', (e) => {
              e.preventDefault();
              e.stopPropagation(); // CRÍTICO: impede que o evento chegue ao container da lista
              li.classList.remove('drag-over');
              li.style.backgroundColor = '';
              li.style.borderColor = '#9ca3af';

              const type = (e.dataTransfer && e.dataTransfer.getData("text/plain")) || draggedType;
              if (!type) return;

              // Chamar insertIntoTarget diretamente para substituir o item
              insertIntoTarget({
                kind: 'listItemReplace',
                targetId: el.id,
                itemIndex: idx
              }, type);
            });

            if (it.kind === 'text') {
              li.textContent = it.text || '';
            } else if (it.kind === 'node' && it.node) {
              li.appendChild(renderElementRecursive(it.node));
            }
            list.appendChild(li);
          });
        }
        preview.appendChild(list);
      }
      else if (el.type === 'table') {
        const tbl = document.createElement('table');
        tbl.className = 'preview-table';

        const body = el.properties.body || [];
        const heights = el.properties.heights;
        const customLayout = el.properties.customLayout || {};

        // Aplicar bordas da tabela baseado no layout customizado
        // Se hLineWidth ou vLineWidth estiverem definidos, aplicar bordas
        const hLineWidth = customLayout.hLineWidth !== undefined ? Number(customLayout.hLineWidth) : null;
        const vLineWidth = customLayout.vLineWidth !== undefined ? Number(customLayout.vLineWidth) : null;
        const hLineColor = customLayout.hLineColor || '#000000';
        const vLineColor = customLayout.vLineColor || '#000000';

        // Se layout for customizado, aplicar bordas dinamicamente
        if (el.properties.layout === 'custom' && (hLineWidth !== null || vLineWidth !== null)) {
          // Aplicar bordas baseadas nas configurações
          if (hLineWidth !== null && hLineWidth > 0) {
            tbl.style.borderTop = `${hLineWidth}px solid ${hLineColor}`;
            tbl.style.borderBottom = `${hLineWidth}px solid ${hLineColor}`;
          }
          if (vLineWidth !== null && vLineWidth > 0) {
            tbl.style.borderLeft = `${vLineWidth}px solid ${vLineColor}`;
            tbl.style.borderRight = `${vLineWidth}px solid ${vLineColor}`;
          }
        }

        for (let r = 0; r < body.length; r++) {
          const tr = document.createElement('tr');
          const isHeaderRow = r === 0; // Primeira linha é o cabeçalho

          // Aplicar altura da linha (heights)
          if (heights) {
            if (typeof heights === 'number') {
              tr.style.height = heights + 'px';
            } else if (Array.isArray(heights) && heights[r] !== undefined) {
              tr.style.height = heights[r] + 'px';
            }
          }

          // Aplicar bordas horizontais baseadas no layout customizado
          if (el.properties.layout === 'custom' && hLineWidth !== null && hLineWidth > 0) {
            // Aplicar borda inferior em todas as linhas
            tr.style.borderBottom = `${hLineWidth}px solid ${hLineColor}`;
            // Aplicar borda superior na primeira linha
            if (r === 0) {
              tr.style.borderTop = `${hLineWidth}px solid ${hLineColor}`;
            }
          } else if (isHeaderRow) {
            // Layout padrão - apenas borda no cabeçalho
            tr.style.backgroundColor = '#f3f4f6';
            tr.style.fontWeight = 'bold';
            tr.style.borderBottom = '2px solid #d1d5db';
          }

          // Rastrear células já cobertas por rowSpan/colSpan
          const coveredCells = new Set();

          for (let c = 0; c < body[r].length; c++) {
            // Pular células já cobertas por colSpan
            if (coveredCells.has(`${r}-${c}`)) {
              continue;
            }

            const td = document.createElement('td');
            td.style.verticalAlign = 'top';
            const cell = body[r][c];

            // Se layout customizado estiver ativo, remover bordas padrão do CSS
            if (el.properties.layout === 'custom') {
              td.style.border = 'none'; // Remover borda padrão
            }

            // Aplicar bordas verticais baseadas no layout customizado
            if (el.properties.layout === 'custom' && vLineWidth !== null && vLineWidth > 0) {
              // Aplicar borda direita em todas as células (exceto a última coluna)
              if (c < body[r].length - 1) {
                td.style.borderRight = `${vLineWidth}px solid ${vLineColor}`;
              }
              // Aplicar borda esquerda na primeira coluna
              if (c === 0) {
                td.style.borderLeft = `${vLineWidth}px solid ${vLineColor}`;
              }
            }

            // Aplicar bordas horizontais baseadas no layout customizado (nas células)
            if (el.properties.layout === 'custom' && hLineWidth !== null && hLineWidth > 0) {
              // Aplicar borda superior na primeira linha
              if (r === 0) {
                td.style.borderTop = `${hLineWidth}px solid ${hLineColor}`;
              }
              // Aplicar borda inferior em todas as linhas
              td.style.borderBottom = `${hLineWidth}px solid ${hLineColor}`;
            }

            // Verificar se esta célula está vazia (string vazia ou null)
            if (!cell || (typeof cell === 'string' && cell === '')) {
              // Célula vazia - renderizar como vazia mas ainda adicionar à linha
              tr.appendChild(td);
              continue;
            }

            // Se não for objeto, tratar como string simples
            const cellObj = (typeof cell === 'object' && cell !== null) ? cell : { children: [] };

            // Aplicar rowSpan e colSpan
            if (cellObj.rowSpan && cellObj.rowSpan > 1) {
              td.setAttribute('rowspan', cellObj.rowSpan);
              // Marcar células abaixo como cobertas
              for (let sr = 1; sr < cellObj.rowSpan; sr++) {
                coveredCells.add(`${r + sr}-${c}`);
              }
            }
            if (cellObj.colSpan && cellObj.colSpan > 1) {
              td.setAttribute('colspan', cellObj.colSpan);
              // Marcar células à direita como cobertas
              for (let sc = 1; sc < cellObj.colSpan; sc++) {
                coveredCells.add(`${r}-${c + sc}`);
              }
            }

            // Aplicar border (array de 4 booleanos) - sobrescreve bordas do layout customizado se definido
            if (cellObj.border && Array.isArray(cellObj.border)) {
              if (!cellObj.border[0]) td.style.borderLeft = 'none';
              if (!cellObj.border[1]) td.style.borderTop = 'none';
              if (!cellObj.border[2]) td.style.borderRight = 'none';
              if (!cellObj.border[3]) td.style.borderBottom = 'none';
            }

            // Aplicar borderColor (array de 4 cores) - sobrescreve cores do layout customizado se definido
            if (cellObj.borderColor && Array.isArray(cellObj.borderColor)) {
              if (cellObj.borderColor[0]) td.style.borderLeftColor = cellObj.borderColor[0];
              if (cellObj.borderColor[1]) td.style.borderTopColor = cellObj.borderColor[1];
              if (cellObj.borderColor[2]) td.style.borderRightColor = cellObj.borderColor[2];
              if (cellObj.borderColor[3]) td.style.borderBottomColor = cellObj.borderColor[3];
            }

            // Aplicar estilos da célula (fillColor, color, fillOpacity)
            // Tabela zebrada tem prioridade sobre fillColor individual
            if (el.properties.zebraEnabled && el.properties.zebraColor) {
              // Aplicar zebra seguindo o padrão do exemplo: linhas pares (0, 2, 4...) = cor, linhas ímpares (1, 3, 5...) = null
              // Mas cabeçalho (r=0) não recebe zebra
              if (!isHeaderRow && r % 2 === 0) {
                const baseColor = el.properties.zebraColor;
                td.style.backgroundColor = baseColor;
              } else if (!isHeaderRow) {
                // Linhas ímpares = transparente (null no PDF)
                td.style.backgroundColor = 'transparent';
              }
            } else if (cellObj.fillColor) {
              const opacity = cellObj.fillOpacity !== undefined ? cellObj.fillOpacity : 1;
              td.style.backgroundColor = cellObj.fillColor;
              td.style.opacity = opacity;
            } else if (isHeaderRow) {
              td.style.backgroundColor = '#f9fafb';
            }

            if (cellObj.color) {
              td.style.color = cellObj.color;
            }

            // Padding padrão ou customizado
            if (el.properties.customLayout) {
              const cl = el.properties.customLayout;
              td.style.paddingLeft = (cl.paddingLeft || 5) + 'px';
              td.style.paddingRight = (cl.paddingRight || 5) + 'px';
              td.style.paddingTop = (cl.paddingTop || 5) + 'px';
              td.style.paddingBottom = (cl.paddingBottom || 5) + 'px';
            } else if (isHeaderRow) {
              td.style.padding = '0.5rem';
            }

            // dropzone por célula
            td.setAttribute('data-drop-kind', 'tableCell');
            td.setAttribute('data-target-id', el.id);
            td.setAttribute('data-row', String(r));
            td.setAttribute('data-col', String(c));
            td.addEventListener('dragover', onDropZoneOver);
            td.addEventListener('dragleave', onDropZoneLeave);
            td.addEventListener('drop', onDropZoneDrop);

            const kids = (cellObj.children || []);
            if (kids.length === 0) {
              const placeholderColor = cellObj.color || (isHeaderRow ? '#6b7280' : '#9ca3af');
              if (isHeaderRow) {
                td.innerHTML = `<span style="color:${placeholderColor};font-size:12px;font-weight:bold;">Cabeçalho ${c + 1} - Arraste aqui</span>`;
              } else {
                td.innerHTML = `<span style="color:${placeholderColor};font-size:12px">Arraste aqui</span>`;
              }
            } else {
              kids.forEach(k => td.appendChild(renderElementRecursive(k)));
            }
            tr.appendChild(td);
          }
          tbl.appendChild(tr);
        }
        preview.appendChild(tbl);
      }
      else if (el.type === 'margin') {
        const div = document.createElement('div');
        div.className = 'preview-margin';
        const marginSize = Number(el.properties.size || 20);
        div.style.height = `${marginSize}px`;
        div.style.minHeight = `${marginSize}px`;
        div.style.display = 'flex';
        div.style.alignItems = 'center';
        div.style.justifyContent = 'center';
        div.textContent = `Espaço (${marginSize}px)`;
        preview.appendChild(div);
      }
      else if (el.type === 'pageBreak') {
        const div = document.createElement('div');
        div.className = 'preview-pagebreak';
        div.textContent = 'Quebra de página';
        preview.appendChild(div);
      }
      else if (el.type === 'qr') {
        const box = document.createElement('div');
        box.className = 'preview-qr';
        box.style.width = `${el.properties.fit || 100}px`;
        box.style.height = `${el.properties.fit || 100}px`;
        box.style.border = `2px solid ${el.properties.foreground || '#000000'}`;
        box.style.display = 'flex';
        box.style.alignItems = 'center';
        box.style.justifyContent = 'center';
        box.style.background = el.properties.background || '#ffffff';
        const foregroundColor = el.properties.foreground || '#000000';
        box.innerHTML = `<div style="font-size: 0.75rem; color: ${foregroundColor}; font-weight: bold;">QR Code</div>`;
        preview.appendChild(box);
      }
      else if (el.type === 'svg') {
        const box = document.createElement('div');
        box.className = 'preview-svg';
        box.style.width = `${el.properties.width || 100}px`;
        box.style.height = `${el.properties.height || 100}px`;
        box.style.border = '1px solid #d1d5db';
        box.style.display = 'flex';
        box.style.alignItems = 'center';
        box.style.justifyContent = 'center';
        try {
          // Tentar renderizar o SVG
          const parser = new DOMParser();
          const svgDoc = parser.parseFromString(el.properties.svg || '', 'image/svg+xml');
          const svgElement = svgDoc.documentElement;
          if (svgElement && svgElement.tagName === 'svg') {
            svgElement.setAttribute('width', el.properties.width || 100);
            svgElement.setAttribute('height', el.properties.height || 100);
            if (el.properties.color) {
              svgElement.setAttribute('fill', el.properties.color);
            }
            box.appendChild(svgElement);
          } else {
            box.innerHTML = '<div style="font-size: 0.75rem; color: #6b7280;">SVG</div>';
          }
        } catch (e) {
          box.innerHTML = '<div style="font-size: 0.75rem; color: #ef4444;">Erro no SVG</div>';
        }
        preview.appendChild(box);
      }
      else if (el.type === 'barcode') {
        const box = document.createElement('div');
        box.className = 'preview-barcode';
        box.style.display = 'flex';
        box.style.alignItems = 'center';
        box.style.justifyContent = 'center';
        box.style.padding = '1rem';
        box.style.minHeight = '60px';
        box.style.border = '1px solid #d1d5db';
        box.style.borderRadius = '0.375rem';
        box.style.background = '#ffffff';

        try {
          // Gerar SVG do barcode usando JsBarcode
          const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          const p = el.properties || {};

          if (typeof JsBarcode !== 'undefined') {
            JsBarcode(svg, p.barcodeValue || "", {
              format: p.format || "CODE128",
              width: Number(p.lineWidth) || 1.5,
              height: Number(p.barHeight) || 30,
              displayValue: p.displayValue !== false,
              fontSize: Number(p.fontSize) || 10,
              margin: Number(p.margin) || 0
            });
            box.appendChild(svg);
          } else {
            box.innerHTML = '<div style="font-size: 0.75rem; color: #6b7280;">Barcode: ' + escapeHtml(p.barcodeValue || '') + '</div>';
          }
        } catch (e) {
          box.innerHTML = '<div style="font-size: 0.75rem; color: #ef4444;">Barcode inválido</div>';
        }

        preview.appendChild(box);
      }
      else if (el.type === 'stamp') {
        const box = document.createElement('div');
        box.className = 'preview-stamp';
        const p = el.properties || {};
        const fit = Array.isArray(p.fit) ? p.fit : [p.fit || 120, p.fit || 120];
        box.style.width = `${fit[0]}px`;
        box.style.height = `${fit[1]}px`;
        box.style.border = '1px solid #d1d5db';
        box.style.display = 'flex';
        box.style.alignItems = 'center';
        box.style.justifyContent = 'center';
        box.style.background = '#f9fafb';
        box.style.opacity = p.opacity !== undefined ? p.opacity : 1;

        if (p.sourceType === 'image' && p.value) {
          const img = document.createElement('img');
          img.src = p.value;
          img.style.maxWidth = '100%';
          img.style.maxHeight = '100%';
          img.style.objectFit = 'contain';
          img.onerror = () => {
            box.innerHTML = '<div style="font-size: 0.75rem; color: #ef4444;">Erro ao carregar imagem</div>';
          };
          box.appendChild(img);
        } else if (p.sourceType === 'svg' && p.value) {
          try {
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(p.value, 'image/svg+xml');
            const svgElement = svgDoc.documentElement;
            if (svgElement && svgElement.tagName === 'svg') {
              svgElement.setAttribute('width', fit[0]);
              svgElement.setAttribute('height', fit[1]);
              box.appendChild(svgElement);
            } else {
              box.innerHTML = '<div style="font-size: 0.75rem; color: #6b7280;">Carimbo / Selo</div>';
            }
          } catch (e) {
            box.innerHTML = '<div style="font-size: 0.75rem; color: #ef4444;">Erro no SVG</div>';
          }
        } else {
          box.innerHTML = '<div style="font-size: 0.75rem; color: #6b7280;">Carimbo / Selo</div>';
        }
        preview.appendChild(box);
      }
      else if (el.type === 'checkbox' || el.type === 'radio') {
        const box = document.createElement('div');
        box.className = `preview-${el.type}`;
        const p = el.properties || {};
        const choiceType = p.choiceType || el.type;
        const choiceText = p.choiceText || 'Texto...';
        const choiceChecked = p.choiceChecked === true;
        const choiceIconPosition = p.choiceIconPosition || 'before';
        const choiceGap = Number(p.choiceGap || 8);
        const choiceIconSize = Number(p.choiceIconSize || 12);

        box.style.display = 'flex';
        box.style.flexDirection = 'row';
        box.style.alignItems = 'center';
        box.style.gap = `${choiceGap}px`;
        box.style.justifyContent = p.alignment === 'center' ? 'center' : p.alignment === 'right' ? 'flex-end' : 'flex-start';
        box.style.width = '100%';
        box.style.minHeight = `${choiceIconSize + 4}px`;

        // Função para gerar SVG do ícone
        function generateIconSVG(type, checked, size) {
          const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          svg.setAttribute('width', size);
          svg.setAttribute('height', size);
          svg.setAttribute('viewBox', `0 0 ${size} ${size}`);
          svg.style.flexShrink = '0';

          if (type === 'checkbox') {
            const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            rect.setAttribute('x', '1');
            rect.setAttribute('y', '1');
            rect.setAttribute('width', size - 2);
            rect.setAttribute('height', size - 2);
            rect.setAttribute('fill', 'none');
            rect.setAttribute('stroke', '#000');
            rect.setAttribute('stroke-width', '1');
            svg.appendChild(rect);

            if (checked) {
              const check = document.createElementNS("http://www.w3.org/2000/svg", "path");
              check.setAttribute('d', `M 3 ${size * 0.5} L ${size * 0.4} ${size * 0.7} L ${size * 0.8} ${size * 0.3}`);
              check.setAttribute('fill', 'none');
              check.setAttribute('stroke', '#000');
              check.setAttribute('stroke-width', '1.3');
              check.setAttribute('stroke-linecap', 'round');
              check.setAttribute('stroke-linejoin', 'round');
              svg.appendChild(check);
            }
          } else if (type === 'radio') {
            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute('cx', size / 2);
            circle.setAttribute('cy', size / 2);
            circle.setAttribute('r', size / 2 - 1);
            circle.setAttribute('fill', 'none');
            circle.setAttribute('stroke', '#000');
            circle.setAttribute('stroke-width', '1');
            svg.appendChild(circle);

            if (checked) {
              const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
              dot.setAttribute('cx', size / 2);
              dot.setAttribute('cy', size / 2);
              dot.setAttribute('r', size / 4);
              dot.setAttribute('fill', '#000');
              svg.appendChild(dot);
            }
          }

          return svg;
        }

        const iconSVG = generateIconSVG(choiceType, choiceChecked, choiceIconSize);
        const textDiv = document.createElement('div');
        textDiv.textContent = choiceText;
        textDiv.style.flex = '1';
        textDiv.style.fontSize = '14px';
        textDiv.style.color = '#111827';

        if (choiceIconPosition === 'before') {
          box.appendChild(iconSVG);
          box.appendChild(textDiv);
        } else {
          box.appendChild(textDiv);
          box.appendChild(iconSVG);
        }

        preview.appendChild(box);
      }
      else if (el.type === 'fillLine') {
        const box = document.createElement('div');
        box.className = 'preview-fillline';
        const p = el.properties || {};
        const lineWidth = Number(p.lineWidth || 200);
        const thickness = Number(p.thickness || 0.8);
        const color = p.color || '#000000';

        box.style.width = `${lineWidth}px`;
        box.style.height = `${thickness + 4}px`;
        box.style.display = 'flex';
        box.style.alignItems = 'center';
        box.style.justifyContent = p.alignment === 'center' ? 'center' : p.alignment === 'right' ? 'flex-end' : 'flex-start';

        const line = document.createElement('div');
        line.style.width = `${lineWidth}px`;
        line.style.height = `${thickness}px`;
        line.style.backgroundColor = color;
        line.style.borderRadius = '1px';
        box.appendChild(line);
        preview.appendChild(box);
      }
      else if (el.type === 'chart') {
        const box = document.createElement('div');
        box.className = 'preview-chart';
        const p = el.properties || {};
        const width = Number(p.chartWidth || 400);
        const height = Number(p.chartHeight || 200);

        box.style.width = `${width}px`;
        box.style.height = `${height}px`;
        box.style.border = '1px solid #d1d5db';
        box.style.borderRadius = '0.375rem';
        box.style.background = p.chartBackgroundColor || '#FFFFFF';
        box.style.position = 'relative';
        box.style.display = 'flex';
        box.style.alignItems = 'center';
        box.style.justifyContent = 'center';

        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        canvas.style.maxWidth = '100%';
        canvas.style.maxHeight = '100%';
        box.appendChild(canvas);

        // Renderizar gráfico usando Chart.js se disponível
        if (typeof Chart !== 'undefined') {
          try {
            const ctx = canvas.getContext('2d');
            const chartData = p.chartData || { labels: [], datasets: [] };
            const chartOptions = {
              ...(p.chartOptions || {}),
              responsive: false,
              animation: { duration: 0 },
              maintainAspectRatio: false
            };

            const chart = new Chart(ctx, {
              type: p.chartType || 'bar',
              data: chartData,
              options: chartOptions
            });

            // Armazenar referência do chart para destruir depois
            box._chart = chart;
          } catch (e) {
            box.innerHTML = '<div style="font-size: 0.75rem; color: #ef4444;">Erro ao renderizar gráfico</div>';
          }
        } else {
          box.innerHTML = '<div style="font-size: 0.75rem; color: #6b7280;">Chart.js não carregado</div>';
        }

        preview.appendChild(box);
      }
      else {
        preview.textContent = elementLabel(el);
      }

      wrapper.appendChild(preview);
      return wrapper;
    }

    function renderCanvas(shouldAdjustSize = true) {
      const root = getRootGroup();

      // Limpar canvas
      elementsList.innerHTML = '';

      // Renderizar Header se ativado
      if (documentHeader.enabled && documentHeader.root) {
        const headerContainer = document.createElement('div');
        headerContainer.className = 'header-container';
        headerContainer.setAttribute('data-header-container', 'true');
        // Removido position: sticky para que role junto com o conteúdo
        // Mantém apenas o estilo visual, sem fixação durante scroll
        headerContainer.style.background = '#f9fafb';
        headerContainer.style.borderBottom = '2px solid #2563eb';
        headerContainer.style.padding = '1rem';
        headerContainer.style.marginBottom = '1rem';
        headerContainer.style.minHeight = `${documentHeader.height}px`;

        const headerLabel = document.createElement('div');
        headerLabel.style.fontSize = '0.75rem';
        headerLabel.style.fontWeight = '600';
        headerLabel.style.color = '#2563eb';
        headerLabel.style.marginBottom = '0.5rem';
        headerLabel.textContent = '📄 CABEÇALHO';
        headerContainer.appendChild(headerLabel);

        const headerContent = document.createElement('div');
        headerContent.className = 'header-content';
        headerContent.setAttribute('data-drop-kind', 'groupChildren');
        headerContent.setAttribute('data-target-id', documentHeader.root.id);
        headerContent.addEventListener('dragover', onDropZoneOver);
        headerContent.addEventListener('dragleave', onDropZoneLeave);
        headerContent.addEventListener('drop', onDropZoneDrop);

        const headerChildren = documentHeader.root.properties.children || [];
        if (headerChildren.length === 0) {
          const ph = document.createElement('div');
          ph.className = 'group-placeholder';
          ph.textContent = 'Arraste elementos aqui para o cabeçalho';
          headerContent.appendChild(ph);
        } else {
          headerChildren.forEach(ch => {
            headerContent.appendChild(renderElementRecursive(ch));
          });
        }

        headerContainer.appendChild(headerContent);
        elementsList.appendChild(headerContainer);
      }

      // Renderizar conteúdo principal
      if (!root) {
        canvasEmpty.style.display = 'flex';
        elementsList.style.display = 'none';
        // Resetar altura do canvas quando vazio
        canvas.style.height = 'auto';
        canvas.style.minHeight = '842px';
        return;
      }
      canvasEmpty.style.display = 'none';
      elementsList.style.display = 'flex';

      elementsList.appendChild(renderElementRecursive(root));

      // Renderizar Footer se ativado
      if (documentFooter.enabled && documentFooter.root) {
        const footerContainer = document.createElement('div');
        footerContainer.className = 'footer-container';
        footerContainer.setAttribute('data-footer-container', 'true');
        // Removido position: sticky para que role junto com o conteúdo
        // Mantém apenas o estilo visual, sem fixação durante scroll
        footerContainer.style.background = '#f9fafb';
        footerContainer.style.borderTop = '2px solid #2563eb';
        footerContainer.style.padding = '1rem';
        footerContainer.style.marginTop = '1rem';
        footerContainer.style.minHeight = `${documentFooter.height}px`;

        const footerLabel = document.createElement('div');
        footerLabel.style.fontSize = '0.75rem';
        footerLabel.style.fontWeight = '600';
        footerLabel.style.color = '#2563eb';
        footerLabel.style.marginBottom = '0.5rem';
        footerLabel.textContent = '📄 RODAPÉ';
        footerContainer.appendChild(footerLabel);

        const footerContent = document.createElement('div');
        footerContent.className = 'footer-content';
        footerContent.setAttribute('data-drop-kind', 'groupChildren');
        footerContent.setAttribute('data-target-id', documentFooter.root.id);
        footerContent.addEventListener('dragover', onDropZoneOver);
        footerContent.addEventListener('dragleave', onDropZoneLeave);
        footerContent.addEventListener('drop', onDropZoneDrop);

        const footerChildren = documentFooter.root.properties.children || [];
        if (footerChildren.length === 0) {
          const ph = document.createElement('div');
          ph.className = 'group-placeholder';
          ph.textContent = 'Arraste elementos aqui para o rodapé';
          footerContent.appendChild(ph);
        } else {
          footerChildren.forEach(ch => {
            footerContent.appendChild(renderElementRecursive(ch));
          });
        }

        footerContainer.appendChild(footerContent);
        elementsList.appendChild(footerContainer);
      }

      applyZoom();

      // Ajustar altura e largura do canvas dinamicamente baseado no conteúdo
      // IMPORTANTE: Só ajustar se solicitado E se permitido (apenas quando elementos são adicionados/removidos)
      if (shouldAdjustSize && allowCanvasSizeAdjust) {
        // Usar setTimeout para garantir que o DOM está completamente renderizado
        // Isso evita medições incorretas que causam crescimento infinito
        setTimeout(() => {
          if (allowCanvasSizeAdjust) {
            adjustCanvasSize();
            // Desativar imediatamente após ajustar para evitar ajustes em cliques subsequentes
            allowCanvasSizeAdjust = false;
          }
        }, 50);
      }
    }

    /**
     * Função central para auto-redimensionar a página/canvas baseado no conteúdo real
     * Ajusta tanto ALTURA quanto LARGURA dinamicamente, sem impor limites artificiais
     * 
     * Comportamento:
     * - Mede o conteúdo REAL usando scrollWidth/scrollHeight
     * - Aplica o tamanho calculado no canvas
     * - Não altera layout visual, apenas tamanho do container
     * - Não afeta o output do PDF (apenas visual do editor)
     */
    let isAdjustingCanvasSize = false; // Flag para evitar chamadas recursivas
    let lastCanvasWidth = 0; // Armazenar última largura aplicada para evitar recálculos desnecessários
    let lastCanvasHeight = 0; // Armazenar última altura aplicada para evitar recálculos desnecessários

    // Função auxiliar para resetar cache de tamanho do canvas quando conteúdo muda
    // IMPORTANTE: Só resetar quando há mudanças estruturais reais (adicionar/remover elementos)
    // NÃO resetar durante edições de propriedades (texto, cores, etc.)
    function resetCanvasSizeCache() {
      lastCanvasWidth = 0;
      lastCanvasHeight = 0;
    }

    // Flag para indicar se estamos em modo de edição (não ajustar tamanho)
    let isEditingMode = false;

    // Flag para permitir ajuste de tamanho apenas quando elementos são adicionados/removidos
    let allowCanvasSizeAdjust = false;

    function adjustCanvasSize() {
      // Evitar chamadas recursivas que podem causar crescimento infinito
      if (isAdjustingCanvasSize) return;

      // IMPORTANTE: Não ajustar tamanho durante edições de propriedades
      // Isso evita crescimento infinito ao editar texto, cores, posições, etc.
      if (isEditingMode) {
        return;
      }

      // IMPORTANTE: Só ajustar tamanho quando explicitamente permitido (adicionar/remover elementos)
      // Isso evita crescimento infinito ao clicar em elementos ou no canvas
      if (!allowCanvasSizeAdjust) {
        return;
      }

      isAdjustingCanvasSize = true;

      // IMPORTANTE: Desativar allowCanvasSizeAdjust imediatamente para evitar múltiplas chamadas
      allowCanvasSizeAdjust = false;

      // Aguardar múltiplos frames para garantir que o DOM foi completamente atualizado
      // Isso é importante para elementos aninhados e transições CSS
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          if (!elementsList || !canvas) {
            isAdjustingCanvasSize = false;
            return;
          }

          // ==========================================
          // AJUSTAR ALTURA (já funcionando, manter lógica)
          // ==========================================
          if (elementsList.children.length === 0) {
            // Se não há elementos, manter altura mínima
            canvas.style.height = 'auto';
            canvas.style.minHeight = '842px';
          } else {
            // Calcular altura total do conteúdo
            // Padding do canvas: 2rem top + 2rem bottom = 64px total
            const canvasPaddingTop = 32; // 2rem
            const canvasPaddingBottom = 32; // 2rem

            // Obter altura total da lista de elementos
            // Usar scrollHeight para pegar a altura real incluindo elementos que podem estar fora da viewport
            const elementsListHeight = elementsList.scrollHeight;

            // Calcular altura total: altura dos elementos + padding do canvas
            const totalHeight = elementsListHeight + canvasPaddingTop + canvasPaddingBottom;

            // Altura mínima é 842px (tamanho A4 portrait em pixels a 96dpi)
            const minHeight = 842;

            // Definir altura do canvas (mínimo ou altura calculada, o que for maior)
            // Adicionar uma pequena margem de segurança (20px) para evitar cortes
            const newHeight = Math.max(minHeight, totalHeight + 20);

            // Só aplicar se a diferença for significativa (mais de 15px)
            const currentHeight = lastCanvasHeight > 0 ? lastCanvasHeight : (parseInt(canvas.style.height) || canvas.offsetHeight || minHeight);
            const heightDifference = Math.abs(newHeight - currentHeight);

            if (heightDifference > 15) {
              canvas.style.height = newHeight + 'px';
              canvas.style.minHeight = minHeight + 'px';
              lastCanvasHeight = newHeight;
            } else {
              if (lastCanvasHeight === 0) {
                lastCanvasHeight = currentHeight;
              }
            }
          }

          // ==========================================
          // AJUSTAR LARGURA (nova implementação)
          // ==========================================
          // IMPORTANTE: Fazer TODAS as medições ANTES de alterar qualquer estilo
          // Isso evita reflows que causam crescimento incremental

          const canvasPaddingLeft = 32; // 2rem
          const canvasPaddingRight = 32; // 2rem
          const minWidth = 595; // Largura mínima A4 portrait

          // 1. Obter largura atual do canvas ANTES de qualquer medição
          // Isso garante que não estamos comparando com valores já alterados
          // Usar a última largura aplicada se disponível, senão usar o valor atual
          const currentCanvasWidth = lastCanvasWidth > 0 ? lastCanvasWidth : (parseInt(canvas.style.width) || canvas.offsetWidth || minWidth);

          // 2. Medir o scrollWidth do elementsList SEM alterar o DOM
          // IMPORTANTE: Não alterar temporariamente o width do elementsList para evitar reflows que causam loops
          let contentWidth = elementsList.scrollWidth || elementsList.offsetWidth || 0;

          // 3. Verificar elementos raiz diretamente para garantir que capturamos tudo
          // Elementos raiz são os .element-item que estão diretamente dentro de .elements-list
          const rootElements = Array.from(elementsList.children).filter(
            child => child.classList.contains('element-item') ||
              child.classList.contains('header-container') ||
              child.classList.contains('footer-container')
          );

          rootElements.forEach(rootEl => {
            // Para cada elemento raiz, medir sua largura real
            const rootScrollWidth = rootEl.scrollWidth || 0;
            const rootOffsetWidth = rootEl.offsetWidth || 0;
            const rootWidth = Math.max(rootScrollWidth, rootOffsetWidth);

            if (rootWidth > contentWidth) {
              contentWidth = rootWidth;
            }

            // Verificar também elementos dentro deste root (tabelas, grupos, etc.)
            // Buscar todas as tabelas dentro deste elemento
            const tablesInRoot = rootEl.querySelectorAll('table, .preview-table');
            tablesInRoot.forEach(table => {
              // Para tabelas, calcular largura real somando células
              // Estratégia: somar a largura de todas as células da primeira linha
              let tableWidth = 0;
              const firstRow = table.querySelector('tr');

              if (firstRow) {
                const cells = firstRow.querySelectorAll('td, th');
                cells.forEach(cell => {
                  // scrollWidth captura a largura real do conteúdo, mesmo que esteja cortado
                  const cellScrollWidth = cell.scrollWidth || 0;
                  const cellOffsetWidth = cell.offsetWidth || 0;
                  const cellRect = cell.getBoundingClientRect();
                  // Usar o maior valor para garantir que capturamos a largura real
                  const cellWidth = Math.max(cellScrollWidth, cellOffsetWidth, cellRect.width);
                  tableWidth += cellWidth;
                });
              }

              // Se não conseguiu calcular pelas células, usar scrollWidth da tabela
              if (tableWidth === 0) {
                tableWidth = table.scrollWidth || table.offsetWidth || table.getBoundingClientRect().width;
              }

              // Considerar padding e bordas da tabela (getBoundingClientRect inclui isso)
              const tableRect = table.getBoundingClientRect();
              if (tableRect.width > tableWidth) {
                tableWidth = tableRect.width;
              }

              if (tableWidth > contentWidth) {
                contentWidth = tableWidth;
              }
            });
          });

          // 4. Calcular largura total necessária: largura do conteúdo + padding do canvas
          const totalWidth = contentWidth + canvasPaddingLeft + canvasPaddingRight;

          // 5. Definir largura do canvas (mínimo ou largura calculada, o que for maior)
          // Adicionar margem de segurança (30px) para evitar cortes de bordas/padding
          const newWidth = Math.max(minWidth, totalWidth + 30);

          // 6. Comparar com a largura atual ANTES de aplicar qualquer alteração
          // Só aplicar se a diferença for significativa (mais de 15px para evitar ajustes infinitos)
          // Isso evita ajustes infinitos por diferenças mínimas de arredondamento ou medições inconsistentes
          const widthDifference = Math.abs(newWidth - currentCanvasWidth);

          // IMPORTANTE: Limitar o crescimento máximo para evitar crescimento infinito
          // Se a nova largura for muito maior que a atual (mais de 200px), pode ser um erro de medição
          const maxWidthIncrease = 200; // Máximo de aumento permitido por vez
          const shouldApplyWidth = widthDifference > 15 && (newWidth <= currentCanvasWidth + maxWidthIncrease);

          if (shouldApplyWidth) {
            // 7. Aplicar largura no canvas APENAS se realmente necessário
            canvas.style.width = newWidth + 'px';
            canvas.style.minWidth = minWidth + 'px';
            canvas.style.maxWidth = 'none'; // Remover qualquer limite máximo

            // Armazenar a largura aplicada para evitar recálculos desnecessários
            lastCanvasWidth = newWidth;

            // 8. Garantir que containers pais não limitem o crescimento
            // O canvas-wrapper deve permitir que o canvas cresça
            // IMPORTANTE: Só alterar se realmente necessário para evitar reflows desnecessários
            const canvasWrapper = canvas.parentElement;
            if (canvasWrapper && canvasWrapper.classList.contains('canvas-wrapper')) {
              // Verificar se já está configurado corretamente antes de alterar
              if (canvasWrapper.style.maxWidth !== 'none') {
                canvasWrapper.style.width = 'auto';
                canvasWrapper.style.minWidth = '0';
                canvasWrapper.style.maxWidth = 'none';
              }
            }

            // 9. Garantir que elements-list também não limite o crescimento
            // elements-list deve poder crescer horizontalmente
            // IMPORTANTE: Só alterar se realmente necessário para evitar reflows desnecessários
            if (elementsList && elementsList.style.maxWidth !== 'none') {
              elementsList.style.width = 'auto';
              elementsList.style.minWidth = '0';
              elementsList.style.maxWidth = 'none';
            }
          } else {
            // Se não houve alteração, manter a última largura conhecida
            if (lastCanvasWidth === 0) {
              lastCanvasWidth = currentCanvasWidth;
            }
            // Se a nova largura é muito maior, pode ser um erro de medição - não aplicar
            if (newWidth > currentCanvasWidth + 200) {
              console.warn('Ajuste de largura do canvas ignorado - possível erro de medição:', {
                current: currentCanvasWidth,
                calculated: newWidth,
                difference: widthDifference
              });
            }
          }

          // 10. Liberar flag após completar o ajuste (importante para evitar loops infinitos)
          isAdjustingCanvasSize = false;
        });
      });
    }

    function selectElement(id) {
      // Evitar re-renderização desnecessária se o elemento já está selecionado
      if (selectedElementId === id) {
        return; // Já está selecionado, não precisa fazer nada
      }

      // Mostrar o painel se estiver oculto
      const panel = document.getElementById('codePanel');
      if (panel && panel.classList.contains('hidden')) {
        panel.classList.remove('hidden');
      }

      // Atualizar seleção visual sem recriar o DOM inteiro
      // Isso evita reflows desnecessários que causam crescimento infinito
      const prevSelected = selectedElementId ? document.querySelector(`[data-id="${selectedElementId}"]`) : null;
      if (prevSelected) {
        prevSelected.classList.remove('selected');
      }

      const newSelected = document.querySelector(`[data-id="${id}"]`);
      if (newSelected) {
        newSelected.classList.add('selected');
      }

      selectedElementId = id;
      // IMPORTANTE: Não recriar o DOM quando apenas selecionamos
      // Apenas atualizar o inspector (código será gerado apenas quando solicitado)
      renderInspector();
      // Salvar estado após seleção
      saveState();
    }

    function closePanel() {
      const panel = document.getElementById('codePanel');
      if (panel) {
        panel.classList.add('hidden');
      }
    }

    window.closePanel = closePanel;

    // -----------------------
    // Inspector (Right panel)
    // -----------------------
    function fieldWrap(labelText) {
      const wrap = document.createElement('div');
      wrap.className = 'inspector-field';
      const label = document.createElement('label');
      label.textContent = labelText;
      wrap.appendChild(label);
      return wrap;
    }

    function addInput(wrap, value, onChange, opts = {}) {
      const input = document.createElement('input');
      input.type = opts.type || 'text';
      if (opts.min != null) input.min = opts.min;
      if (opts.max != null) input.max = opts.max;
      if (opts.step != null) input.step = opts.step;
      input.value = value ?? '';
      input.oninput = () => onChange(input.value);
      wrap.appendChild(input);
      return input;
    }

    function addSelect(wrap, value, options, onChange) {
      const sel = document.createElement('select');
      options.forEach(o => {
        const opt = document.createElement('option');
        opt.value = o.value;
        opt.textContent = o.label;
        if (o.value === value) opt.selected = true;
        sel.appendChild(opt);
      });
      sel.onchange = () => onChange(sel.value);
      wrap.appendChild(sel);
      return sel;
    }

    function addTextarea(wrap, value, onChange) {
      const ta = document.createElement('textarea');
      ta.value = value ?? '';
      ta.oninput = () => onChange(ta.value);
      wrap.appendChild(ta);
      return ta;
    }

    // Funções auxiliares para o editor (do gerador_atualizado_v2.html)
    function findElementByIdRecursive(id, elementsArray) {
      for (const el of elementsArray) {
        if (el.id === id) return el;

        // Buscar em grupos
        if (el.type === 'group' && el.properties && el.properties.children) {
          const found = findElementByIdRecursive(id, el.properties.children);
          if (found) return found;
        }

        // Buscar em columns
        if (el.type === 'columns' && el.properties && el.properties.columns) {
          for (const col of el.properties.columns) {
            if (col.children) {
              const found = findElementByIdRecursive(id, col.children);
              if (found) return found;
            }
          }
        }

        // Buscar em list items (quando item é um node)
        if (el.type === 'list' && el.properties && el.properties.items) {
          for (const item of el.properties.items) {
            if (item.kind === 'node' && item.node) {
              if (item.node.id === id) return item.node;
              // Buscar recursivamente no node
              const found = findElementByIdRecursive(id, [item.node]);
              if (found) return found;
            }
          }
        }

        // Buscar em table cells
        if (el.type === 'table' && el.properties && el.properties.body) {
          for (const row of el.properties.body) {
            for (const cell of row) {
              if (cell && typeof cell === 'object' && cell.children) {
                const found = findElementByIdRecursive(id, cell.children);
                if (found) return found;
              }
            }
          }
        }
      }
      return null;
    }

    function findElementById(id) {
      if (!id) return null;
      // Primeiro tentar usar findNodeById se existir
      if (typeof findNodeById === 'function') {
        const node = findNodeById(id);
        if (node) return node;
      }
      // Depois buscar recursivamente nos elements
      return findElementByIdRecursive(id, elements);
    }

    // Find parent container of an element (group, columns, list, table)
    // Verificar se elemento está dentro de header
    function isElementInHeader(elementId) {
      if (!elementId || !documentHeader.root) return false;
      let found = false;
      walk(documentHeader.root, (n) => {
        if (n.id === elementId) found = true;
      });
      return found;
    }

    // Verificar se elemento está dentro de footer
    function isElementInFooter(elementId) {
      if (!elementId || !documentFooter.root) return false;
      let found = false;
      walk(documentFooter.root, (n) => {
        if (n.id === elementId) found = true;
      });
      return found;
    }

    function findParentGroup(elementId) {
      if (!elementId) return null;

      // Buscar em grupos do root
      for (const group of elements) {
        if (group.type === 'group' && group.properties && group.properties.children) {
          const childIndex = group.properties.children.findIndex(c => c && c.id === elementId);
          if (childIndex !== -1) {
            return { group, child: group.properties.children[childIndex], index: childIndex };
          }

          // Buscar recursivamente em grupos aninhados
          for (const childGroup of group.properties.children) {
            if (childGroup && childGroup.type === 'group' && childGroup.properties && childGroup.properties.children) {
              const nestedChildIndex = childGroup.properties.children.findIndex(c => c && c.id === elementId);
              if (nestedChildIndex !== -1) {
                return {
                  group: childGroup,
                  child: childGroup.properties.children[nestedChildIndex],
                  index: nestedChildIndex
                };
              }
            }
          }
        }

        // Buscar em columns
        if (group.type === 'columns' && group.properties && group.properties.columns) {
          for (let colIdx = 0; colIdx < group.properties.columns.length; colIdx++) {
            const col = group.properties.columns[colIdx];
            if (col.children) {
              const childIndex = col.children.findIndex(c => c && c.id === elementId);
              if (childIndex !== -1) {
                return { group, child: col.children[childIndex], index: childIndex, colIndex: colIdx };
              }
            }
          }
        }

        // Buscar em list items
        if (group.type === 'list' && group.properties && group.properties.items) {
          for (let itemIdx = 0; itemIdx < group.properties.items.length; itemIdx++) {
            const item = group.properties.items[itemIdx];
            if (item.kind === 'node' && item.node && item.node.id === elementId) {
              return { group, child: item.node, index: itemIdx };
            }
          }
        }

        // Buscar em table cells
        if (group.type === 'table' && group.properties && group.properties.body) {
          for (let rowIdx = 0; rowIdx < group.properties.body.length; rowIdx++) {
            const row = group.properties.body[rowIdx];
            for (let colIdx = 0; colIdx < row.length; colIdx++) {
              const cell = row[colIdx];
              if (cell && typeof cell === 'object' && cell.children) {
                const childIndex = cell.children.findIndex(c => c && c.id === elementId);
                if (childIndex !== -1) {
                  return { group, child: cell.children[childIndex], index: childIndex, rowIndex: rowIdx, colIndex: colIdx };
                }
              }
            }
          }
        }
      }
      return null;
    }

    // Mover elemento dentro de um container (grupo, columns, table)
    function moveElementInContainer(direction) {
      if (!selectedElementId) return;

      const nodeWithParent = findNodeWithParent(selectedElementId);
      if (!nodeWithParent || !nodeWithParent.parent || !nodeWithParent.ctx) return;

      const { parent, ctx } = nodeWithParent;
      let children = [];
      let index = -1;

      // Determinar array de children e índice baseado no tipo de container
      if (ctx.kind === 'groupChildren') {
        children = parent.properties.children || [];
        index = ctx.index;
      } else if (ctx.kind === 'columns') {
        const col = parent.properties.columns[ctx.colIndex];
        children = col.children || [];
        index = ctx.index;
      } else if (ctx.kind === 'tableCell') {
        const cell = parent.properties.body[ctx.row][ctx.col];
        children = cell.children || [];
        index = ctx.index;
      } else {
        return; // Não suportado
      }

      if (children.length <= 1) return;

      let newIndex = index;

      switch (direction) {
        case 'first':
          if (index === 0) return;
          newIndex = 0;
          break;
        case 'prev':
          if (index === 0) return;
          newIndex = index - 1;
          break;
        case 'next':
          if (index === children.length - 1) return;
          newIndex = index + 1;
          break;
        case 'last':
          if (index === children.length - 1) return;
          newIndex = children.length - 1;
          break;
      }

      // Mover elemento
      const [movedElement] = children.splice(index, 1);
      children.splice(newIndex, 0, movedElement);

      // Se for grupo, recalcular larguras se for horizontal
      if (ctx.kind === 'groupChildren' && parent.properties.orientation === 'row' && typeof updateGroupChildrenWidths === 'function') {
        updateGroupChildrenWidths(parent);
      }

      // Atualizar dimensões do grupo se aplicável
      if (ctx.kind === 'groupChildren' && typeof updateGroupDimensions === 'function') {
        updateGroupDimensions(parent);
      }

      // Re-renderizar imediatamente
      if (typeof renderAll === 'function') {
        renderAll();
      } else if (typeof render === 'function') {
        render();
      }
      // Atualizar inspector para refletir a nova posição
      setTimeout(() => {
        if (typeof renderInspector === 'function') renderInspector();
      }, 0);
    }

    // Mover elemento dentro de um grupo (mantido para compatibilidade)
    function moveElementInGroup(direction) {
      moveElementInContainer(direction);
    }

    // Mover coluna dentro de columns
    function moveColumnInColumns(elementId, colIndex, direction) {
      const element = findElementById(elementId);
      if (!element || element.type !== 'columns') return;

      const cols = element.properties.columns || [];
      if (cols.length <= 1) return;

      let newIndex = colIndex;

      switch (direction) {
        case 'first':
          if (colIndex === 0) return;
          newIndex = 0;
          break;
        case 'prev':
          if (colIndex === 0) return;
          newIndex = colIndex - 1;
          break;
        case 'next':
          if (colIndex === cols.length - 1) return;
          newIndex = colIndex + 1;
          break;
        case 'last':
          if (colIndex === cols.length - 1) return;
          newIndex = cols.length - 1;
          break;
      }

      // Mover coluna
      const [movedCol] = cols.splice(colIndex, 1);
      cols.splice(newIndex, 0, movedCol);

      // Re-renderizar
      if (typeof renderAll === 'function') {
        renderAll();
      } else if (typeof render === 'function') {
        render();
      }
      // Atualizar inspector
      setTimeout(() => {
        if (typeof renderInspector === 'function') renderInspector();
      }, 0);
    }

    // Mover coluna dentro de table
    function moveColumnInTable(elementId, colIndex, direction) {
      const element = findElementById(elementId);
      if (!element || element.type !== 'table') return;

      const body = element.properties.body || [];
      if (body.length === 0) return;

      const numCols = body[0].length;
      if (numCols <= 1) return;

      let newIndex = colIndex;

      switch (direction) {
        case 'first':
          if (colIndex === 0) return;
          newIndex = 0;
          break;
        case 'prev':
          if (colIndex === 0) return;
          newIndex = colIndex - 1;
          break;
        case 'next':
          if (colIndex === numCols - 1) return;
          newIndex = colIndex + 1;
          break;
        case 'last':
          if (colIndex === numCols - 1) return;
          newIndex = numCols - 1;
          break;
      }

      // Mover coluna em todas as linhas
      body.forEach(row => {
        const [movedCell] = row.splice(colIndex, 1);
        row.splice(newIndex, 0, movedCell);
      });

      // Mover width correspondente se existir
      if (element.properties.widths && element.properties.widths.length === numCols) {
        const [movedWidth] = element.properties.widths.splice(colIndex, 1);
        element.properties.widths.splice(newIndex, 0, movedWidth);
      }

      // Re-renderizar
      if (typeof renderAll === 'function') {
        renderAll();
      } else if (typeof render === 'function') {
        render();
      }
      // Atualizar inspector
      setTimeout(() => {
        if (typeof renderInspector === 'function') renderInspector();
      }, 0);
    }

    // Deletar coluna específica de columns
    function deleteColumnFromColumns(elementId, colIndex) {
      const element = findElementById(elementId);
      if (!element || element.type !== 'columns') return;

      const cols = element.properties.columns || [];
      if (cols.length <= 1) {
        if (typeof showAlertModal === 'function') {
          showAlertModal('Aviso', 'É necessário manter pelo menos uma coluna.');
        }
        return;
      }

      if (typeof showConfirmModal === 'function') {
        showConfirmModal(
          'Deletar Coluna',
          `Tem certeza que deseja deletar a Coluna ${colIndex + 1}? Todos os elementos dentro desta coluna serão removidos.`,
          () => {
            // Deletar a coluna
            cols.splice(colIndex, 1);

            // Atualizar o número de colunas no input se existir
            const colCountInput = document.getElementById('insp-colCount');
            if (colCountInput) {
              colCountInput.value = cols.length;
            }

            // Re-renderizar
            if (typeof renderAll === 'function') {
              renderAll();
            } else if (typeof render === 'function') {
              render();
            }
            // Atualizar inspector
            setTimeout(() => {
              if (typeof renderInspector === 'function') renderInspector();
            }, 0);
          }
        );
      }
    }

    // Deletar coluna específica de table
    function deleteColumnFromTable(elementId, colIndex) {
      const element = findElementById(elementId);
      if (!element || element.type !== 'table') return;

      const body = element.properties.body || [];
      if (body.length === 0) return;

      const numCols = body[0].length;
      if (numCols <= 1) {
        if (typeof showAlertModal === 'function') {
          showAlertModal('Aviso', 'É necessário manter pelo menos uma coluna.');
        }
        return;
      }

      if (typeof showConfirmModal === 'function') {
        showConfirmModal(
          'Deletar Coluna',
          `Tem certeza que deseja deletar a Coluna ${colIndex + 1}? Todos os dados desta coluna em todas as linhas serão removidos.`,
          () => {
            // Deletar coluna de todas as linhas
            body.forEach(row => {
              row.splice(colIndex, 1);
            });

            // Deletar width correspondente se existir
            if (element.properties.widths && element.properties.widths.length === numCols) {
              element.properties.widths.splice(colIndex, 1);
            }

            // Atualizar número de colunas no input se existir
            const tableColsInput = document.getElementById('insp-tableCols');
            if (tableColsInput) {
              tableColsInput.value = numCols - 1;
            }

            // Re-renderizar
            if (typeof renderAll === 'function') {
              renderAll();
            } else if (typeof render === 'function') {
              render();
            }
            // Atualizar inspector
            setTimeout(() => {
              if (typeof renderInspector === 'function') renderInspector();
            }, 0);
          }
        );
      }
    }

    // Processar imagem com border-radius usando Canvas (adaptado do script Node.js fornecido)
    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function updateParentGroupsDimensions(childId) {
      if (!childId) return;
      elements.forEach(group => {
        if (group.type === 'group' && group.properties && group.properties.children) {
          const hasChild = group.properties.children.some(child => child && child.id === childId);
          if (hasChild && typeof updateGroupDimensions === 'function') {
            updateGroupDimensions(group);
          }
        }
      });
    }

    // Remover elemento selecionado
    function removeSelectedElement() {
      if (!selectedElementId) return;

      showConfirmModal(
        'Remover elemento',
        'Tem certeza que deseja remover este elemento?',
        () => {
          // Usar deleteSelected que já existe e funciona corretamente
          deleteSelected();
          // Atualizar inspector após remoção
          renderInspector();
        }
      );
    }
    window.removeSelectedElement = removeSelectedElement; // Tornar global para uso no onclick

    // Variável global para armazenar propriedades copiadas
    let copiedElementProperties = null;

    // Duplicar elemento selecionado
    function duplicateSelectedElement() {
      if (!selectedElementId) return;

      const element = findElementById(selectedElementId);
      if (!element) return;

      // Criar uma cópia profunda do elemento
      const duplicated = JSON.parse(JSON.stringify(element));

      // Gerar novo ID
      duplicated.id = 'el_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

      // Encontrar onde adicionar o elemento duplicado
      const parentGroupInfo = findParentGroup(selectedElementId);
      const nodeWithParent = findNodeWithParent(selectedElementId);

      if (parentGroupInfo) {
        // Adicionar ao mesmo grupo, após o elemento original
        const parentGroup = parentGroupInfo.group;
        const children = parentGroup.properties.children || [];
        const index = parentGroupInfo.index;
        children.splice(index + 1, 0, duplicated);
        parentGroup.properties.children = children;
      } else if (nodeWithParent && nodeWithParent.parent && nodeWithParent.ctx) {
        const ctx = nodeWithParent.ctx;
        if (ctx.kind === 'columns') {
          const col = nodeWithParent.parent.properties.columns[ctx.colIndex];
          const children = col.children || [];
          children.splice(ctx.index + 1, 0, duplicated);
          col.children = children;
        } else if (ctx.kind === 'tableCell') {
          const cell = nodeWithParent.parent.properties.body[ctx.row][ctx.col];
          const children = cell.children || [];
          children.splice(ctx.index + 1, 0, duplicated);
          cell.children = children;
        } else {
          // Adicionar ao root
          const rootGroup = getRootGroup();
          if (rootGroup) {
            const children = rootGroup.properties.children || [];
            const index = children.findIndex(el => el.id === selectedElementId);
            if (index >= 0) {
              children.splice(index + 1, 0, duplicated);
            } else {
              children.push(duplicated);
            }
            rootGroup.properties.children = children;
          }
        }
      } else {
        // Adicionar ao root
        const rootGroup = getRootGroup();
        if (rootGroup) {
          const children = rootGroup.properties.children || [];
          const index = children.findIndex(el => el.id === selectedElementId);
          if (index >= 0) {
            children.splice(index + 1, 0, duplicated);
          } else {
            children.push(duplicated);
          }
          rootGroup.properties.children = children;
        }
      }

      // Selecionar o elemento duplicado
      selectedElementId = duplicated.id;

      // Resetar cache e renderizar primeiro sem ajustar tamanho
      resetCanvasSizeCache();
      if (typeof renderAll === 'function') {
        renderAll(false);
      } else if (typeof render === 'function') {
        render();
      }

      // Depois, permitir ajuste e fazer ajuste único após um delay
      setTimeout(() => {
        allowCanvasSizeAdjust = true;
        if (typeof renderAll === 'function') {
          renderAll(true);
        }
        allowCanvasSizeAdjust = false;
      }, 100);

      // Atualizar inspector
      setTimeout(() => {
        if (typeof renderInspector === 'function') renderInspector();
      }, 150);
    }
    window.duplicateSelectedElement = duplicateSelectedElement;

    // Copiar propriedades do elemento
    function copyElementProperties() {
      if (!selectedElementId) return;

      const element = findElementById(selectedElementId);
      if (!element) return;

      // Copiar apenas as propriedades (não o ID nem outras propriedades do elemento)
      copiedElementProperties = {
        type: element.type,
        properties: JSON.parse(JSON.stringify(element.properties || {}))
      };

      // Mostrar feedback
      const btn = document.querySelector('.btn-paste');
      if (btn) {
        btn.style.background = '#f59e0b';
        btn.disabled = false;
        btn.style.cursor = 'pointer';
        const originalText = btn.textContent;
        btn.textContent = '✓ Propriedades Copiadas!';
        setTimeout(() => {
          btn.textContent = originalText;
        }, 2000);
      }
    }
    window.copyElementProperties = copyElementProperties;

    // Colar propriedades no elemento selecionado
    function pasteElementProperties() {
      if (!selectedElementId || !copiedElementProperties) return;

      const element = findElementById(selectedElementId);
      if (!element) return;

      // Só colar se os tipos forem compatíveis
      if (element.type !== copiedElementProperties.type) {
        if (typeof showAlertModal === 'function') {
          showAlertModal(
            'Erro ao Colar Propriedades',
            `Não é possível colar propriedades de um tipo de elemento diferente.\n\nElemento atual: ${getElementTypeName(element.type)}\nElemento copiado: ${getElementTypeName(copiedElementProperties.type)}`
          );
        } else {
          alert('Não é possível colar propriedades de um tipo de elemento diferente.');
        }
        return;
      }

      // Colar as propriedades (preservar ID e outras propriedades do elemento)
      element.properties = JSON.parse(JSON.stringify(copiedElementProperties.properties));

      // Atualizar renderização
      if (typeof renderAll === 'function') {
        renderAll();
      } else if (typeof render === 'function') {
        render();
      }

      // Atualizar inspector
      setTimeout(() => {
        if (typeof renderInspector === 'function') renderInspector();
      }, 100);
    }
    window.pasteElementProperties = pasteElementProperties;

    // Helper function para criar tooltips
    function createTooltip(text, helpText = '') {
      if (!text) return '';
      const tooltipId = 'tooltip_' + Math.random().toString(36).substr(2, 9);
      const fullText = helpText ? text + '\\n\\n' + helpText : text;
      return `
        <span style="position: relative; display: inline-block; margin-left: 0.25rem; cursor: help;" title="${escapeHtml(fullText)}">
          <span style="color: var(--text-tertiary); font-size: 0.875rem;">ℹ️</span>
        </span>
      `;
    }

    // Get element type name for display
    function getElementTypeName(type) {
      const names = {
        text: 'Texto',
        header: 'Cabeçalho',
        image: 'Imagem',
        table: 'Tabela',
        columns: 'Colunas',
        list: 'Lista',
        margin: 'Espaço',
        pageBreak: 'Quebra de Página',
        group: 'Grupo'
      };
      return names[type] || type;
    }

    function renderInspector() {
      const inspector = document.getElementById('inspector');
      const element = findElementById(selectedElementId);

      if (!element) {
        // Limpar título quando não há elemento selecionado
        const typeTitle = document.getElementById('elementTypeTitle');
        if (typeTitle) {
          typeTitle.innerHTML = 'Tipo';
        }
        inspector.innerHTML = `
          <div class="muted" style="padding: 1rem; text-align: center;">
            Selecione um elemento no canvas para editar suas propriedades.
          </div>
        `;
        return;
      }

      // Atualizar título no header
      const typeTitle = document.getElementById('elementTypeTitle');
      if (typeTitle) {
        typeTitle.innerHTML = `Tipo: <strong>${getElementTypeName(element.type)}</strong>`;
      }

      let html = '';

      // Check if element is inside a container (group, columns, table)
      const parentGroupInfo = findParentGroup(element.id);
      const nodeWithParent = findNodeWithParent(element.id);

      if (parentGroupInfo || (nodeWithParent && nodeWithParent.parent && nodeWithParent.ctx)) {
        let children = [];
        let childIndex = -1;
        let isFirst = false;
        let isLast = false;
        let showReorder = false;

        // Se encontrou via findParentGroup (grupos)
        if (parentGroupInfo) {
          const parentGroup = parentGroupInfo.group;
          childIndex = parentGroupInfo.index;
          children = parentGroup.properties.children || [];
          isFirst = childIndex === 0;
          isLast = childIndex === children.length - 1;
          showReorder = true;
        }
        // Se encontrou via findNodeWithParent (columns, table)
        else if (nodeWithParent && nodeWithParent.parent && nodeWithParent.ctx) {
          const ctx = nodeWithParent.ctx;
          if (ctx.kind === 'columns') {
            const col = nodeWithParent.parent.properties.columns[ctx.colIndex];
            children = col.children || [];
            childIndex = ctx.index;
            isFirst = childIndex === 0;
            isLast = childIndex === children.length - 1;
            showReorder = true;
          } else if (ctx.kind === 'tableCell') {
            const cell = nodeWithParent.parent.properties.body[ctx.row][ctx.col];
            children = cell.children || [];
            childIndex = ctx.index;
            isFirst = childIndex === 0;
            isLast = childIndex === children.length - 1;
            showReorder = true;

            // Adicionar campo para editar verticalAlignment da célula
            html += `
              <div class="inspector-field" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                <label style="margin-bottom: 0.75rem; display: block; font-weight: 500;">Alinhamento Vertical da Célula</label>
                <select id="insp-cellVerticalAlignment" style="width: 100%; padding: 0.5rem; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 0.375rem;">
                  <option value="top" ${cell.verticalAlignment === 'top' ? 'selected' : ''}>Topo</option>
                  <option value="middle" ${cell.verticalAlignment === 'middle' || !cell.verticalAlignment ? 'selected' : ''}>Meio</option>
                  <option value="bottom" ${cell.verticalAlignment === 'bottom' ? 'selected' : ''}>Inferior</option>
                </select>
                <div class="smallNote" style="margin-top: 0.5rem;">Alinhamento vertical do conteúdo dentro desta célula</div>
              </div>
            `;
          }
        }

        // Adicionar botões de reordenação para elementos dentro de containers
        if (showReorder && children.length > 1) {
          html += `
            <div class="inspector-field" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
              <label style="margin-bottom: 0.75rem; display: block; font-weight: 500;">Reordenar Elemento</label>
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                <button id="btn-move-first" onclick="moveElementInContainer('first')" 
                        style="padding: 0.5rem; background: ${isFirst ? 'var(--bg-tertiary)' : '#2563eb'}; color: ${isFirst ? 'var(--text-tertiary)' : 'white'}; border: none; border-radius: 0.375rem; cursor: ${isFirst ? 'not-allowed' : 'pointer'}; font-size: 0.875rem;"
                        ${isFirst ? 'disabled' : ''}>
                  ⏮️ Primeiro
                </button>
                <button id="btn-move-prev" onclick="moveElementInContainer('prev')" 
                        style="padding: 0.5rem; background: ${isFirst ? 'var(--bg-tertiary)' : '#2563eb'}; color: ${isFirst ? 'var(--text-tertiary)' : 'white'}; border: none; border-radius: 0.375rem; cursor: ${isFirst ? 'not-allowed' : 'pointer'}; font-size: 0.875rem;"
                        ${isFirst ? 'disabled' : ''}>
                  ⬅️ Anterior
                </button>
                <button id="btn-move-next" onclick="moveElementInContainer('next')" 
                        style="padding: 0.5rem; background: ${isLast ? 'var(--bg-tertiary)' : '#2563eb'}; color: ${isLast ? 'var(--text-tertiary)' : 'white'}; border: none; border-radius: 0.375rem; cursor: ${isLast ? 'not-allowed' : 'pointer'}; font-size: 0.875rem;"
                        ${isLast ? 'disabled' : ''}>
                  ➡️ Próximo
                </button>
                <button id="btn-move-last" onclick="moveElementInContainer('last')" 
                        style="padding: 0.5rem; background: ${isLast ? 'var(--bg-tertiary)' : '#2563eb'}; color: ${isLast ? 'var(--text-tertiary)' : 'white'}; border: none; border-radius: 0.375rem; cursor: ${isLast ? 'not-allowed' : 'pointer'}; font-size: 0.875rem;"
                        ${isLast ? 'disabled' : ''}>
                  ⏭️ Último
                </button>
              </div>
            </div>
          `;
        }

        // Show width and height fields only for elements in groups
        if (parentGroupInfo) {
          const parentGroup = parentGroupInfo.group;
          if (parentGroup.properties.orientation === 'row') {
            // Show width field for elements in horizontal groups
            const currentWidth = element.width !== null && element.width !== undefined ? element.width : (100 / (parentGroup.properties.children?.length || 1));
            html += `
              <div class="inspector-field">
                <label>Largura (%)</label>
                <input type="number" id="insp-width" value="${Math.round(currentWidth)}" step="1">
                <div class="smallNote">Largura do elemento dentro do grupo. O espaço restante será distribuído entre os outros elementos.</div>
              </div>
            `;
          }
        }
      }

      // Se o elemento é columns, adicionar opções para reordenar e deletar colunas
      if (element.type === 'columns') {
        const cols = element.properties.columns || [];
        if (cols.length > 0) {
          html += `
            <div class="inspector-field" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
              <label style="margin-bottom: 0.75rem; display: block; font-weight: 500;">Reordenar Colunas</label>
              <div class="smallNote" style="margin-bottom: 0.5rem;">Selecione uma coluna abaixo para movê-la</div>
          `;
          cols.forEach((col, colIndex) => {
            const isFirstCol = colIndex === 0;
            const isLastCol = colIndex === cols.length - 1;
            //const canDelete = cols.length > 1; // Só pode deletar se tiver mais de 1 coluna
            html += `
              <div style="margin-bottom: 0.5rem;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.25rem;">
                  <span style="font-size: 0.875rem; color: var(--text-secondary);">Coluna ${colIndex + 1}</span>
                </div>
                ${cols.length > 1 ? `
                  <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 0.25rem;">
                    <button onclick="moveColumnInColumns('${element.id}', ${colIndex}, 'first')" 
                            style="padding: 0.25rem; background: ${isFirstCol ? 'var(--bg-tertiary)' : '#2563eb'}; color: ${isFirstCol ? 'var(--text-tertiary)' : 'white'}; border: none; border-radius: 0.25rem; cursor: ${isFirstCol ? 'not-allowed' : 'pointer'}; font-size: 0.75rem;"
                            ${isFirstCol ? 'disabled' : ''}>
                      ⇤
                    </button>
                    <button onclick="moveColumnInColumns('${element.id}', ${colIndex}, 'prev')" 
                            style="padding: 0.25rem; background: ${isFirstCol ? 'var(--bg-tertiary)' : '#2563eb'}; color: ${isFirstCol ? 'var(--text-tertiary)' : 'white'}; border: none; border-radius: 0.25rem; cursor: ${isFirstCol ? 'not-allowed' : 'pointer'}; font-size: 0.75rem;"
                            ${isFirstCol ? 'disabled' : ''}>
                      ←
                    </button>
                    <button onclick="moveColumnInColumns('${element.id}', ${colIndex}, 'next')" 
                            style="padding: 0.25rem; background: ${isLastCol ? 'var(--bg-tertiary)' : '#2563eb'}; color: ${isLastCol ? 'var(--text-tertiary)' : 'white'}; border: none; border-radius: 0.25rem; cursor: ${isLastCol ? 'not-allowed' : 'pointer'}; font-size: 0.75rem;"
                            ${isLastCol ? 'disabled' : ''}>
                      →
                    </button>
                    <button onclick="moveColumnInColumns('${element.id}', ${colIndex}, 'last')" 
                            style="padding: 0.25rem; background: ${isLastCol ? 'var(--bg-tertiary)' : '#2563eb'}; color: ${isLastCol ? 'var(--text-tertiary)' : 'white'}; border: none; border-radius: 0.25rem; cursor: ${isLastCol ? 'not-allowed' : 'pointer'}; font-size: 0.75rem;"
                            ${isLastCol ? 'disabled' : ''}>
                      ⇥
                    </button>
                  </div>
                ` : ''}
              </div>
            `;
          });
          html += `</div>`;
        }
      }

      // Se o elemento é table, adicionar opções para reordenar e deletar colunas da tabela
      if (element.type === 'table') {
        const body = element.properties.body || [];
        if (body.length > 0 && body[0].length > 0) {
          const numCols = body[0].length;
          html += `
            <div class="inspector-field" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
              <label style="margin-bottom: 0.75rem; display: block; font-weight: 500;">Reordenar Colunas da Tabela</label>
              <div class="smallNote" style="margin-bottom: 0.5rem;">Selecione uma coluna abaixo para movê-la</div>
          `;
          for (let colIndex = 0; colIndex < numCols; colIndex++) {
            const isFirstCol = colIndex === 0;
            const isLastCol = colIndex === numCols - 1;
            const canDelete = numCols > 1; // Só pode deletar se tiver mais de 1 coluna
            html += `
              <div style="margin-bottom: 0.5rem;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.25rem;">
                  <span style="font-size: 0.875rem; color: var(--text-secondary);">Coluna ${colIndex + 1}</span>
                </div>
                ${numCols > 1 ? `
                  <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 0.25rem;">
                    <button onclick="moveColumnInTable('${element.id}', ${colIndex}, 'first')" 
                            style="padding: 0.25rem; background: ${isFirstCol ? 'var(--bg-tertiary)' : '#2563eb'}; color: ${isFirstCol ? 'var(--text-tertiary)' : 'white'}; border: none; border-radius: 0.25rem; cursor: ${isFirstCol ? 'not-allowed' : 'pointer'}; font-size: 0.75rem;"
                            ${isFirstCol ? 'disabled' : ''}>
                      ⇤
                    </button>
                    <button onclick="moveColumnInTable('${element.id}', ${colIndex}, 'prev')" 
                            style="padding: 0.25rem; background: ${isFirstCol ? 'var(--bg-tertiary)' : '#2563eb'}; color: ${isFirstCol ? 'var(--text-tertiary)' : 'white'}; border: none; border-radius: 0.25rem; cursor: ${isFirstCol ? 'not-allowed' : 'pointer'}; font-size: 0.75rem;"
                            ${isFirstCol ? 'disabled' : ''}>
                      ←
                    </button>
                    <button onclick="moveColumnInTable('${element.id}', ${colIndex}, 'next')" 
                            style="padding: 0.25rem; background: ${isLastCol ? 'var(--bg-tertiary)' : '#2563eb'}; color: ${isLastCol ? 'var(--text-tertiary)' : 'white'}; border: none; border-radius: 0.25rem; cursor: ${isLastCol ? 'not-allowed' : 'pointer'}; font-size: 0.75rem;"
                            ${isLastCol ? 'disabled' : ''}>
                      →
                    </button>
                    <button onclick="moveColumnInTable('${element.id}', ${colIndex}, 'last')" 
                            style="padding: 0.25rem; background: ${isLastCol ? 'var(--bg-tertiary)' : '#2563eb'}; color: ${isLastCol ? 'var(--text-tertiary)' : 'white'}; border: none; border-radius: 0.25rem; cursor: ${isLastCol ? 'not-allowed' : 'pointer'}; font-size: 0.75rem;"
                            ${isLastCol ? 'disabled' : ''}>
                      ⇥
                    </button>
                  </div>
                ` : ''}
              </div>
            `;
          }
          html += `</div>`;
        }
      }

      // Render fields based on element type
      switch (element.type) {
        case 'text':
          html += renderInspectorText(element);
          break;
        case 'header':
          html += renderInspectorHeader(element);
          break;
        case 'image':
          html += renderInspectorImage(element);
          break;
        case 'table':
          html += renderInspectorTable(element);
          break;
        case 'columns':
          html += renderInspectorColumns(element);
          break;
        case 'list':
          html += renderInspectorList(element);
          break;
        case 'margin':
          html += renderInspectorMargin(element);
          break;
        case 'pageBreak':
          html += renderInspectorPageBreak(element);
          break;
        case 'qr':
          html += renderInspectorQR(element);
          break;
        case 'svg':
          html += renderInspectorSVG(element);
          break;
        case 'barcode':
          html += renderInspectorBarcode(element);
          break;
        case 'stamp':
          html += renderInspectorStamp(element);
          break;
        case 'checkbox':
          html += renderInspectorCheckbox(element);
          break;
        case 'radio':
          html += renderInspectorRadio(element);
          break;
        case 'fillLine':
          html += renderInspectorFillLine(element);
          break;
        case 'chart':
          html += renderInspectorChart(element);
          break;
        case 'group':
          html += renderInspectorGroup(element);
          break;
      }

      // Adicionar botões de ação no final do inspector
      html += `
        <div class="inspector-field" style="margin-top: 2rem; padding-top: 1.5rem; border-top: 1px solid var(--border-color);">
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-bottom: 0.75rem;">
            <button class="btn-duplicate" onclick="duplicateSelectedElement()" style="padding: 0.75rem 1rem; background: #2563eb; color: white; border: none; border-radius: 0.5rem; font-size: 0.875rem; font-weight: 500; cursor: pointer; transition: background 0.2s;">
              📋 Duplicar
            </button>
            <button class="btn-copy" onclick="copyElementProperties()" style="padding: 0.75rem 1rem; background: #10b981; color: white; border: none; border-radius: 0.5rem; font-size: 0.875rem; font-weight: 500; cursor: pointer; transition: background 0.2s;">
              📄 Copiar
            </button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr; gap: 0.5rem;">
            <button class="btn-paste" onclick="pasteElementProperties()" style="padding: 0.75rem 1rem; background: ${copiedElementProperties ? '#f59e0b' : '#6b7280'}; color: white; border: none; border-radius: 0.5rem; font-size: 0.875rem; font-weight: 500; cursor: ${copiedElementProperties ? 'pointer' : 'not-allowed'}; transition: background 0.2s;" ${!copiedElementProperties ? 'disabled' : ''}>
              📥 Colar Propriedades
            </button>
            <button class="btn-remove-large" onclick="removeSelectedElement()" style="width: 100%; padding: 0.75rem 1rem; background: #ef4444; color: white; border: none; border-radius: 0.5rem; font-size: 1rem; font-weight: 500; cursor: pointer; transition: background 0.2s;">
              🗑️ Remover Elemento
            </button>
          </div>
        </div>
      `;

      inspector.innerHTML = html;

      // Forçar visibilidade do inspector após renderizar
      if (inspector) {
        inspector.style.display = 'block';
        inspector.style.visibility = 'visible';
        inspector.style.opacity = '1';
        inspector.style.height = 'auto';
      }

      // Attach event listeners (deve ser chamado após atualizar o HTML)
      setTimeout(() => {
        attachInspectorListeners(element);
      }, 0);
    }

    // Inspector render functions
    function renderInspectorText(element) {
      const p = element.properties || {};

      // Verificar se o elemento está dentro de header ou footer
      const isInHeader = isElementInHeader(element.id);
      const isInFooter = isElementInFooter(element.id);
      const isInHeaderFooter = isInHeader || isInFooter;

      return `
        <div class="inspector-field">
          <label>ID do Elemento (para linkToDestination) ${createTooltip('Define um ID único para este elemento. Outros elementos podem usar linkToDestination apontando para este ID.', 'Exemplo: Se definir id="secao1", outros elementos podem usar linkToDestination: "secao1" para criar um link interno.')}</label>
          <input type="text" id="insp-elementId" value="${escapeHtml(p.id || '')}" placeholder="Ex: secao1, destino1 (deixe vazio se não for destino)">
          <div class="smallNote">ID único para este elemento. Use para criar destinos de links internos.</div>
        </div>
        <div class="inspector-field">
              <label>Texto ${createTooltip('Conteúdo de texto do elemento. Pode conter múltiplas linhas.', 'Use {{pageNumber}} e {{totalPages}} em headers/footers para numeração de páginas.')}</label>
          <textarea id="insp-text">${escapeHtml(p.text || '')}</textarea>
          ${isInHeaderFooter ? `
            <div class="smallNote" style="margin-top: 0.5rem; padding: 0.75rem; background: #dbeafe; border-left: 3px solid #2563eb; border-radius: 0.25rem; color: #1e40af;">
              <strong>💡 Numeração de Página:</strong> Use <code>{{pageNumber}}</code> para número da página atual e <code>{{totalPages}}</code> para total de páginas. Exemplo: "Página {{pageNumber}} de {{totalPages}}"
            </div>
          ` : ''}
            </div>
        <div class="inspector-field">
          <label>Tipo de Link ${createTooltip('Escolha o tipo de link: URL externa, link para página do PDF ou link para destino/âncora.', 'LinkToPage: número da página (ex: 1, 2, 3). LinkToDestination: nome da âncora definida no documento.')}</label>
          <select id="insp-linkType">
            <option value="none" ${(!p._linkType && !p.link && !p.linkToPage && !p.linkToDestination) || p._linkType === 'none' ? 'selected' : ''}>Nenhum</option>
            <option value="url" ${(p._linkType === 'url' || (p.link && !p.linkToPage && !p.linkToDestination)) ? 'selected' : ''}>URL Externa</option>
            <option value="page" ${p._linkType === 'page' || p.linkToPage ? 'selected' : ''}>Link para Página</option>
            <option value="destination" ${p._linkType === 'destination' || p.linkToDestination ? 'selected' : ''}>Link para Destino</option>
          </select>
        </div>
        <div id="insp-linkUrlOptions" style="${(p._linkType === 'url' || (p.link && !p.linkToPage && !p.linkToDestination)) ? '' : 'display: none;'}">
          <div class="inspector-field">
            <label>Link (URL)</label>
            <input type="text" id="insp-link" value="${escapeHtml(p.link || '')}" placeholder="https://exemplo.com">
            <div class="smallNote">URL externa para o link</div>
          </div>
        </div>
        <div id="insp-linkPageOptions" style="${(p._linkType === 'page' || p.linkToPage) ? '' : 'display: none;'}">
          <div class="inspector-field">
            <label>Número da Página</label>
            <input type="number" id="insp-linkToPage" value="${p.linkToPage || 1}" min="1" placeholder="1">
            <div class="smallNote">Número da página para onde o link aponta (começa em 1)</div>
          </div>
        </div>
        <div id="insp-linkDestinationOptions" style="${(p._linkType === 'destination' || p.linkToDestination) ? '' : 'display: none;'}">
          <div class="inspector-field">
            <label>Nome do Destino (ID do elemento destino)</label>
            <input type="text" id="insp-linkToDestination" value="${escapeHtml(p.linkToDestination || '')}" placeholder="nome-do-destino">
            <div class="smallNote" style="margin-top: 0.5rem; padding: 0.75rem; background: #fef3c7; border-left: 3px solid #f59e0b; border-radius: 0.25rem; color: #92400e;">
              <strong>⚠️ Importante:</strong> O elemento de destino precisa ter um <strong>ID</strong> definido igual a este valor. Exemplo: Se usar "secao1" aqui, o elemento destino deve ter ID="secao1" no campo "ID do Elemento".
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Tamanho da Fonte</label>
              <input type="number" id="insp-fontSize" value="${p.fontSize || 14}" min="8" max="72" step="1">
              <div id="insp-fontSizeError" style="display: none; margin-top: 0.25rem; padding: 0.25rem; background: #fee2e2; border-left: 3px solid #ef4444; border-radius: 0.25rem; color: #991b1b; font-size: 0.75rem;"></div>
            </div>
            <div>
              <label class="smallNote">Fonte</label>
              <select id="insp-font">
                <option value="Roboto" ${p.font === 'Roboto' || !p.font ? 'selected' : ''}>Roboto</option>
                <option value="Courier" ${p.font === 'Courier' ? 'selected' : ''}>Courier</option>
                <option value="Helvetica" ${p.font === 'Helvetica' ? 'selected' : ''}>Helvetica</option>
                <option value="Times" ${p.font === 'Times' ? 'selected' : ''}>Times</option>
              </select>
            </div>
            </div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Font Features (fontFeatures)</label>
          <input type="text" id="insp-fontFeatures" value="${p.fontFeatures ? p.fontFeatures.join(', ') : ''}" placeholder="Ex: kern, liga, smcp (separados por vírgula)">
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">Features tipográficas avançadas (dependem da fonte TTF). Separe por vírgula.</div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Cor do Texto</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="color" id="insp-color" value="${p.color || '#000000'}" style="width: 50px; height: 32px; cursor: pointer;">
                <input type="text" id="insp-colorText" value="${p.color || '#000000'}" placeholder="#000000" style="flex: 1; font-size: 0.875rem;">
              </div>
            </div>
            <div>
              <label class="smallNote">Cor de Fundo</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="color" id="insp-background" value="${p.background || '#ffffff'}" style="width: 50px; height: 32px; cursor: pointer;">
                <input type="text" id="insp-backgroundText" value="${p.background || ''}" placeholder="Deixe vazio para transparente" style="flex: 1; font-size: 0.875rem;">
              </div>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Alinhamento</label>
              <select id="insp-alignment">
                <option value="left" ${p.alignment === 'left' ? 'selected' : ''}>Esquerda</option>
                <option value="center" ${p.alignment === 'center' ? 'selected' : ''}>Centro</option>
                <option value="right" ${p.alignment === 'right' ? 'selected' : ''}>Direita</option>
                <option value="justify" ${p.alignment === 'justify' ? 'selected' : ''}>Justificado</option>
              </select>
            </div>
            <div>
              <label class="smallNote">Decoração</label>
              <select id="insp-decoration">
                <option value="" ${!p.decoration ? 'selected' : ''}>Nenhuma</option>
                <option value="underline" ${p.decoration === 'underline' ? 'selected' : ''}>Sublinhado</option>
                <option value="lineThrough" ${p.decoration === 'lineThrough' ? 'selected' : ''}>Riscado</option>
                <option value="overline" ${p.decoration === 'overline' ? 'selected' : ''}>Sobrelinha</option>
              </select>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
                <input type="checkbox" id="insp-bold" ${p.bold ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
                <span>Negrito</span>
              </label>
            </div>
            <div>
              <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
                <input type="checkbox" id="insp-italics" ${p.italics ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
                <span>Itálico</span>
              </label>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Altura da Linha (lineHeight)</label>
              <input type="number" id="insp-lineHeight" value="${p.lineHeight || ''}" placeholder="Auto" min="0" max="10" step="0.1">
              <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">Deixe vazio para automático</div>
            </div>
            <div>
              <label class="smallNote">Espaçamento entre Caracteres</label>
              <input type="number" id="insp-characterSpacing" value="${p.characterSpacing || ''}" placeholder="0" min="0" max="10" step="0.1">
              <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">Em unidades (0 = normal)</div>
            </div>
          </div>
        </div>
        <div class="inspector-field" id="decorationOptions" style="${!p.decoration ? 'display: none;' : ''}">
          <div class="row">
            <div>
              <label class="smallNote">Estilo da Decoração</label>
              <select id="insp-decorationStyle">
                <option value="solid" ${p.decorationStyle === 'solid' || !p.decorationStyle ? 'selected' : ''}>Sólida</option>
                <option value="dashed" ${p.decorationStyle === 'dashed' ? 'selected' : ''}>Tracejada</option>
                <option value="dotted" ${p.decorationStyle === 'dotted' ? 'selected' : ''}>Pontilhada</option>
                <option value="double" ${p.decorationStyle === 'double' ? 'selected' : ''}>Dupla</option>
                <option value="wavy" ${p.decorationStyle === 'wavy' ? 'selected' : ''}>Ondulada</option>
              </select>
            </div>
            <div>
              <label class="smallNote">Cor da Decoração</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="color" id="insp-decorationColor" value="${p.decorationColor || p.color || '#000000'}" style="width: 50px; height: 32px; cursor: pointer;">
                <input type="text" id="insp-decorationColorText" value="${p.decorationColor || ''}" placeholder="Deixe vazio para usar cor do texto" style="flex: 1; font-size: 0.875rem;">
              </div>
            </div>
          </div>
        </div>
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorHeader(element) {
      const p = element.properties || {};
      return `
        <div class="inspector-field">
          <label>ID do Elemento (para linkToDestination) ${createTooltip('Define um ID único para este elemento. Outros elementos podem usar linkToDestination apontando para este ID.', 'Exemplo: Se definir id="secao1", outros elementos podem usar linkToDestination: "secao1" para criar um link interno.')}</label>
          <input type="text" id="insp-headerElementId" value="${escapeHtml(p.id || '')}" placeholder="Ex: secao1, destino1 (deixe vazio se não for destino)">
          <div class="smallNote">ID único para este elemento. Use para criar destinos de links internos.</div>
        </div>
        <div class="inspector-field">
              <label>Texto do Cabeçalho</label>
          <input type="text" id="insp-headerText" value="${escapeHtml(p.text || '')}">
            </div>
        <div class="inspector-field">
          <label>Tipo de Link</label>
          <select id="insp-headerLinkType">
            <option value="none" ${(!p._linkType && !p.link && !p.linkToPage && !p.linkToDestination) || p._linkType === 'none' ? 'selected' : ''}>Nenhum</option>
            <option value="url" ${(p._linkType === 'url' || (p.link && !p.linkToPage && !p.linkToDestination)) ? 'selected' : ''}>URL Externa</option>
            <option value="page" ${p._linkType === 'page' || p.linkToPage ? 'selected' : ''}>Link para Página</option>
            <option value="destination" ${p._linkType === 'destination' || p.linkToDestination ? 'selected' : ''}>Link para Destino</option>
          </select>
        </div>
        <div id="insp-headerLinkUrlOptions" style="${(p._linkType === 'url' || (p.link && !p.linkToPage && !p.linkToDestination)) ? '' : 'display: none;'}">
          <div class="inspector-field">
            <label>Link (URL)</label>
            <input type="text" id="insp-headerLink" value="${escapeHtml(p.link || '')}" placeholder="https://exemplo.com">
            <div class="smallNote">URL externa para o link</div>
          </div>
        </div>
        <div id="insp-headerLinkPageOptions" style="${(p._linkType === 'page' || p.linkToPage) ? '' : 'display: none;'}">
          <div class="inspector-field">
            <label>Número da Página</label>
            <input type="number" id="insp-headerLinkToPage" value="${p.linkToPage || 1}" min="1" placeholder="1">
            <div class="smallNote">Número da página para onde o link aponta (começa em 1)</div>
          </div>
        </div>
        <div id="insp-headerLinkDestinationOptions" style="${(p._linkType === 'destination' || p.linkToDestination) ? '' : 'display: none;'}">
          <div class="inspector-field">
            <label>Nome do Destino (ID do elemento destino)</label>
            <input type="text" id="insp-headerLinkToDestination" value="${escapeHtml(p.linkToDestination || '')}" placeholder="nome-do-destino">
            <div class="smallNote" style="margin-top: 0.5rem; padding: 0.75rem; background: #fef3c7; border-left: 3px solid #f59e0b; border-radius: 0.25rem; color: #92400e;">
              <strong>⚠️ Importante:</strong> O elemento de destino precisa ter um <strong>ID</strong> definido igual a este valor. Exemplo: Se usar "secao1" aqui, o elemento destino deve ter ID="secao1" no campo "ID do Elemento".
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Tamanho da Fonte</label>
              <input type="number" id="insp-headerFontSize" value="${p.fontSize || 18}" min="8" max="72">
            </div>
            <div>
              <label class="smallNote">Fonte</label>
              <select id="insp-headerFont">
                <option value="Roboto" ${p.font === 'Roboto' || !p.font ? 'selected' : ''}>Roboto</option>
                <option value="Courier" ${p.font === 'Courier' ? 'selected' : ''}>Courier</option>
                <option value="Helvetica" ${p.font === 'Helvetica' ? 'selected' : ''}>Helvetica</option>
                <option value="Times" ${p.font === 'Times' ? 'selected' : ''}>Times</option>
              </select>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Font Features (fontFeatures)</label>
          <input type="text" id="insp-headerFontFeatures" value="${p.fontFeatures ? p.fontFeatures.join(', ') : ''}" placeholder="Ex: kern, liga, smcp (separados por vírgula)">
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">Features tipográficas avançadas (dependem da fonte TTF). Separe por vírgula.</div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Cor do Texto</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="color" id="insp-headerColor" value="${p.color || '#000000'}" style="width: 50px; height: 32px; cursor: pointer;">
                <input type="text" id="insp-headerColorText" value="${p.color || '#000000'}" placeholder="#000000" style="flex: 1; font-size: 0.875rem;">
              </div>
            </div>
            <div>
              <label class="smallNote">Cor de Fundo</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="color" id="insp-headerBackground" value="${p.background || '#ffffff'}" style="width: 50px; height: 32px; cursor: pointer;">
                <input type="text" id="insp-headerBackgroundText" value="${p.background || ''}" placeholder="Deixe vazio para transparente" style="flex: 1; font-size: 0.875rem;">
              </div>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Alinhamento</label>
              <select id="insp-headerAlignment">
                <option value="left" ${p.alignment === 'left' ? 'selected' : ''}>Esquerda</option>
                <option value="center" ${p.alignment === 'center' ? 'selected' : ''}>Centro</option>
                <option value="right" ${p.alignment === 'right' ? 'selected' : ''}>Direita</option>
              </select>
            </div>
            <div>
              <label class="smallNote">Decoração</label>
              <select id="insp-headerDecoration">
                <option value="" ${!p.decoration ? 'selected' : ''}>Nenhuma</option>
                <option value="underline" ${p.decoration === 'underline' ? 'selected' : ''}>Sublinhado</option>
                <option value="lineThrough" ${p.decoration === 'lineThrough' ? 'selected' : ''}>Riscado</option>
                <option value="overline" ${p.decoration === 'overline' ? 'selected' : ''}>Sobrelinha</option>
              </select>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
                <input type="checkbox" id="insp-headerBold" ${p.bold ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
                <span>Negrito</span>
              </label>
            </div>
            <div>
              <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
                <input type="checkbox" id="insp-headerItalics" ${p.italics ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
                <span>Itálico</span>
              </label>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Altura da Linha (lineHeight)</label>
              <input type="number" id="insp-headerLineHeight" value="${p.lineHeight || ''}" placeholder="Auto" min="0" max="10" step="0.1">
              <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">Deixe vazio para automático</div>
            </div>
            <div>
              <label class="smallNote">Espaçamento entre Caracteres</label>
              <input type="number" id="insp-headerCharacterSpacing" value="${p.characterSpacing || ''}" placeholder="0" min="0" max="10" step="0.1">
              <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">Em unidades (0 = normal)</div>
            </div>
          </div>
        </div>
        <div class="inspector-field" id="headerDecorationOptions" style="${!p.decoration ? 'display: none;' : ''}">
          <div class="row">
            <div>
              <label class="smallNote">Estilo da Decoração</label>
              <select id="insp-headerDecorationStyle">
                <option value="solid" ${p.decorationStyle === 'solid' || !p.decorationStyle ? 'selected' : ''}>Sólida</option>
                <option value="dashed" ${p.decorationStyle === 'dashed' ? 'selected' : ''}>Tracejada</option>
                <option value="dotted" ${p.decorationStyle === 'dotted' ? 'selected' : ''}>Pontilhada</option>
                <option value="double" ${p.decorationStyle === 'double' ? 'selected' : ''}>Dupla</option>
                <option value="wavy" ${p.decorationStyle === 'wavy' ? 'selected' : ''}>Ondulada</option>
              </select>
            </div>
            <div>
              <label class="smallNote">Cor da Decoração</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="color" id="insp-headerDecorationColor" value="${p.decorationColor || p.color || '#000000'}" style="width: 50px; height: 32px; cursor: pointer;">
                <input type="text" id="insp-headerDecorationColorText" value="${p.decorationColor || ''}" placeholder="Deixe vazio para usar cor do texto" style="flex: 1; font-size: 0.875rem;">
              </div>
            </div>
          </div>
        </div>
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorColumns(element) {
      const p = element.properties || {};
      const cols = p.columns || [{ text: 'Coluna 1', width: '*' }, { text: 'Coluna 2', width: '*' }];
      return `
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Número de Colunas</label>
              <input type="number" id="insp-colCount" value="${cols.length}" min="2" max="6">
              </div>
            <div>
              <label class="smallNote">Espaçamento (gap)</label>
              <input type="number" id="insp-colGap" value="${p.gap || 10}" min="0" max="50">
            </div>
            </div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Alinhamento Vertical</label>
          <select id="insp-colValign">
            <option value="top" ${p.valign === 'top' || !p.valign ? 'selected' : ''}>Topo</option>
            <option value="center" ${p.valign === 'center' ? 'selected' : ''}>Centro</option>
            <option value="bottom" ${p.valign === 'bottom' ? 'selected' : ''}>Inferior</option>
          </select>
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">Alinhamento vertical do conteúdo dentro das colunas</div>
        </div>
        <div class="inspector-field" style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
          <label style="font-weight: 500; margin-bottom: 0.75rem; color: var(--text-primary);">Larguras das Colunas</label>
          ${cols.map((col, idx) => {
        const width = col.width || '*';
        let widthType = 'auto';
        let widthValue = '';

        if (width === '*') {
          widthType = 'auto';
        } else if (width === 'auto') {
          widthType = 'auto';
        } else if (typeof width === 'number') {
          widthType = 'pixels';
          widthValue = width;
        } else if (typeof width === 'string' && width.endsWith('%')) {
          widthType = 'percentage';
          widthValue = width.replace('%', '');
        } else {
          widthType = 'auto';
        }

        return `
              <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 0.375rem;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">
                  <label style="font-weight: 500; color: var(--text-primary);">Coluna ${idx + 1}</label>
                  ${idx > 0 ? `
                    <button type="button" class="btn-delete-col" data-col-index="${idx}" style="padding: 0.25rem 0.5rem; background: #ef4444; color: white; border: none; border-radius: 0.25rem; cursor: pointer; font-size: 0.75rem;">🗑️</button>
                  ` : ''}
            </div>
                <div class="row">
                  <div style="flex: 1;">
                    <label class="smallNote">Tipo de Largura</label>
                    <select class="col-width-type" data-col-index="${idx}">
                      <option value="auto" ${widthType === 'auto' ? 'selected' : ''}>Automático (*)</option>
                      <option value="pixels" ${widthType === 'pixels' ? 'selected' : ''}>Pixels (px)</option>
                      <option value="percentage" ${widthType === 'percentage' ? 'selected' : ''}>Porcentagem (%)</option>
                    </select>
              </div>
                  <div style="flex: 1; ${widthType === 'auto' ? 'display: none;' : ''}" id="col-width-value-${idx}">
                    <label class="smallNote">Valor</label>
                    <input type="number" class="col-width-value" data-col-index="${idx}" value="${widthValue}" min="0" step="${widthType === 'percentage' ? '1' : '1'}" placeholder="${widthType === 'percentage' ? '50' : '100'}">
              </div>
            </div>
            </div>
          `;
      }).join('')}
          <div class="smallNote" style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-tertiary);">
            <strong style="color: var(--text-primary);">Tipos de largura:</strong><br>
            • Automático (*): divide o espaço igualmente entre as colunas<br>
            • Pixels: largura fixa em pontos (ex: 100, 200)<br>
            • Porcentagem: largura em % do espaço disponível (ex: 30, 50)
          </div>
        </div>
        <div class="inspector-field">
          <label>Conteúdo das Colunas (uma por linha, separado por "---")</label>
          <textarea id="insp-colTexts" placeholder="Coluna 1&#10;---&#10;Coluna 2">${cols.map(c => c.text || '').join('\n---\n')}</textarea>
          <div class="smallNote">Use "---" em uma linha separada para dividir as colunas</div>
        </div>
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorList(element) {
      const p = element.properties || {};
      const items = p.items || [{ kind: 'text', text: 'Item 1' }, { kind: 'text', text: 'Item 2' }];
      const textItems = items.filter(item => item.kind === 'text').map(item => item.text || '').join('\n');
      const isOrdered = p.ordered || p.listType === 'ol';
      return `
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Tipo</label>
              <select id="insp-listKind">
                <option value="ul" ${!isOrdered ? 'selected' : ''}>Não ordenada (ul)</option>
                <option value="ol" ${isOrdered ? 'selected' : ''}>Ordenada (ol)</option>
              </select>
            </div>
          </div>
        </div>
        ${isOrdered ? `
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Número Inicial (start)</label>
              <input type="number" id="insp-listStart" value="${p.start || 1}" min="1" max="1000">
            </div>
            <div>
              <label class="smallNote">Tipo de Marcador</label>
              <select id="insp-listType">
                <option value="decimal" ${p.type === 'decimal' || !p.type ? 'selected' : ''}>Decimal (1, 2, 3...)</option>
                <option value="lower-alpha" ${p.type === 'lower-alpha' ? 'selected' : ''}>Minúsculas (a, b, c...)</option>
                <option value="upper-alpha" ${p.type === 'upper-alpha' ? 'selected' : ''}>Maiúsculas (A, B, C...)</option>
                <option value="lower-roman" ${p.type === 'lower-roman' ? 'selected' : ''}>Romano minúsculo (i, ii, iii...)</option>
                <option value="upper-roman" ${p.type === 'upper-roman' ? 'selected' : ''}>Romano maiúsculo (I, II, III...)</option>
              </select>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <label><input type="checkbox" id="insp-listReversed" ${p.reversed ? 'checked' : ''}> Lista Reversa (reversed)</label>
          <div class="smallNote">Inverte a ordem numérica da lista</div>
        </div>
        ` : `
        <div class="inspector-field">
          <label class="smallNote">Tipo de Marcador</label>
          <select id="insp-listType">
            <option value="disc" ${p.type === 'disc' || !p.type ? 'selected' : ''}>Disco preenchido (●)</option>
            <option value="circle" ${p.type === 'circle' ? 'selected' : ''}>Círculo vazio (○)</option>
            <option value="square" ${p.type === 'square' ? 'selected' : ''}>Quadrado (■)</option>
          </select>
        </div>
        `}
        <div class="inspector-field">
          <label>Itens de Texto (um por linha)</label>
          <textarea id="insp-listItems">${textItems}</textarea>
          <div class="smallNote">Você também pode arrastar elementos diretamente na lista para criar itens complexos.</div>
        </div>
        <div class="inspector-field">
          <div class="smallNote">Itens com elementos aninhados: ${items.filter(item => item.kind === 'node').length}</div>
        </div>
        ${!isOrdered ? `
        <div class="inspector-field">
          <label class="smallNote">Cor dos Marcadores (markerColor)</label>
          <div style="display: flex; gap: 0.5rem; align-items: center;">
            <input type="color" id="insp-markerColor" value="${p.markerColor || '#000000'}" style="width: 50px; height: 32px; cursor: pointer;">
            <input type="text" id="insp-markerColorText" value="${p.markerColor || ''}" placeholder="Deixe vazio para usar cor padrão" style="flex: 1; font-size: 0.875rem;">
          </div>
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">Aplica-se apenas a listas não ordenadas (ul)</div>
        </div>
        ` : ''}
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorTable(element) {
      const p = element.properties || {};
      const body = p.body || [];
      const numRows = body.length || 2;
      const numCols = body[0]?.length || 3;
      const numDataRows = Math.max(0, numRows - 1); // Linhas de dados (excluindo header)

      return `
        <div class="inspector-field">
          <div class="smallNote" style="padding: 0.75rem; background: #dbeafe; border-left: 3px solid #2563eb; margin-bottom: 1rem; border-radius: 0.25rem; color: #1e40af;">
            <strong>📋 Estrutura da Tabela:</strong><br>
            • <strong>Linha 1</strong> = Cabeçalho (nomes das colunas)<br>
            • <strong>Linhas ${numRows > 1 ? '2-' + numRows : '2'}</strong> = Dados da tabela
          </div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Colunas</label>
              <input type="number" id="insp-tableCols" value="${numCols}" min="1" max="10">
            </div>
            <div>
              <label class="smallNote">Linhas de Dados</label>
              <input type="number" id="insp-tableRows" value="${numDataRows}" min="1" max="20">
              <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">
                (Total: ${numRows} linhas incluindo cabeçalho)
              </div>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Linhas de Cabeçalho (headerRows) ${createTooltip('Define quantas linhas da tabela serão repetidas em cada página como cabeçalho.', 'Padrão: 1 linha. Se definir 2, as duas primeiras linhas serão cabeçalho.')}</label>
          <input type="number" id="insp-tableHeaderRows" value="${p.headerRows !== undefined ? p.headerRows : 1}" min="0" max="${numRows}">
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">
            Número de linhas que serão consideradas como cabeçalho (padrão: 1)
          </div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Layout</label>
          <select id="insp-tableLayout">
            <option value="lightHorizontalLines" ${p.layout === 'lightHorizontalLines' || !p.layout ? 'selected' : ''}>Linhas Horizontais</option>
            <option value="headerLineOnly" ${p.layout === 'headerLineOnly' ? 'selected' : ''}>Apenas Header</option>
            <option value="noBorders" ${p.layout === 'noBorders' ? 'selected' : ''}>Sem Bordas</option>
            <option value="custom" ${p.layout === 'custom' || (p.customLayout && Object.keys(p.customLayout).length > 0) ? 'selected' : ''}>Customizado</option>
          </select>
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">Escolha "Customizado" para definir cores e larguras das linhas manualmente</div>
        </div>
        
        ${(p.layout === 'custom' || (p.customLayout && Object.keys(p.customLayout).length > 0)) ? `
        <div style="margin-top: 0.5rem;">
          <button type="button" id="btn-show-custom-layout" onclick="document.getElementById('tableCustomLayoutOptions').style.display = 'block'; this.style.display = 'none';" style="padding: 0.5rem; background: #2563eb; color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-size: 0.875rem;">Mostrar Opções de Layout Customizado</button>
        </div>
        ` : ''}
        ${(p.layout === 'custom' || (p.customLayout && Object.keys(p.customLayout).length > 0)) ? `
        <div class="inspector-field" id="tableCustomLayoutOptions">
          <label style="font-weight: 500; margin-bottom: 0.75rem; color: var(--text-primary);">Layout Customizado</label>
          
          <div style="margin-bottom: 1rem;">
            <label class="smallNote" style="color: var(--text-secondary);">Linhas Horizontais</label>
            <div class="row" style="margin-top: 0.5rem;">
              <div style="flex: 1;">
                <label class="smallNote" style="color: var(--text-secondary); font-size: 0.75rem;">Largura (px)</label>
                <input type="number" id="insp-tableHLineWidth" value="${p.customLayout?.hLineWidth || 1}" min="0" max="10" step="0.1" style="width: 100%; padding: 0.5rem; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 0.375rem; font-size: 0.875rem;">
              </div>
              <div style="flex: 1;">
                <label class="smallNote" style="color: var(--text-secondary); font-size: 0.75rem;">Cor</label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <input type="color" id="insp-tableHLineColor" value="${p.customLayout?.hLineColor || '#000000'}" style="width: 50px; height: 32px; cursor: pointer;">
                  <input type="text" id="insp-tableHLineColorText" value="${p.customLayout?.hLineColor || '#000000'}" placeholder="#000000" style="flex: 1; padding: 0.5rem; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 0.375rem; font-size: 0.875rem;">
                </div>
              </div>
            </div>
          </div>
          
          <div style="margin-bottom: 1rem;">
            <label class="smallNote" style="color: var(--text-secondary);">Linhas Verticais</label>
            <div class="row" style="margin-top: 0.5rem;">
              <div style="flex: 1;">
                <label class="smallNote" style="color: var(--text-secondary); font-size: 0.75rem;">Largura (px)</label>
                <input type="number" id="insp-tableVLineWidth" value="${p.customLayout?.vLineWidth || 1}" min="0" max="10" step="0.1" style="width: 100%; padding: 0.5rem; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 0.375rem; font-size: 0.875rem;">
              </div>
              <div style="flex: 1;">
                <label class="smallNote" style="color: var(--text-secondary); font-size: 0.75rem;">Cor</label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <input type="color" id="insp-tableVLineColor" value="${p.customLayout?.vLineColor || '#000000'}" style="width: 50px; height: 32px; cursor: pointer;">
                  <input type="text" id="insp-tableVLineColorText" value="${p.customLayout?.vLineColor || '#000000'}" placeholder="#000000" style="flex: 1; padding: 0.5rem; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 0.375rem; font-size: 0.875rem;">
                </div>
              </div>
            </div>
          </div>
          
          <div style="margin-bottom: 1rem;">
            <label class="smallNote" style="color: var(--text-secondary);">Padding das Células</label>
            <div class="row" style="margin-top: 0.5rem;">
              <div style="flex: 1;">
                <label class="smallNote" style="color: var(--text-secondary); font-size: 0.75rem;">Esquerda</label>
                <input type="number" id="insp-tablePaddingLeft" value="${p.customLayout?.paddingLeft || 5}" min="0" max="50" style="width: 100%; padding: 0.5rem; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 0.375rem; font-size: 0.875rem;">
              </div>
              <div style="flex: 1;">
                <label class="smallNote" style="color: var(--text-secondary); font-size: 0.75rem;">Direita</label>
                <input type="number" id="insp-tablePaddingRight" value="${p.customLayout?.paddingRight || 5}" min="0" max="50" style="width: 100%; padding: 0.5rem; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 0.375rem; font-size: 0.875rem;">
              </div>
            </div>
            <div class="row" style="margin-top: 0.5rem;">
              <div style="flex: 1;">
                <label class="smallNote" style="color: var(--text-secondary); font-size: 0.75rem;">Topo</label>
                <input type="number" id="insp-tablePaddingTop" value="${p.customLayout?.paddingTop || 5}" min="0" max="50" style="width: 100%; padding: 0.5rem; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 0.375rem; font-size: 0.875rem;">
              </div>
              <div style="flex: 1;">
                <label class="smallNote" style="color: var(--text-secondary); font-size: 0.75rem;">Inferior</label>
                <input type="number" id="insp-tablePaddingBottom" value="${p.customLayout?.paddingBottom || 5}" min="0" max="50" style="width: 100%; padding: 0.5rem; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 0.375rem; font-size: 0.875rem;">
              </div>
            </div>
          </div>
          
          <div style="margin-bottom: 1rem;">
            <label class="smallNote" style="color: var(--text-secondary);">Estilos de Linhas (Dashed)</label>
            <div class="row" style="margin-top: 0.5rem;">
              <div style="flex: 1;">
                <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
                  <input type="checkbox" id="insp-tableHLineStyle" ${p.customLayout?.hLineStyle ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
                  <span>Linhas Horizontais Tracejadas</span>
                </label>
                <div class="smallNote" style="margin-top: 0.25rem; color: var(--text-tertiary); font-size: 0.75rem;">
                  Aplica estilo tracejado nas linhas horizontais
                </div>
              </div>
              <div style="flex: 1;">
                <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
                  <input type="checkbox" id="insp-tableVLineStyle" ${p.customLayout?.vLineStyle ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
                  <span>Linhas Verticais Tracejadas</span>
                </label>
                <div class="smallNote" style="margin-top: 0.25rem; color: var(--text-tertiary); font-size: 0.75rem;">
                  Aplica estilo tracejado nas linhas verticais
                </div>
              </div>
            </div>
          </div>
          
          <div style="margin-bottom: 1rem;">
            <label class="smallNote" style="color: var(--text-secondary);">Borda Padrão (defaultBorder)</label>
            <div style="margin-top: 0.5rem;">
              <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
                <input type="checkbox" id="insp-tableDefaultBorder" ${p.customLayout?.defaultBorder !== false ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
                <span>Usar Bordas Padrão</span>
              </label>
              <div class="smallNote" style="margin-top: 0.25rem; color: var(--text-tertiary); font-size: 0.75rem;">
                Se desmarcado, apenas células com border definido terão bordas
              </div>
            </div>
          </div>
        </div>
        ` : ''}
        
        <div class="inspector-field" style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
          <label style="font-weight: 500; margin-bottom: 0.75rem; color: var(--text-primary);">Tabela Zebrada</label>
          <div style="margin-bottom: 1rem;">
            <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
              <input type="checkbox" id="insp-tableZebraEnabled" ${p.zebraEnabled ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
              <span>Ativar Tabela Zebrada</span>
            </label>
            <div class="smallNote" style="margin-top: 0.5rem; color: var(--text-tertiary); font-size: 0.75rem;">
              Alterna cores de fundo entre linhas para facilitar a leitura
            </div>
          </div>
          
          ${p.zebraEnabled ? `
          <div id="tableZebraOptions" style="margin-top: 1rem; padding: 1rem; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 0.375rem;">
            <div style="margin-bottom: 1rem;">
              <label class="smallNote" style="color: var(--text-secondary); font-size: 0.75rem; margin-bottom: 0.5rem; display: block;">Cor Base (linhas pares)</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="color" id="insp-tableZebraColor" value="${p.zebraColor || '#CCCCCC'}" style="width: 50px; height: 32px; cursor: pointer;">
                <input type="text" id="insp-tableZebraColorText" value="${p.zebraColor || '#CCCCCC'}" placeholder="#CCCCCC" style="flex: 1; padding: 0.5rem; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 0.375rem; font-size: 0.875rem;">
              </div>
              <div class="smallNote" style="margin-top: 0.5rem; color: var(--text-tertiary); font-size: 0.75rem;">
                A cor das linhas ímpares será gerada automaticamente com 50% de opacidade
              </div>
            </div>
            
            <div style="margin-bottom: 1rem;">
              <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
                <input type="checkbox" id="insp-tableZebraWithLines" ${p.zebraWithLines !== false ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
                <span>Mostrar Linhas Horizontais</span>
              </label>
              <div class="smallNote" style="margin-top: 0.5rem; color: var(--text-tertiary); font-size: 0.75rem;">
                Adiciona linhas horizontais entre as linhas da tabela
              </div>
            </div>
          </div>
          ` : ''}
        </div>
        <div class="inspector-field" style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
          <label style="font-weight: 500; margin-bottom: 0.75rem; color: var(--text-primary);">Estilos das Células</label>
          <div class="smallNote" style="margin-bottom: 0.75rem; color: var(--text-tertiary); font-size: 0.75rem;">
            Configure cores de fundo e texto para as células da tabela. A primeira linha é o cabeçalho.
          </div>
          
          ${Array.from({ length: numRows }, (_, rowIdx) => {
        const isHeader = rowIdx === 0;
        return Array.from({ length: numCols }, (_, colIdx) => {
          const cell = body[rowIdx]?.[colIdx] || { children: [] };
          const cellFillColor = cell.fillColor || '';
          const cellColor = cell.color || '';
          const cellFillOpacity = cell.fillOpacity !== undefined ? cell.fillOpacity : 1;

          return `
                <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 0.375rem;">
                  <label style="font-weight: 500; color: var(--text-primary); margin-bottom: 0.5rem; display: block;">
                    ${isHeader ? '🔵' : '⚪'} ${isHeader ? 'Cabeçalho' : 'Linha'} ${rowIdx + 1}, Coluna ${colIdx + 1}
                  </label>
                  
                  <div style="margin-bottom: 0.5rem;">
                    <label class="smallNote" style="color: var(--text-secondary); font-size: 0.75rem;">Cor de Fundo (fillColor)</label>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                      <input type="color" class="table-cell-fill-color" data-row="${rowIdx}" data-col="${colIdx}" value="${cellFillColor || '#ffffff'}" style="width: 50px; height: 32px; cursor: pointer;">
                      <input type="text" class="table-cell-fill-color-text" data-row="${rowIdx}" data-col="${colIdx}" value="${cellFillColor || ''}" placeholder="Deixe vazio para transparente" style="flex: 1; padding: 0.5rem; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 0.375rem; font-size: 0.875rem;">
                    </div>
                  </div>
                  
                  <div style="margin-bottom: 0.5rem;">
                    <label class="smallNote" style="color: var(--text-secondary); font-size: 0.75rem;">Cor do Texto (color)</label>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                      <input type="color" class="table-cell-color" data-row="${rowIdx}" data-col="${colIdx}" value="${cellColor || '#000000'}" style="width: 50px; height: 32px; cursor: pointer;">
                      <input type="text" class="table-cell-color-text" data-row="${rowIdx}" data-col="${colIdx}" value="${cellColor || ''}" placeholder="Deixe vazio para cor padrão" style="flex: 1; padding: 0.5rem; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 0.375rem; font-size: 0.875rem;">
                    </div>
                  </div>
                  
                  <div>
                    <label class="smallNote" style="color: var(--text-secondary); font-size: 0.75rem;">Opacidade do Fundo (fillOpacity)</label>
                    <input type="number" class="table-cell-fill-opacity" data-row="${rowIdx}" data-col="${colIdx}" value="${cellFillOpacity}" min="0" max="1" step="0.1" style="width: 100%; padding: 0.5rem; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 0.375rem; font-size: 0.875rem;">
                  </div>
                </div>
              `;
        }).join('')
      }).join('')}
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
                <input type="checkbox" id="insp-tableDontBreakRows" ${p.dontBreakRows ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
                <span>Não Quebrar Linhas</span>
              </label>
              <div class="smallNote">Previne quebra de linhas entre páginas</div>
            </div>
            <div>
              <label class="smallNote">Manter com Header (keepWithHeaderRows)</label>
              <input type="number" id="insp-tableKeepWithHeaderRows" value="${p.keepWithHeaderRows || 0}" min="0" max="10">
              <div class="smallNote">Número de linhas para manter com cabeçalho</div>
            </div>
          </div>
        </div>
        <div class="inspector-field" style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
          <label style="font-weight: 500; margin-bottom: 0.75rem; color: var(--text-primary);">Larguras das Colunas</label>
          ${Array.from({ length: numCols }, (_, idx) => {
        const widths = p.widths || [];
        const width = widths[idx] || '*';
        let widthType = 'auto';
        let widthValue = '';

        if (width === '*' || width === 'auto') {
          widthType = 'auto';
        } else if (typeof width === 'number') {
          widthType = 'pixels';
          widthValue = width;
        } else if (typeof width === 'string' && width.endsWith('%')) {
          widthType = 'percentage';
          widthValue = width.replace('%', '');
        } else {
          widthType = 'auto';
        }

        return `
              <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 0.375rem;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">
                  <label style="font-weight: 500; color: var(--text-primary);">Coluna ${idx + 1}</label>
                  ${idx > 0 ? `
                    <button type="button" class="btn-delete-table-col" data-col-index="${idx}" style="padding: 0.25rem 0.5rem; background: #ef4444; color: white; border: none; border-radius: 0.25rem; cursor: pointer; font-size: 0.75rem;">🗑️</button>
                  ` : ''}
                </div>
                <div class="row">
                  <div style="flex: 1;">
                    <label class="smallNote" style="color: var(--text-secondary);">Tipo de Largura</label>
                    <select class="table-col-width-type" data-col-index="${idx}" style="width: 100%; padding: 0.5rem; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 0.375rem; font-size: 0.875rem;">
                      <option value="auto" ${widthType === 'auto' ? 'selected' : ''}>Automático (*)</option>
                      <option value="pixels" ${widthType === 'pixels' ? 'selected' : ''}>Pixels (px)</option>
                      <option value="percentage" ${widthType === 'percentage' ? 'selected' : ''}>Porcentagem (%)</option>
                    </select>
                  </div>
                  <div style="flex: 1; ${widthType === 'auto' ? 'display: none;' : ''}" id="table-col-width-value-${idx}">
                    <label class="smallNote" style="color: var(--text-secondary);">Valor</label>
                    <input type="number" class="table-col-width-value" data-col-index="${idx}" value="${widthValue}" min="0" step="${widthType === 'percentage' ? '1' : '1'}" placeholder="${widthType === 'percentage' ? '50' : '100'}" style="width: 100%; padding: 0.5rem; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 0.375rem; font-size: 0.875rem;">
                  </div>
                </div>
              </div>
            `;
      }).join('')}
          <div class="smallNote" style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-tertiary);">
            <strong style="color: var(--text-primary);">Tipos de largura:</strong><br>
            • Automático (*): divide o espaço igualmente entre as colunas<br>
            • Pixels: largura fixa em pontos (ex: 100, 200)<br>
            • Porcentagem: largura em % do espaço disponível (ex: 30, 50)
          </div>
        </div>
        <div class="inspector-field" style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
          <label style="font-weight: 500; margin-bottom: 0.75rem; color: var(--text-primary);">Altura das Linhas (heights)</label>
          <div class="smallNote" style="margin-bottom: 0.75rem; color: var(--text-tertiary); font-size: 0.75rem;">
            Defina a altura das linhas da tabela. Pode ser um valor fixo para todas, um array por linha, ou uma função.
          </div>
          <div class="row">
            <div style="flex: 1;">
              <label class="smallNote">Tipo</label>
              <select id="insp-tableHeightsType">
                <option value="none" ${!p.heights ? 'selected' : ''}>Não Definir</option>
                <option value="fixed" ${p.heights && typeof p.heights === 'number' ? 'selected' : ''}>Valor Fixo (todas as linhas)</option>
                <option value="array" ${p.heights && Array.isArray(p.heights) ? 'selected' : ''}>Array (por linha)</option>
              </select>
            </div>
            <div style="flex: 1; ${!p.heights || typeof p.heights !== 'number' ? 'display: none;' : ''}" id="table-heights-fixed">
              <label class="smallNote">Altura Fixa (px)</label>
              <input type="number" id="insp-tableHeightsFixed" value="${p.heights && typeof p.heights === 'number' ? p.heights : 40}" min="0" step="1">
            </div>
          </div>
          ${p.heights && Array.isArray(p.heights) ? `
          <div style="margin-top: 1rem;">
            <label class="smallNote" style="color: var(--text-secondary); margin-bottom: 0.5rem; display: block;">Alturas por Linha</label>
            ${Array.from({ length: numRows }, (_, idx) => {
        const height = p.heights[idx] || 40;
        return `
                <div style="margin-bottom: 0.5rem;">
                  <label class="smallNote" style="color: var(--text-secondary); font-size: 0.75rem;">Linha ${idx + 1}</label>
                  <input type="number" class="table-row-height" data-row="${idx}" value="${height}" min="0" step="1" style="width: 100%; padding: 0.5rem; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 0.375rem; font-size: 0.875rem;">
                </div>
              `;
      }).join('')}
          </div>
          ` : ''}
        </div>
        <div class="inspector-field" style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
          <label style="font-weight: 500; margin-bottom: 0.75rem; color: var(--text-primary);">Propriedades Avançadas das Células</label>
          <div class="smallNote" style="margin-bottom: 0.75rem; color: var(--text-tertiary); font-size: 0.75rem;">
            Configure rowSpan, colSpan, border e borderColor para células individuais.
          </div>
          
          ${Array.from({ length: numRows }, (_, rowIdx) => {
        const isHeader = rowIdx === 0;
        return Array.from({ length: numCols }, (_, colIdx) => {
          const cell = body[rowIdx]?.[colIdx] || { children: [] };
          const rowSpan = cell.rowSpan || 1;
          const colSpan = cell.colSpan || 1;
          const border = cell.border || [true, true, true, true];
          const borderColor = cell.borderColor || ['', '', '', ''];

          return `
                <div style="margin-bottom: 1rem; padding: 0.75rem; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 0.375rem;">
                  <label style="font-weight: 500; color: var(--text-primary); margin-bottom: 0.75rem; display: block;">
                    ${isHeader ? '🔵' : '⚪'} ${isHeader ? 'Cabeçalho' : 'Linha'} ${rowIdx + 1}, Coluna ${colIdx + 1}
                  </label>
                  
                  <div class="row" style="margin-bottom: 0.75rem;">
                    <div style="flex: 1;">
                      <label class="smallNote" style="color: var(--text-secondary); font-size: 0.75rem;">rowSpan</label>
                      <input type="number" class="table-cell-rowspan" data-row="${rowIdx}" data-col="${colIdx}" value="${rowSpan}" min="1" max="10" style="width: 100%; padding: 0.5rem; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 0.375rem; font-size: 0.875rem;">
            </div>
                    <div style="flex: 1;">
                      <label class="smallNote" style="color: var(--text-secondary); font-size: 0.75rem;">colSpan</label>
                      <input type="number" class="table-cell-colspan" data-row="${rowIdx}" data-col="${colIdx}" value="${colSpan}" min="1" max="10" style="width: 100%; padding: 0.5rem; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 0.375rem; font-size: 0.875rem;">
            </div>
                  </div>
                  
                  <div style="margin-bottom: 0.75rem;">
                    <label class="smallNote" style="color: var(--text-secondary); font-size: 0.75rem; margin-bottom: 0.5rem; display: block;">Bordas (border) - [esquerda, topo, direita, inferior]</label>
                    <div class="row">
                      <div style="flex: 1;">
                        <label class="smallNote" style="color: var(--text-secondary); font-size: 0.7rem;">Esquerda</label>
                        <input type="checkbox" class="table-cell-border" data-row="${rowIdx}" data-col="${colIdx}" data-side="0" ${border[0] ? 'checked' : ''} style="width: 100%;">
                      </div>
                      <div style="flex: 1;">
                        <label class="smallNote" style="color: var(--text-secondary); font-size: 0.7rem;">Topo</label>
                        <input type="checkbox" class="table-cell-border" data-row="${rowIdx}" data-col="${colIdx}" data-side="1" ${border[1] ? 'checked' : ''} style="width: 100%;">
                      </div>
                      <div style="flex: 1;">
                        <label class="smallNote" style="color: var(--text-secondary); font-size: 0.7rem;">Direita</label>
                        <input type="checkbox" class="table-cell-border" data-row="${rowIdx}" data-col="${colIdx}" data-side="2" ${border[2] ? 'checked' : ''} style="width: 100%;">
                      </div>
                      <div style="flex: 1;">
                        <label class="smallNote" style="color: var(--text-secondary); font-size: 0.7rem;">Inferior</label>
                        <input type="checkbox" class="table-cell-border" data-row="${rowIdx}" data-col="${colIdx}" data-side="3" ${border[3] ? 'checked' : ''} style="width: 100%;">
                      </div>
                    </div>
                  </div>
                  
                  <div>
                    <label class="smallNote" style="color: var(--text-secondary); font-size: 0.75rem; margin-bottom: 0.5rem; display: block;">Cores das Bordas (borderColor) - [esquerda, topo, direita, inferior]</label>
                    <div class="row">
                      <div style="flex: 1;">
                        <label class="smallNote" style="color: var(--text-secondary); font-size: 0.7rem;">Esquerda</label>
                        <input type="color" class="table-cell-border-color" data-row="${rowIdx}" data-col="${colIdx}" data-side="0" value="${borderColor[0] || '#000000'}" style="width: 100%; height: 32px; cursor: pointer;">
                      </div>
                      <div style="flex: 1;">
                        <label class="smallNote" style="color: var(--text-secondary); font-size: 0.7rem;">Topo</label>
                        <input type="color" class="table-cell-border-color" data-row="${rowIdx}" data-col="${colIdx}" data-side="1" value="${borderColor[1] || '#000000'}" style="width: 100%; height: 32px; cursor: pointer;">
                      </div>
                      <div style="flex: 1;">
                        <label class="smallNote" style="color: var(--text-secondary); font-size: 0.7rem;">Direita</label>
                        <input type="color" class="table-cell-border-color" data-row="${rowIdx}" data-col="${colIdx}" data-side="2" value="${borderColor[2] || '#000000'}" style="width: 100%; height: 32px; cursor: pointer;">
                      </div>
                      <div style="flex: 1;">
                        <label class="smallNote" style="color: var(--text-secondary); font-size: 0.7rem;">Inferior</label>
                        <input type="color" class="table-cell-border-color" data-row="${rowIdx}" data-col="${colIdx}" data-side="3" value="${borderColor[3] || '#000000'}" style="width: 100%; height: 32px; cursor: pointer;">
                      </div>
                    </div>
                  </div>
                </div>
              `;
        }).join('')
      }).join('')}
        </div>
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorImage(element) {
      const p = element.properties || {};
      const useFit = p.fit !== undefined;
      const useCover = p.cover !== undefined;
      const useAbsolutePosition = p.absolutePosition !== undefined;
      const useRelativePosition = p.relativePosition !== undefined;
      return `
        <div class="inspector-field">
          <label>URL da Imagem</label>
          <input type="text" id="insp-imageUrl" value="${escapeHtml(p.url || '')}" placeholder="https://exemplo.com/imagem.jpg">
          <div id="insp-imageUrlError" style="display: none; margin-top: 0.5rem; padding: 0.5rem; background: #fee2e2; border-left: 3px solid #ef4444; border-radius: 0.25rem; color: #991b1b; font-size: 0.875rem;"></div>
          <div class="smallNote">Cole a URL completa da imagem (http://, https:// ou data:image)</div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Modo de Dimensionamento</label>
          <select id="insp-imageSizeMode">
            <option value="widthHeight" ${!useFit && !useCover ? 'selected' : ''}>Largura e Altura</option>
            <option value="fit" ${useFit ? 'selected' : ''}>Fit (Ajustar mantendo proporção)</option>
            <option value="cover" ${useCover ? 'selected' : ''}>Cover (Preencher área)</option>
              </select>
            </div>
        <div id="imageWidthHeightOptions" style="${useFit || useCover ? 'display: none;' : ''}">
          <div class="inspector-field">
            <div class="row">
              <div>
                <label class="smallNote">Largura</label>
                <input type="number" id="insp-imageWidth" value="${p.width || ''}" min="10" max="500" placeholder="Auto">
              </div>
              <div>
                <label class="smallNote">Altura</label>
                <input type="number" id="insp-imageHeight" value="${p.height || ''}" min="10" max="500" placeholder="Auto">
              </div>
            </div>
          </div>
        </div>
        <div id="imageFitOptions" style="${!useFit ? 'display: none;' : ''}">
          <div class="inspector-field">
            <div class="row">
              <div>
                <label class="smallNote">Fit Width</label>
                <input type="number" id="insp-imageFitWidth" value="${Array.isArray(p.fit) ? p.fit[0] : (p.fit || 100)}" min="10" max="500">
              </div>
              <div>
                <label class="smallNote">Fit Height</label>
                <input type="number" id="insp-imageFitHeight" value="${Array.isArray(p.fit) ? p.fit[1] : (p.fit || 100)}" min="10" max="500">
              </div>
            </div>
            <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">Ajusta a imagem mantendo a proporção</div>
          </div>
        </div>
        <div id="imageCoverOptions" style="${!useCover ? 'display: none;' : ''}">
          <div class="inspector-field">
            <div class="row">
              <div>
                <label class="smallNote">Cover Width</label>
                <input type="number" id="insp-imageCoverWidth" value="${p.cover?.width || 300}" min="10" max="500">
              </div>
              <div>
                <label class="smallNote">Cover Height</label>
                <input type="number" id="insp-imageCoverHeight" value="${p.cover?.height || 150}" min="10" max="500">
              </div>
            </div>
          </div>
          <div class="inspector-field">
            <div class="row">
              <div>
                <label class="smallNote">Cover Align</label>
                <select id="insp-imageCoverAlign">
                  <option value="left" ${p.cover?.align === 'left' ? 'selected' : ''}>Esquerda</option>
                  <option value="center" ${p.cover?.align === 'center' || !p.cover?.align ? 'selected' : ''}>Centro</option>
                  <option value="right" ${p.cover?.align === 'right' ? 'selected' : ''}>Direita</option>
                </select>
              </div>
              <div>
                <label class="smallNote">Cover Valign</label>
                <select id="insp-imageCoverValign">
                  <option value="top" ${p.cover?.valign === 'top' ? 'selected' : ''}>Topo</option>
                  <option value="center" ${p.cover?.valign === 'center' || !p.cover?.valign ? 'selected' : ''}>Centro</option>
                  <option value="bottom" ${p.cover?.valign === 'bottom' ? 'selected' : ''}>Inferior</option>
                </select>
              </div>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Border Radius</label>
          <input type="number" id="insp-imageBorderRadius" value="${p.borderRadius || 0}" min="0" max="1000" step="1" placeholder="0">
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">Apenas o número (ex: 30, 50, 100). 0 = sem arredondamento</div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Opacidade (0.0 - 1.0)</label>
          <input type="number" id="insp-imageOpacity" value="${p.opacity !== undefined ? p.opacity : ''}" placeholder="1.0" min="0" max="1" step="0.1">
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">1.0 = totalmente opaco, 0.0 = transparente</div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Alinhamento</label>
          <select id="insp-imageAlignment">
            <option value="left" ${p.alignment === 'left' ? 'selected' : ''}>Esquerda</option>
            <option value="center" ${p.alignment === 'center' ? 'selected' : ''}>Centro</option>
            <option value="right" ${p.alignment === 'right' ? 'selected' : ''}>Direita</option>
          </select>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Tipo de Posicionamento</label>
          <select id="insp-imagePositionType">
            <option value="none" ${!useAbsolutePosition && !useRelativePosition ? 'selected' : ''}>Normal (fluxo do documento)</option>
            <option value="absolute" ${useAbsolutePosition ? 'selected' : ''}>Posição Absoluta</option>
            <option value="relative" ${useRelativePosition ? 'selected' : ''}>Posição Relativa</option>
          </select>
        </div>
        <div id="imageAbsolutePositionOptions" style="${!useAbsolutePosition ? 'display: none;' : ''}">
          <div class="inspector-field">
            <div class="row">
              <div>
                <label class="smallNote">X (absoluto)</label>
                <input type="number" id="insp-imageAbsoluteX" value="${p.absolutePosition?.x || 0}" min="0" step="1">
              </div>
              <div>
                <label class="smallNote">Y (absoluto)</label>
                <input type="number" id="insp-imageAbsoluteY" value="${p.absolutePosition?.y || 0}" min="0" step="1">
              </div>
            </div>
            <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">Posição em pixels a partir do canto superior esquerdo da página</div>
          </div>
        </div>
        <div id="imageRelativePositionOptions" style="${!useRelativePosition ? 'display: none;' : ''}">
          <div class="inspector-field">
            <div class="row">
              <div>
                <label class="smallNote">X (relativo)</label>
                <input type="number" id="insp-imageRelativeX" value="${p.relativePosition?.x || 0}" step="1">
              </div>
              <div>
                <label class="smallNote">Y (relativo)</label>
                <input type="number" id="insp-imageRelativeY" value="${p.relativePosition?.y || 0}" step="1">
              </div>
            </div>
            <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">Deslocamento relativo à posição atual no fluxo do documento</div>
          </div>
        </div>
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorMargin(element) {
      const p = element.properties || {};
      // Suportar tanto o formato antigo (size) quanto o novo (margin array)
      const marginArray = p.margin || (p.size ? [0, p.size, 0, 0] : [0, 20, 0, 0]);
      return `
        <div class="inspector-field">
          <label>Margens Individuais (px)</label>
          <div class="smallNote" style="margin-bottom: 0.5rem;">Configure as margens: [Esquerda, Topo, Direita, Baixo]</div>
          <div class="row">
            <div>
              <label class="smallNote">Esquerda</label>
              <input type="number" id="insp-marginLeft" value="${marginArray[0] || 0}" min="0" step="1">
            </div>
            <div>
              <label class="smallNote">Topo</label>
              <input type="number" id="insp-marginTop" value="${marginArray[1] || 20}" min="0" step="1">
            </div>
            <div>
              <label class="smallNote">Direita</label>
              <input type="number" id="insp-marginRight" value="${marginArray[2] || 0}" min="0" step="1">
            </div>
            <div>
              <label class="smallNote">Baixo</label>
              <input type="number" id="insp-marginBottom" value="${marginArray[3] || 0}" min="0" step="1">
            </div>
          </div>
          <div class="smallNote" style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-tertiary);">Formato PDFMake: [left, top, right, bottom]</div>
            </div>
          `;
    }

    // Função auxiliar para renderizar seção de margens (reutilizável para todos os elementos)
    function renderMarginSection(element) {
      const p = element.properties || {};
      const marginArray = p.margin || [0, 0, 0, 0];
      return `
        <div class="inspector-field" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
          <label style="font-weight: 500; margin-bottom: 0.5rem; color: var(--text-primary);">Margens (px)</label>
          <div class="row">
            <div>
              <label class="smallNote">Esquerda</label>
              <input type="number" class="margin-input" data-side="0" value="${marginArray[0] || 0}" min="0" step="1" placeholder="0">
            </div>
            <div>
              <label class="smallNote">Topo</label>
              <input type="number" class="margin-input" data-side="1" value="${marginArray[1] || 0}" min="0" step="1" placeholder="0">
            </div>
            <div>
              <label class="smallNote">Direita</label>
              <input type="number" class="margin-input" data-side="2" value="${marginArray[2] || 0}" min="0" step="1" placeholder="0">
            </div>
            <div>
              <label class="smallNote">Baixo</label>
              <input type="number" class="margin-input" data-side="3" value="${marginArray[3] || 0}" min="0" step="1" placeholder="0">
            </div>
          </div>
          <div class="smallNote" style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-tertiary);">Formato: [left, top, right, bottom]</div>
        </div>
      `;
    }

    function renderInspectorPageBreak(element) {
      return `
        <div class="inspector-field">
          <div class="smallNote">Quebra de página - não há propriedades configuráveis para este elemento.</div>
            </div>
          `;
    }

    function renderInspectorQR(element) {
      const p = element.properties || {};
      return `
        <div class="inspector-field">
          <label>Texto/Dados para QR Code</label>
          <textarea id="insp-qrText" placeholder="URL, texto ou dados para codificar" style="min-height: 60px;">${escapeHtml(p.text || '')}</textarea>
          <div class="smallNote">Pode ser uma URL, texto ou qualquer dado que você queira codificar no QR Code</div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Tamanho (fit)</label>
              <input type="number" id="insp-qrFit" value="${p.fit || 100}" min="50" max="500">
            </div>
            <div>
              <label class="smallNote">Nível de Correção</label>
              <select id="insp-qrEccLevel">
                <option value="L" ${p.eccLevel === 'L' ? 'selected' : ''}>L (Baixo - 7%)</option>
                <option value="M" ${p.eccLevel === 'M' || !p.eccLevel ? 'selected' : ''}>M (Médio - 15%)</option>
                <option value="Q" ${p.eccLevel === 'Q' ? 'selected' : ''}>Q (Alto - 25%)</option>
                <option value="H" ${p.eccLevel === 'H' ? 'selected' : ''}>H (Muito Alto - 30%)</option>
              </select>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Cor do QR Code</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="color" id="insp-qrForeground" value="${p.foreground || '#000000'}" style="width: 50px; height: 32px; cursor: pointer;">
                <input type="text" id="insp-qrForegroundText" value="${p.foreground || '#000000'}" placeholder="#000000" style="flex: 1; font-size: 0.875rem;">
              </div>
            </div>
            <div>
              <label class="smallNote">Cor de Fundo</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="color" id="insp-qrBackground" value="${p.background || '#ffffff'}" style="width: 50px; height: 32px; cursor: pointer;">
                <input type="text" id="insp-qrBackgroundText" value="${p.background || '#ffffff'}" placeholder="#ffffff" style="flex: 1; font-size: 0.875rem;">
              </div>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Alinhamento</label>
          <select id="insp-qrAlignment">
            <option value="left" ${p.alignment === 'left' ? 'selected' : ''}>Esquerda</option>
            <option value="center" ${p.alignment === 'center' || !p.alignment ? 'selected' : ''}>Centro</option>
            <option value="right" ${p.alignment === 'right' ? 'selected' : ''}>Direita</option>
              </select>
            </div>
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorSVG(element) {
      const p = element.properties || {};
      return `
        <div class="inspector-field">
          <label>Código SVG</label>
          <div class="smallNote" style="padding: 0.75rem; background: #dbeafe; border-left: 3px solid #2563eb; margin-bottom: 1rem; border-radius: 0.25rem; color: #1e40af;">
            <strong>💡 Dica:</strong> Crie ou edite SVGs facilmente em 
            <a href="https://www.svgviewer.dev/" target="_blank" rel="noopener noreferrer" style="color: #1e40af; text-decoration: underline; font-weight: 500;">svgviewer.dev</a>
            e depois cole o código aqui.
          </div>
          <textarea id="insp-svgCode" placeholder="Cole ou digite o código SVG aqui" style="min-height: 120px; font-family: monospace; font-size: 0.875rem; width: 100%; padding: 0.5rem 0.75rem; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 0.375rem; color: var(--text-primary); box-sizing: border-box; resize: vertical;">${escapeHtml(p.svg || '')}</textarea>
          <div class="smallNote">Cole o código SVG completo (incluindo a tag &lt;svg&gt;)</div>
            </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Largura</label>
              <input type="number" id="insp-svgWidth" value="${p.width || 100}" min="10" max="1000">
            </div>
            <div>
              <label class="smallNote">Altura</label>
              <input type="number" id="insp-svgHeight" value="${p.height || 100}" min="10" max="1000">
            </div>
            </div>
                </div>
        <div class="inspector-field">
          <label class="smallNote">Cor (para SVGs monocromáticos)</label>
          <div style="display: flex; gap: 0.5rem; align-items: center;">
            <input type="color" id="insp-svgColor" value="${p.color || '#000000'}" style="width: 50px; height: 32px; cursor: pointer;">
            <input type="text" id="insp-svgColorText" value="${p.color || '#000000'}" placeholder="#000000" style="flex: 1; font-size: 0.875rem;">
            </div>
          <div class="smallNote">Aplicável apenas para SVGs que suportam coloração (deixe vazio se o SVG já tiver cores definidas)</div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Alinhamento</label>
          <select id="insp-svgAlignment">
            <option value="left" ${p.alignment === 'left' ? 'selected' : ''}>Esquerda</option>
            <option value="center" ${p.alignment === 'center' || !p.alignment ? 'selected' : ''}>Centro</option>
            <option value="right" ${p.alignment === 'right' ? 'selected' : ''}>Direita</option>
          </select>
        </div>
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorBarcode(element) {
      const p = element.properties || {};
      return `
        <div class="inspector-field">
          <label>Valor do Barcode</label>
          <input type="text" id="insp-barcodeValue" value="${escapeHtml(p.barcodeValue || 'ABC123456789')}" placeholder="ABC123456789">
          <div class="smallNote">Digite o valor que será codificado no barcode</div>
        </div>
        <div class="inspector-field">
          <label>Formato</label>
          <select id="insp-barcodeFormat">
            <option value="CODE128" ${p.format === 'CODE128' || !p.format ? 'selected' : ''}>CODE128</option>
            <option value="CODE39" ${p.format === 'CODE39' ? 'selected' : ''}>CODE39</option>
            <option value="EAN13" ${p.format === 'EAN13' ? 'selected' : ''}>EAN13</option>
            <option value="EAN8" ${p.format === 'EAN8' ? 'selected' : ''}>EAN8</option>
            <option value="UPC" ${p.format === 'UPC' ? 'selected' : ''}>UPC</option>
            <option value="ITF" ${p.format === 'ITF' ? 'selected' : ''}>ITF</option>
          </select>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Line Width</label>
              <input type="number" id="insp-barcodeLineWidth" value="${p.lineWidth || 1.5}" min="0.5" max="5" step="0.1">
            </div>
            <div>
              <label class="smallNote">Height</label>
              <input type="number" id="insp-barcodeHeight" value="${p.barHeight || 30}" min="10" max="200">
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
            <input type="checkbox" id="insp-barcodeDisplayValue" ${p.displayValue !== false ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
            <span>Display Value</span>
          </label>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Font Size</label>
              <input type="number" id="insp-barcodeFontSize" value="${p.fontSize || 10}" min="8" max="20">
            </div>
            <div>
              <label class="smallNote">Margin</label>
              <input type="number" id="insp-barcodeMargin" value="${p.margin || 0}" min="0" max="20">
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <label>Fit (Largura x Altura)</label>
          <div class="row">
            <div>
              <input type="number" id="insp-barcodeFitW" value="${p.fit ? p.fit[0] : 201}" min="50" max="500">
            </div>
            <div>
              <input type="number" id="insp-barcodeFitH" value="${p.fit ? p.fit[1] : 42}" min="20" max="200">
            </div>
          </div>
          <div class="smallNote">Tamanho do barcode no PDF (em pixels)</div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Alinhamento</label>
          <select id="insp-barcodeAlignment">
            <option value="left" ${p.alignment === 'left' ? 'selected' : ''}>Esquerda</option>
            <option value="center" ${p.alignment === 'center' || !p.alignment ? 'selected' : ''}>Centro</option>
            <option value="right" ${p.alignment === 'right' ? 'selected' : ''}>Direita</option>
          </select>
        </div>
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorStamp(element) {
      const p = element.properties || {};
      const fit = Array.isArray(p.fit) ? p.fit : [p.fit || 120, p.fit || 120];
      return `
        <div class="inspector-field">
          <label>Tipo de Fonte</label>
          <select id="insp-stampSourceType">
            <option value="image" ${p.sourceType === 'image' || !p.sourceType ? 'selected' : ''}>Imagem</option>
            <option value="svg" ${p.sourceType === 'svg' ? 'selected' : ''}>SVG</option>
          </select>
        </div>
        <div class="inspector-field" id="insp-stampValueField">
          <label id="insp-stampValueLabel">${p.sourceType === 'svg' ? 'Código SVG' : 'URL ou DataURL'}</label>
          ${p.sourceType === 'svg' ?
          `<textarea id="insp-stampValue" rows="6" placeholder="<svg>...</svg>">${escapeHtml(p.value || '')}</textarea>` :
          `<input type="text" id="insp-stampValue" value="${escapeHtml(p.value || '')}" placeholder="https://exemplo.com/imagem.png ou data:image/...">`
        }
          <div class="smallNote">${p.sourceType === 'svg' ? 'Cole o código SVG completo' : 'URL da imagem (http/https) ou dataURL (data:image/...)'}</div>
        </div>
        <div class="inspector-field">
          <label>Fit (Largura x Altura)</label>
          <div class="row">
            <div>
              <input type="number" id="insp-stampFitW" value="${fit[0]}" min="10" max="500">
            </div>
            <div>
              <input type="number" id="insp-stampFitH" value="${fit[1]}" min="10" max="500">
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Alinhamento</label>
          <select id="insp-stampAlignment">
            <option value="left" ${p.alignment === 'left' ? 'selected' : ''}>Esquerda</option>
            <option value="center" ${p.alignment === 'center' || !p.alignment ? 'selected' : ''}>Centro</option>
            <option value="right" ${p.alignment === 'right' ? 'selected' : ''}>Direita</option>
          </select>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Opacidade</label>
          <input type="number" id="insp-stampOpacity" value="${p.opacity !== undefined ? p.opacity : 1}" min="0" max="1" step="0.1">
        </div>
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorCheckbox(element) {
      const p = element.properties || {};
      return `
        <div class="inspector-field">
          <label>Texto</label>
          <input type="text" id="insp-choiceText" value="${escapeHtml(p.choiceText || 'Texto...')}" placeholder="Texto...">
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">Texto que aparece ao lado do ícone</div>
        </div>
        <div class="inspector-field">
          <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
            <input type="checkbox" id="insp-choiceChecked" ${p.choiceChecked === true ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
            <span>Marcado</span>
          </label>
        </div>
        <div class="inspector-field">
          <label>Posição do Ícone</label>
          <select id="insp-choiceIconPosition">
            <option value="before" ${p.choiceIconPosition === 'before' || !p.choiceIconPosition ? 'selected' : ''}>Antes do texto</option>
            <option value="after" ${p.choiceIconPosition === 'after' ? 'selected' : ''}>Depois do texto</option>
          </select>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Tamanho do Ícone</label>
              <input type="number" id="insp-choiceIconSize" value="${p.choiceIconSize || 12}" min="8" max="30" step="1">
            </div>
            <div>
              <label class="smallNote">Gap (distância)</label>
              <input type="number" id="insp-choiceGap" value="${p.choiceGap || 8}" min="0" max="30" step="1">
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Alinhamento</label>
          <select id="insp-choiceAlignment">
            <option value="left" ${p.alignment === 'left' || !p.alignment ? 'selected' : ''}>Esquerda</option>
            <option value="center" ${p.alignment === 'center' ? 'selected' : ''}>Centro</option>
            <option value="right" ${p.alignment === 'right' ? 'selected' : ''}>Direita</option>
          </select>
        </div>
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorRadio(element) {
      const p = element.properties || {};
      return `
        <div class="inspector-field">
          <label>Texto</label>
          <input type="text" id="insp-choiceText" value="${escapeHtml(p.choiceText || 'Texto...')}" placeholder="Texto...">
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">Texto que aparece ao lado do ícone</div>
        </div>
        <div class="inspector-field">
          <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
            <input type="checkbox" id="insp-choiceChecked" ${p.choiceChecked === true ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
            <span>Marcado</span>
          </label>
        </div>
        <div class="inspector-field">
          <label>Posição do Ícone</label>
          <select id="insp-choiceIconPosition">
            <option value="before" ${p.choiceIconPosition === 'before' || !p.choiceIconPosition ? 'selected' : ''}>Antes do texto</option>
            <option value="after" ${p.choiceIconPosition === 'after' ? 'selected' : ''}>Depois do texto</option>
          </select>
        </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Tamanho do Ícone</label>
              <input type="number" id="insp-choiceIconSize" value="${p.choiceIconSize || 12}" min="8" max="30" step="1">
            </div>
            <div>
              <label class="smallNote">Gap (distância)</label>
              <input type="number" id="insp-choiceGap" value="${p.choiceGap || 8}" min="0" max="30" step="1">
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Alinhamento</label>
          <select id="insp-choiceAlignment">
            <option value="left" ${p.alignment === 'left' || !p.alignment ? 'selected' : ''}>Esquerda</option>
            <option value="center" ${p.alignment === 'center' ? 'selected' : ''}>Centro</option>
            <option value="right" ${p.alignment === 'right' ? 'selected' : ''}>Direita</option>
          </select>
        </div>
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorFillLine(element) {
      const p = element.properties || {};
      return `
        <div class="inspector-field">
          <label class="smallNote">Largura da Linha</label>
          <input type="number" id="insp-fillLineWidth" value="${p.lineWidth || 200}" min="50" max="800" step="10">
        </div>
        <div class="inspector-field">
          <label class="smallNote">Espessura</label>
          <input type="number" id="insp-fillLineThickness" value="${p.thickness || 0.8}" min="0.5" max="5" step="0.1">
        </div>
        <div class="inspector-field">
          <label class="smallNote">Cor</label>
          <input type="color" id="insp-fillLineColor" value="${p.color || '#000000'}">
        </div>
        <div class="inspector-field">
          <label class="smallNote">Alinhamento</label>
          <select id="insp-fillLineAlignment">
            <option value="left" ${p.alignment === 'left' || !p.alignment ? 'selected' : ''}>Esquerda</option>
            <option value="center" ${p.alignment === 'center' ? 'selected' : ''}>Centro</option>
            <option value="right" ${p.alignment === 'right' ? 'selected' : ''}>Direita</option>
          </select>
        </div>
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorChart(element) {
      const p = element.properties || {};
      const fit = Array.isArray(p.chartFit) ? p.chartFit : [p.chartFit || 400, p.chartFit || 200];
      return `
        <div class="inspector-field">
          <label>Tipo de Gráfico</label>
          <select id="insp-chartType">
            <option value="bar" ${p.chartType === 'bar' || !p.chartType ? 'selected' : ''}>Barra</option>
            <option value="line" ${p.chartType === 'line' ? 'selected' : ''}>Linha</option>
            <option value="pie" ${p.chartType === 'pie' ? 'selected' : ''}>Pizza</option>
            <option value="doughnut" ${p.chartType === 'doughnut' ? 'selected' : ''}>Rosca</option>
            <option value="radar" ${p.chartType === 'radar' ? 'selected' : ''}>Radar</option>
            <option value="polarArea" ${p.chartType === 'polarArea' ? 'selected' : ''}>Área Polar</option>
            <option value="scatter" ${p.chartType === 'scatter' ? 'selected' : ''}>Dispersão</option>
            <option value="bubble" ${p.chartType === 'bubble' ? 'selected' : ''}>Bolha</option>
            <option value="mixed" ${p.chartType === 'mixed' ? 'selected' : ''}>Misto</option>
          </select>
        </div>
        <div class="inspector-field">
          <label>Tamanho do Gráfico</label>
          <div class="row">
            <div>
              <label class="smallNote">Largura</label>
              <input type="number" id="insp-chartWidth" value="${p.chartWidth || 400}" min="200" max="800" step="10">
            </div>
            <div>
              <label class="smallNote">Altura</label>
              <input type="number" id="insp-chartHeight" value="${p.chartHeight || 200}" min="100" max="600" step="10">
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <label>Fit (Largura x Altura)</label>
          <div class="row">
            <div>
              <input type="number" id="insp-chartFitW" value="${fit[0]}" min="100" max="800" step="10">
            </div>
            <div>
              <input type="number" id="insp-chartFitH" value="${fit[1]}" min="50" max="600" step="10">
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Cor de Fundo</label>
          <input type="color" id="insp-chartBackgroundColor" value="${p.chartBackgroundColor || '#FFFFFF'}">
        </div>
        <div class="inspector-field">
          <label class="smallNote">Device Pixel Ratio</label>
          <input type="number" id="insp-chartDevicePixelRatio" value="${p.chartDevicePixelRatio || 2}" min="1" max="4" step="1">
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">Valor maior = melhor qualidade (2 é recomendado)</div>
        </div>
        <div class="inspector-field">
          <label>Dados do Gráfico (JSON)</label>
          <textarea id="insp-chartData" rows="8" placeholder='{"labels": ["Jan", "Feb"], "datasets": [...]}'>${escapeHtml(JSON.stringify(p.chartData || { labels: [], datasets: [] }, null, 2))}</textarea>
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">Formato JSON do Chart.js. Deve conter "labels" e "datasets"</div>
        </div>
        <div class="inspector-field">
          <label>Opções do Gráfico (JSON)</label>
          <textarea id="insp-chartOptions" rows="8" placeholder='{"responsive": false, "animation": {"duration": 0}, ...}'>${escapeHtml(JSON.stringify(p.chartOptions || { responsive: false, animation: { duration: 0 } }, null, 2))}</textarea>
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">Formato JSON do Chart.js. animation.duration deve ser 0 para export correto</div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Alinhamento</label>
          <select id="insp-chartAlignment">
            <option value="left" ${p.alignment === 'left' ? 'selected' : ''}>Esquerda</option>
            <option value="center" ${p.alignment === 'center' || !p.alignment ? 'selected' : ''}>Centro</option>
            <option value="right" ${p.alignment === 'right' ? 'selected' : ''}>Direita</option>
          </select>
        </div>
        ${renderMarginSection(element)}
      `;
    }

    function renderInspectorGroup(element) {
      const p = element.properties || {};
      return `
        <div class="inspector-field">
          <label class="smallNote">Orientaçao</label>
          <select id="insp-groupOrientation">
            <option value="column" ${p.orientation === 'column' ? 'selected' : ''}>Coluna (vertical)</option>
            <option value="row" ${p.orientation === 'row' ? 'selected' : ''}>Linha (horizontal)</option>
          </select>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Alinhamento</label>
          <select id="insp-groupAlignment">
            <option value="left" ${p.alignment === 'left' ? 'selected' : ''}>Esquerda</option>
            <option value="center" ${p.alignment === 'center' ? 'selected' : ''}>Centro</option>
            <option value="right" ${p.alignment === 'right' ? 'selected' : ''}>Direita</option>
            <option value="justify" ${p.alignment === 'justify' ? 'selected' : ''}>Justificado</option>
          </select>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Espaçamento entre elementos (gap)</label>
          <input type="number" id="insp-groupGap" value="${p.gap || 10}" min="0" max="50">
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">Espaço entre os elementos dentro do grupo</div>
        </div>
        <div class="inspector-field">
          <div class="smallNote" style="margin-top: 0.25rem; font-size: 0.75rem; color: var(--text-tertiary);">Elementos no grupo: ${p.children?.length || 0}</div>
        </div>
        ${renderMarginSection(element)}
      `;
    }

    // Variáveis para debounce e preservação de foco
    let renderTimeout = null;
    let focusedElementId = null;
    let focusedElementValue = null;
    let focusedElementSelectionStart = null;
    let focusedElementSelectionEnd = null;

    function attachInspectorListeners(element) {
      const p = element.properties || {};
      const parentGroupInfo = findParentGroup(element.id);

      // Listeners genéricos para margens (aplicável a todos os elementos)
      const marginInputs = document.querySelectorAll('.margin-input');
      marginInputs.forEach(input => {
        input.addEventListener('input', () => {
          const side = parseInt(input.dataset.side || 0);
          if (!p.margin) p.margin = [0, 0, 0, 0];
          p.margin[side] = parseInt(input.value || 0) || 0;
          // Se todas as margens são 0, remover a propriedade
          if (p.margin.every(m => m === 0)) {
            delete p.margin;
          }
          updateWithoutLosingFocus(() => {
            // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
            if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
          }, 300);
        });
      });

      // Função helper para atualizar sem perder foco
      function updateWithoutLosingFocus(updateFn, delay = 300) {
        // Ativar modo de edição para evitar ajuste de tamanho durante edições
        isEditingMode = true;

        // Salvar estado do elemento focado
        const activeElement = document.activeElement;
        if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
          focusedElementId = activeElement.id;
          // IMPORTANTE: Para inputs number, salvar o valor como string para preservar digitação parcial
          focusedElementValue = activeElement.value;
          // Para inputs number, selectionStart/End podem ser null, usar 0 como fallback
          focusedElementSelectionStart = activeElement.selectionStart !== null ? activeElement.selectionStart : activeElement.value.length;
          focusedElementSelectionEnd = activeElement.selectionEnd !== null ? activeElement.selectionEnd : activeElement.value.length;
        }

        // Limpar timeout anterior
        if (renderTimeout) {
          clearTimeout(renderTimeout);
        }

        // Executar atualização após delay
        renderTimeout = setTimeout(() => {
          updateFn();

          // Desativar modo de edição após um pequeno delay para permitir que o DOM se estabilize
          setTimeout(() => {
            isEditingMode = false;
          }, 200);

          // Restaurar foco após renderização
          setTimeout(() => {
            if (focusedElementId) {
              const element = document.getElementById(focusedElementId);
              if (element) {
                // IMPORTANTE: Para inputs number, restaurar o valor ANTES de focar
                if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
                  // Restaurar o valor exato que estava sendo digitado (pode incluir digitação parcial)
                  element.value = focusedElementValue;

                  // Focar o elemento
                  element.focus();

                  // Restaurar posição do cursor após um pequeno delay para garantir que o valor foi aplicado
                  setTimeout(() => {
                    if (element.setSelectionRange && focusedElementSelectionStart !== undefined && focusedElementSelectionStart !== null) {
                      const len = element.value.length;
                      const start = Math.min(Math.max(0, focusedElementSelectionStart), len);
                      const end = Math.min(Math.max(0, focusedElementSelectionEnd !== undefined && focusedElementSelectionEnd !== null ? focusedElementSelectionEnd : focusedElementSelectionStart), len);

                      // IMPORTANTE: Para inputs number, tentar restaurar a posição do cursor
                      try {
                        element.setSelectionRange(start, end);
                      } catch (e) {
                        // Alguns navegadores podem não suportar setSelectionRange em inputs number
                        // Nesse caso, tentar posicionar o cursor no final
                        try {
                          element.setSelectionRange(len, len);
                        } catch (e2) {
                          // Se ainda falhar, apenas manter o foco
                        }
                      }
                    } else {
                      // Se não houver seleção salva, posicionar no final
                      try {
                        const len = element.value.length;
                        element.setSelectionRange(len, len);
                      } catch (e) {
                        // Ignorar erro
                      }
                    }
                  }, 5);
                } else {
                  element.focus();
                }
              }
            }
          }, 50); // Aumentar delay para garantir que o DOM foi completamente atualizado
        }, delay);
      }

      // Handle width field if element is in a horizontal group
      if (parentGroupInfo && parentGroupInfo.group.properties && parentGroupInfo.group.properties.orientation === 'row') {
        const widthInput = document.getElementById('insp-width');
        if (widthInput && typeof redistributeGroupWidths === 'function') {
          widthInput.addEventListener('input', () => {
            // IMPORTANTE: Não processar o valor imediatamente para inputs number
            // Deixar o valor como string durante a digitação para preservar posição do cursor
            const rawValue = widthInput.value;
            // Apenas atualizar se o valor for válido (não vazio e numérico)
            if (rawValue !== '' && !isNaN(rawValue)) {
              const newWidth = parseFloat(rawValue) || 0;
              redistributeGroupWidths(parentGroupInfo.group, element.id, newWidth);
            }
            updateWithoutLosingFocus(() => {
              // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
              if (typeof renderAll === 'function') {
                renderAll(false);
              } else if (typeof render === 'function') {
                render();
              }
              // Re-renderizar o inspector para atualizar os valores dos outros elementos
              setTimeout(() => {
                if (typeof renderInspector === 'function') renderInspector();
              }, 0);
            }, 300);
          });
        }
      }


      // Handle height field if element is in a group
      if (parentGroupInfo) {
        const heightInput = document.getElementById('insp-height');
        if (heightInput) {
          heightInput.addEventListener('input', () => {
            // IMPORTANTE: Não processar o valor imediatamente para inputs number
            // Deixar o valor como string durante a digitação para preservar posição do cursor
            const rawValue = heightInput.value;
            // Apenas atualizar se o valor for válido (não vazio e numérico)
            if (rawValue !== '' && !isNaN(rawValue)) {
              element.h = parseInt(rawValue) || 100;
            }
            if (typeof updateGroupDimensions === 'function') {
              updateGroupDimensions(parentGroupInfo.group);
            }
            updateWithoutLosingFocus(() => {
              if (typeof renderAll === 'function') {
                renderAll();
              } else if (typeof render === 'function') {
                render();
              }
            }, 300);
          });
        }
      }

      // Adicionar listener para verticalAlignment de célula de tabela
      const cellVerticalAlignmentSelect = document.getElementById('insp-cellVerticalAlignment');
      if (cellVerticalAlignmentSelect) {
        const nodeWithParent = findNodeWithParent(element.id);
        if (nodeWithParent && nodeWithParent.parent && nodeWithParent.ctx && nodeWithParent.ctx.kind === 'tableCell') {
          const ctx = nodeWithParent.ctx;
          const table = nodeWithParent.parent;
          const cell = table.properties.body[ctx.row][ctx.col];

          cellVerticalAlignmentSelect.addEventListener('change', () => {
            cell.verticalAlignment = cellVerticalAlignmentSelect.value;
            updateWithoutLosingFocus(() => {
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
            }, 300);
          });
        }
      }

      switch (element.type) {
        case 'text':
          const elementIdInput = document.getElementById('insp-elementId');
          const textInput = document.getElementById('insp-text');
          const textLinkInput = document.getElementById('insp-link');
          const fontSizeInput = document.getElementById('insp-fontSize');

          if (elementIdInput) {
            elementIdInput.addEventListener('input', () => {
              const idValue = elementIdInput.value.trim();
              if (idValue) {
                p.id = idValue;
              } else {
                delete p.id;
              }
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          const fontSelect = document.getElementById('insp-font');
          const fontFeaturesInput = document.getElementById('insp-fontFeatures');
          const alignmentSelect = document.getElementById('insp-alignment');
          const decorationSelect = document.getElementById('insp-decoration');
          const colorInput = document.getElementById('insp-color');
          const colorTextInput = document.getElementById('insp-colorText');
          const backgroundInput = document.getElementById('insp-background');
          const backgroundTextInput = document.getElementById('insp-backgroundText');
          const boldCheck = document.getElementById('insp-bold');
          const italicsCheck = document.getElementById('insp-italics');
          const lineHeightInput = document.getElementById('insp-lineHeight');
          const characterSpacingInput = document.getElementById('insp-characterSpacing');
          const decorationStyleSelect = document.getElementById('insp-decorationStyle');
          const decorationColorInput = document.getElementById('insp-decorationColor');
          const decorationColorTextInput = document.getElementById('insp-decorationColorText');
          const decorationOptions = document.getElementById('decorationOptions');

          if (textInput) {
            textInput.addEventListener('input', () => {
              p.text = textInput.value;
              updateParentGroupsDimensions(element.id);
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          // Handle link type selector
          const linkTypeSelect = document.getElementById('insp-linkType');
          const linkUrlOptions = document.getElementById('insp-linkUrlOptions');
          const linkPageOptions = document.getElementById('insp-linkPageOptions');
          const linkDestinationOptions = document.getElementById('insp-linkDestinationOptions');

          if (linkTypeSelect) {
            linkTypeSelect.addEventListener('change', () => {
              const linkType = linkTypeSelect.value;

              // Preservar o tipo escolhido mesmo quando não há valor ainda
              p._linkType = linkType;

              // Show/hide options
              if (linkUrlOptions) linkUrlOptions.style.display = linkType === 'url' ? '' : 'none';
              if (linkPageOptions) linkPageOptions.style.display = linkType === 'page' ? '' : 'none';
              if (linkDestinationOptions) linkDestinationOptions.style.display = linkType === 'destination' ? '' : 'none';

              // Apenas limpar propriedades se mudou para 'none', caso contrário manter valores existentes
              if (linkType === 'none') {
                delete p.link;
                delete p.linkToPage;
                delete p.linkToDestination;
                delete p._linkType;
              } else if (linkType === 'url') {
                // Se mudou para URL, limpar outros tipos mas manter URL se existir
                delete p.linkToPage;
                delete p.linkToDestination;
                // Não limpar p.link - deixar o usuário preencher ou manter se já existe
              } else if (linkType === 'page') {
                // Se mudou para página, limpar outros tipos mas manter linkToPage se existir
                delete p.link;
                delete p.linkToDestination;
                if (!p.linkToPage && linkToPageInput) {
                  // Se não tinha página, definir padrão 1
                  p.linkToPage = 1;
                  if (linkToPageInput) linkToPageInput.value = 1;
                }
              } else if (linkType === 'destination') {
                // Se mudou para destino, limpar outros tipos mas manter linkToDestination se existir
                delete p.link;
                delete p.linkToPage;
                // Não limpar p.linkToDestination - deixar o usuário preencher ou manter se já existe
              }

              // Não re-renderizar o inspector para não perder a seleção do dropdown
              // Apenas atualizar a renderização do canvas se necessário
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
            });
          }

          if (textLinkInput) {
            textLinkInput.addEventListener('input', () => {
              const urlValue = textLinkInput.value.trim();
              if (urlValue) {
                p.link = urlValue;
                delete p.linkToPage;
                delete p.linkToDestination;
                p._linkType = 'url'; // Preservar tipo escolhido
              } else {
                // Se limpou o campo, verificar se deve manter o tipo ou limpar tudo
                if (p._linkType === 'url') {
                  delete p.link;
                } else {
                  delete p.link;
                  delete p._linkType;
                }
              }
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          const linkToPageInput = document.getElementById('insp-linkToPage');
          if (linkToPageInput) {
            linkToPageInput.addEventListener('input', () => {
              const pageNum = parseInt(linkToPageInput.value);
              if (pageNum > 0) {
                p.linkToPage = pageNum;
                delete p.link;
                delete p.linkToDestination;
                p._linkType = 'page'; // Preservar tipo escolhido
              } else {
                // Se limpou o campo, verificar se deve manter o tipo ou limpar tudo
                if (p._linkType === 'page') {
                  delete p.linkToPage;
                } else {
                  delete p.linkToPage;
                  delete p._linkType;
                }
              }
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          const linkToDestinationInput = document.getElementById('insp-linkToDestination');
          if (linkToDestinationInput) {
            linkToDestinationInput.addEventListener('input', () => {
              const dest = linkToDestinationInput.value.trim();
              if (dest) {
                p.linkToDestination = dest;
                delete p.link;
                delete p.linkToPage;
                p._linkType = 'destination'; // Preservar tipo escolhido
              } else {
                // Se limpou o campo, verificar se deve manter o tipo ou limpar tudo
                if (p._linkType === 'destination') {
                  delete p.linkToDestination;
                } else {
                  delete p.linkToDestination;
                  delete p._linkType;
                }
              }
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (fontSizeInput) {
            const fontSizeError = document.getElementById('insp-fontSizeError');

            fontSizeInput.addEventListener('input', () => {
              // IMPORTANTE: Não processar o valor imediatamente para inputs number
              // Deixar o valor como string durante a digitação para preservar posição do cursor
              const rawValue = fontSizeInput.value;

              // Validar range
              if (rawValue !== '' && !isNaN(rawValue)) {
                const fontSize = parseInt(rawValue);
                if (fontSize < 8 || fontSize > 72) {
                  if (fontSizeError) {
                    fontSizeError.textContent = `⚠️ Tamanho da fonte deve estar entre 8 e 72 (valor atual: ${fontSize})`;
                    fontSizeError.style.display = 'block';
                  }
                } else {
                  if (fontSizeError) {
                    fontSizeError.style.display = 'none';
                  }
                  p.fontSize = fontSize;
                }
              } else if (rawValue === '') {
                if (fontSizeError) {
                  fontSizeError.style.display = 'none';
                }
              }

              updateParentGroupsDimensions(element.id);
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (fontSelect) {
            fontSelect.addEventListener('change', () => {
              isEditingMode = true;
              p.font = fontSelect.value || null;
              // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              setTimeout(() => { isEditingMode = false; }, 200);
            });
          }
          if (fontFeaturesInput) {
            fontFeaturesInput.addEventListener('input', () => {
              const val = fontFeaturesInput.value.trim();
              p.fontFeatures = val ? val.split(',').map(f => f.trim()).filter(Boolean) : undefined;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (alignmentSelect) alignmentSelect.addEventListener('change', () => {
            isEditingMode = true;
            p.alignment = alignmentSelect.value;
            // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
            if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
            setTimeout(() => { isEditingMode = false; }, 200);
          });
          if (decorationSelect) {
            decorationSelect.addEventListener('change', () => {
              isEditingMode = true;
              p.decoration = decorationSelect.value || null;
              if (decorationOptions) decorationOptions.style.display = p.decoration ? '' : 'none';
              // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              setTimeout(() => { isEditingMode = false; }, 200);
            });
          }
          if (decorationStyleSelect) {
            decorationStyleSelect.addEventListener('change', () => {
              isEditingMode = true;
              p.decorationStyle = decorationStyleSelect.value || null;
              // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              setTimeout(() => { isEditingMode = false; }, 200);
            });
          }
          if (decorationColorInput && decorationColorTextInput) {
            decorationColorInput.addEventListener('input', () => {
              decorationColorTextInput.value = decorationColorInput.value;
              p.decorationColor = decorationColorInput.value;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
            decorationColorTextInput.addEventListener('input', () => {
              if (!decorationColorTextInput.value.trim()) {
                p.decorationColor = null;
              } else if (/^#[0-9A-F]{6}$/i.test(decorationColorTextInput.value)) {
                decorationColorInput.value = decorationColorTextInput.value;
                p.decorationColor = decorationColorTextInput.value;
              }
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (colorInput && colorTextInput) {
            colorInput.addEventListener('input', () => {
              colorTextInput.value = colorInput.value;
              p.color = colorInput.value;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
            colorTextInput.addEventListener('input', () => {
              if (/^#[0-9A-F]{6}$/i.test(colorTextInput.value)) {
                colorInput.value = colorTextInput.value;
                p.color = colorTextInput.value;
                updateWithoutLosingFocus(() => {
                  // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                  if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
                }, 300);
              }
            });
          }
          if (backgroundInput && backgroundTextInput) {
            backgroundInput.addEventListener('input', () => {
              backgroundTextInput.value = backgroundInput.value;
              p.background = backgroundInput.value || null;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
            backgroundTextInput.addEventListener('input', () => {
              if (!backgroundTextInput.value.trim()) {
                p.background = null;
              } else if (/^#[0-9A-F]{6}$/i.test(backgroundTextInput.value)) {
                backgroundInput.value = backgroundTextInput.value;
                p.background = backgroundTextInput.value;
              }
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (boldCheck) boldCheck.addEventListener('change', () => {
            p.bold = boldCheck.checked;
            // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
            if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
          });
          if (italicsCheck) italicsCheck.addEventListener('change', () => {
            p.italics = italicsCheck.checked;
            // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
            if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
          });
          if (lineHeightInput) {
            lineHeightInput.addEventListener('input', () => {
              // IMPORTANTE: Não processar o valor imediatamente para inputs number
              const val = lineHeightInput.value.trim();
              if (val !== '' && !isNaN(val)) {
                p.lineHeight = parseFloat(val);
              } else if (val === '') {
                p.lineHeight = undefined;
              }
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (characterSpacingInput) {
            characterSpacingInput.addEventListener('input', () => {
              // IMPORTANTE: Não processar o valor imediatamente para inputs number
              const val = characterSpacingInput.value.trim();
              if (val !== '' && !isNaN(val)) {
                p.characterSpacing = parseFloat(val);
              } else if (val === '') {
                p.characterSpacing = undefined;
              }
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          break;

        case 'header':
          const headerElementIdInput = document.getElementById('insp-headerElementId');
          const headerTextInput = document.getElementById('insp-headerText');
          const headerLinkInput = document.getElementById('insp-headerLink');
          const headerFontSizeInput = document.getElementById('insp-headerFontSize');

          if (headerElementIdInput) {
            headerElementIdInput.addEventListener('input', () => {
              const idValue = headerElementIdInput.value.trim();
              if (idValue) {
                p.id = idValue;
              } else {
                delete p.id;
              }
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          const headerFontSelect = document.getElementById('insp-headerFont');
          const headerFontFeaturesInput = document.getElementById('insp-headerFontFeatures');
          const headerAlignmentSelect = document.getElementById('insp-headerAlignment');
          const headerDecorationSelect = document.getElementById('insp-headerDecoration');
          const headerColorInput = document.getElementById('insp-headerColor');
          const headerColorTextInput = document.getElementById('insp-headerColorText');
          const headerBackgroundInput = document.getElementById('insp-headerBackground');
          const headerBackgroundTextInput = document.getElementById('insp-headerBackgroundText');
          const headerBoldCheck = document.getElementById('insp-headerBold');
          const headerItalicsCheck = document.getElementById('insp-headerItalics');
          const headerLineHeightInput = document.getElementById('insp-headerLineHeight');
          const headerCharacterSpacingInput = document.getElementById('insp-headerCharacterSpacing');
          const headerDecorationStyleSelect = document.getElementById('insp-headerDecorationStyle');
          const headerDecorationColorInput = document.getElementById('insp-headerDecorationColor');
          const headerDecorationColorTextInput = document.getElementById('insp-headerDecorationColorText');
          const headerDecorationOptions = document.getElementById('headerDecorationOptions');

          if (headerTextInput) {
            headerTextInput.addEventListener('input', () => {
              p.text = headerTextInput.value;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          // Handle header link type selector
          const headerLinkTypeSelect = document.getElementById('insp-headerLinkType');
          const headerLinkUrlOptions = document.getElementById('insp-headerLinkUrlOptions');
          const headerLinkPageOptions = document.getElementById('insp-headerLinkPageOptions');
          const headerLinkDestinationOptions = document.getElementById('insp-headerLinkDestinationOptions');

          if (headerLinkTypeSelect) {
            headerLinkTypeSelect.addEventListener('change', () => {
              const linkType = headerLinkTypeSelect.value;

              // Preservar o tipo escolhido mesmo quando não há valor ainda
              p._linkType = linkType;

              // Show/hide options
              if (headerLinkUrlOptions) headerLinkUrlOptions.style.display = linkType === 'url' ? '' : 'none';
              if (headerLinkPageOptions) headerLinkPageOptions.style.display = linkType === 'page' ? '' : 'none';
              if (headerLinkDestinationOptions) headerLinkDestinationOptions.style.display = linkType === 'destination' ? '' : 'none';

              // Apenas limpar propriedades se mudou para 'none', caso contrário manter valores existentes
              if (linkType === 'none') {
                delete p.link;
                delete p.linkToPage;
                delete p.linkToDestination;
                delete p._linkType;
              } else if (linkType === 'url') {
                // Se mudou para URL, limpar outros tipos mas manter URL se existir
                delete p.linkToPage;
                delete p.linkToDestination;
                // Não limpar p.link - deixar o usuário preencher ou manter se já existe
              } else if (linkType === 'page') {
                // Se mudou para página, limpar outros tipos mas manter linkToPage se existir
                delete p.link;
                delete p.linkToDestination;
                if (!p.linkToPage && headerLinkToPageInput) {
                  // Se não tinha página, definir padrão 1
                  p.linkToPage = 1;
                  if (headerLinkToPageInput) headerLinkToPageInput.value = 1;
                }
              } else if (linkType === 'destination') {
                // Se mudou para destino, limpar outros tipos mas manter linkToDestination se existir
                delete p.link;
                delete p.linkToPage;
                // Não limpar p.linkToDestination - deixar o usuário preencher ou manter se já existe
              }

              // Não re-renderizar o inspector para não perder a seleção do dropdown
              // Apenas atualizar a renderização do canvas se necessário
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
            });
          }

          if (headerLinkInput) {
            headerLinkInput.addEventListener('input', () => {
              const urlValue = headerLinkInput.value.trim();
              if (urlValue) {
                p.link = urlValue;
                delete p.linkToPage;
                delete p.linkToDestination;
                p._linkType = 'url'; // Preservar tipo escolhido
              } else {
                // Se limpou o campo, verificar se deve manter o tipo ou limpar tudo
                if (p._linkType === 'url') {
                  delete p.link;
                } else {
                  delete p.link;
                  delete p._linkType;
                }
              }
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          const headerLinkToPageInput = document.getElementById('insp-headerLinkToPage');
          if (headerLinkToPageInput) {
            headerLinkToPageInput.addEventListener('input', () => {
              const pageNum = parseInt(headerLinkToPageInput.value);
              if (pageNum > 0) {
                p.linkToPage = pageNum;
                delete p.link;
                delete p.linkToDestination;
                p._linkType = 'page'; // Preservar tipo escolhido
              } else {
                // Se limpou o campo, verificar se deve manter o tipo ou limpar tudo
                if (p._linkType === 'page') {
                  delete p.linkToPage;
                } else {
                  delete p.linkToPage;
                  delete p._linkType;
                }
              }
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          const headerLinkToDestinationInput = document.getElementById('insp-headerLinkToDestination');
          if (headerLinkToDestinationInput) {
            headerLinkToDestinationInput.addEventListener('input', () => {
              const dest = headerLinkToDestinationInput.value.trim();
              if (dest) {
                p.linkToDestination = dest;
                delete p.link;
                delete p.linkToPage;
                p._linkType = 'destination'; // Preservar tipo escolhido
              } else {
                // Se limpou o campo, verificar se deve manter o tipo ou limpar tudo
                if (p._linkType === 'destination') {
                  delete p.linkToDestination;
                } else {
                  delete p.linkToDestination;
                  delete p._linkType;
                }
              }
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (headerFontSizeInput) {
            headerFontSizeInput.addEventListener('input', () => {
              // IMPORTANTE: Não processar o valor imediatamente para inputs number
              const rawValue = headerFontSizeInput.value;
              if (rawValue !== '' && !isNaN(rawValue)) {
                p.fontSize = parseInt(rawValue);
              }
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (headerFontSelect) {
            headerFontSelect.addEventListener('change', () => {
              p.font = headerFontSelect.value || null;
              // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
            });
          }
          if (headerFontFeaturesInput) {
            headerFontFeaturesInput.addEventListener('input', () => {
              const val = headerFontFeaturesInput.value.trim();
              p.fontFeatures = val ? val.split(',').map(f => f.trim()).filter(Boolean) : undefined;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (headerAlignmentSelect) headerAlignmentSelect.addEventListener('change', () => {
            p.alignment = headerAlignmentSelect.value;
            // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
            if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
          });
          if (headerDecorationSelect) {
            headerDecorationSelect.addEventListener('change', () => {
              p.decoration = headerDecorationSelect.value || null;
              if (headerDecorationOptions) headerDecorationOptions.style.display = p.decoration ? '' : 'none';
              // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
            });
          }
          if (headerDecorationStyleSelect) {
            headerDecorationStyleSelect.addEventListener('change', () => {
              p.decorationStyle = headerDecorationStyleSelect.value || null;
              // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
            });
          }
          if (headerDecorationColorInput && headerDecorationColorTextInput) {
            headerDecorationColorInput.addEventListener('input', () => {
              headerDecorationColorTextInput.value = headerDecorationColorInput.value;
              p.decorationColor = headerDecorationColorInput.value;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
            headerDecorationColorTextInput.addEventListener('input', () => {
              if (!headerDecorationColorTextInput.value.trim()) {
                p.decorationColor = null;
              } else if (/^#[0-9A-F]{6}$/i.test(headerDecorationColorTextInput.value)) {
                headerDecorationColorInput.value = headerDecorationColorTextInput.value;
                p.decorationColor = headerDecorationColorTextInput.value;
              }
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (headerColorInput && headerColorTextInput) {
            headerColorInput.addEventListener('input', () => {
              headerColorTextInput.value = headerColorInput.value;
              p.color = headerColorInput.value;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
            headerColorTextInput.addEventListener('input', () => {
              if (/^#[0-9A-F]{6}$/i.test(headerColorTextInput.value)) {
                headerColorInput.value = headerColorTextInput.value;
                p.color = headerColorTextInput.value;
                updateWithoutLosingFocus(() => {
                  // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                  if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
                }, 300);
              }
            });
          }
          if (headerBackgroundInput && headerBackgroundTextInput) {
            headerBackgroundInput.addEventListener('input', () => {
              headerBackgroundTextInput.value = headerBackgroundInput.value;
              p.background = headerBackgroundInput.value || null;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
            headerBackgroundTextInput.addEventListener('input', () => {
              if (!headerBackgroundTextInput.value.trim()) {
                p.background = null;
              } else if (/^#[0-9A-F]{6}$/i.test(headerBackgroundTextInput.value)) {
                headerBackgroundInput.value = headerBackgroundTextInput.value;
                p.background = headerBackgroundTextInput.value;
              }
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (headerBoldCheck) headerBoldCheck.addEventListener('change', () => {
            p.bold = headerBoldCheck.checked;
            // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
            if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
          });
          if (headerItalicsCheck) headerItalicsCheck.addEventListener('change', () => {
            p.italics = headerItalicsCheck.checked;
            // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
            if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
          });
          if (headerLineHeightInput) {
            headerLineHeightInput.addEventListener('input', () => {
              const val = headerLineHeightInput.value.trim();
              p.lineHeight = val ? parseFloat(val) : undefined;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (headerCharacterSpacingInput) {
            headerCharacterSpacingInput.addEventListener('input', () => {
              const val = headerCharacterSpacingInput.value.trim();
              p.characterSpacing = val ? parseFloat(val) : undefined;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          break;

        case 'columns':
          const colCountInput = document.getElementById('insp-colCount');
          const colGapInput = document.getElementById('insp-colGap');
          const colValignSelect = document.getElementById('insp-colValign');
          const colTextsInput = document.getElementById('insp-colTexts');

          // Listeners para larguras das colunas
          document.querySelectorAll('.col-width-type').forEach(select => {
            select.addEventListener('change', () => {
              const colIndex = parseInt(select.dataset.colIndex || 0);
              const widthType = select.value;
              const valueInput = document.querySelector(`.col-width-value[data-col-index="${colIndex}"]`);
              const valueContainer = document.getElementById(`col-width-value-${colIndex}`);

              if (!p.columns || !p.columns[colIndex]) return;

              if (widthType === 'auto') {
                p.columns[colIndex].width = '*';
                if (valueContainer) valueContainer.style.display = 'none';
              } else {
                if (valueContainer) valueContainer.style.display = '';
                const currentValue = valueInput ? parseFloat(valueInput.value) || 0 : 0;
                if (widthType === 'pixels') {
                  p.columns[colIndex].width = currentValue || 100;
                } else if (widthType === 'percentage') {
                  p.columns[colIndex].width = currentValue ? `${currentValue}%` : '50%';
                }
              }

              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          });

          document.querySelectorAll('.col-width-value').forEach(input => {
            input.addEventListener('input', () => {
              const colIndex = parseInt(input.dataset.colIndex || 0);
              const typeSelect = document.querySelector(`.col-width-type[data-col-index="${colIndex}"]`);
              const widthType = typeSelect ? typeSelect.value : 'auto';
              // IMPORTANTE: Não processar o valor imediatamente para inputs number
              const rawValue = input.value;
              const value = (rawValue !== '' && !isNaN(rawValue)) ? parseFloat(rawValue) : 0;

              if (!p.columns || !p.columns[colIndex]) return;

              if (widthType === 'pixels') {
                p.columns[colIndex].width = value || 100;
              } else if (widthType === 'percentage') {
                p.columns[colIndex].width = value ? `${value}%` : '50%';
              }

              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          });

          // Listener para deletar coluna
          document.querySelectorAll('.btn-delete-col').forEach(btn => {
            btn.addEventListener('click', () => {
              const colIndex = parseInt(btn.dataset.colIndex || 0);
              if (colIndex > 0 && p.columns && p.columns.length > 1) {
                if (typeof showConfirmModal === 'function') {
                  showConfirmModal(
                    'Deletar Coluna',
                    `Tem certeza que deseja deletar a Coluna ${colIndex + 1}?`,
                    () => {
                      p.columns.splice(colIndex, 1);
                      if (colCountInput) colCountInput.value = p.columns.length;
                      if (typeof renderAll === 'function') {
                        renderAll();
                      } else if (typeof render === 'function') {
                        render();
                      }
                      setTimeout(() => {
                        if (typeof renderInspector === 'function') renderInspector();
                      }, 0);
                    }
                  );
                }
              }
            });
          });

          if (colCountInput) {
            colCountInput.addEventListener('input', () => {
              // IMPORTANTE: Não processar o valor imediatamente para inputs number
              const rawValue = colCountInput.value;
              const count = (rawValue !== '' && !isNaN(rawValue)) ? parseInt(rawValue) : 2;
              const current = p.columns || [];
              while (current.length < count) {
                current.push({ text: `Coluna ${current.length + 1}`, width: '*', children: [] });
              }
              while (current.length > count) {
                current.pop();
              }
              p.columns = current;
              if (typeof renderAll === 'function') {
                renderAll();
              } else if (typeof render === 'function') {
                render();
              }
              // Atualizar inspector para mostrar as novas colunas
              setTimeout(() => {
                if (typeof renderInspector === 'function') renderInspector();
              }, 0);
            });
          }

          if (colGapInput) {
            colGapInput.addEventListener('input', () => {
              // IMPORTANTE: Não processar o valor imediatamente para inputs number
              const rawValue = colGapInput.value;
              if (rawValue !== '' && !isNaN(rawValue)) {
                p.gap = parseInt(rawValue) || 10;
              }
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (colValignSelect) {
            colValignSelect.addEventListener('change', () => {
              p.valign = colValignSelect.value;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (colTextsInput) {
            colTextsInput.addEventListener('input', () => {
              const parts = colTextsInput.value.split('\n---\n');
              // Preservar children e width existentes ao atualizar textos
              p.columns = parts.map((t, i) => {
                const existingCol = p.columns && p.columns[i];
                return {
                  text: t.trim() || `Coluna ${i + 1}`,
                  width: existingCol?.width || '*',
                  children: existingCol?.children || []
                };
              });
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          break;

        case 'list':
          const listKindSelect = document.getElementById('insp-listKind');
          const listItemsInput = document.getElementById('insp-listItems');
          const listStartInput = document.getElementById('insp-listStart');
          const listTypeSelect = document.getElementById('insp-listType');
          const listReversedCheck = document.getElementById('insp-listReversed');
          const markerColorInput = document.getElementById('insp-markerColor');
          const markerColorTextInput = document.getElementById('insp-markerColorText');

          if (listKindSelect) {
            listKindSelect.addEventListener('change', () => {
              p.ordered = listKindSelect.value === 'ol';
              p.listType = listKindSelect.value;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (listStartInput) {
            listStartInput.addEventListener('input', () => {
              // IMPORTANTE: Não processar o valor imediatamente para inputs number
              const rawValue = listStartInput.value;
              if (rawValue !== '' && !isNaN(rawValue)) {
                p.start = parseInt(rawValue) || 1;
              }
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (listTypeSelect) {
            listTypeSelect.addEventListener('change', () => {
              p.type = listTypeSelect.value;
              // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
            });
          }
          if (listReversedCheck) {
            listReversedCheck.addEventListener('change', () => {
              p.reversed = listReversedCheck.checked;
              // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
            });
          }
          if (listItemsInput) {
            listItemsInput.addEventListener('input', () => {
              // Converter strings para objetos {kind: 'text', text: '...'}
              const lines = listItemsInput.value.split('\n').filter(Boolean);
              p.items = lines.map(line => ({ kind: 'text', text: line }));
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          break;

        case 'table':
          const tableColsInput = document.getElementById('insp-tableCols');
          const tableRowsInput = document.getElementById('insp-tableRows');
          const tableHeaderRowsInput = document.getElementById('insp-tableHeaderRows');
          const tableLayoutSelect = document.getElementById('insp-tableLayout');

          if (tableHeaderRowsInput) {
            tableHeaderRowsInput.addEventListener('input', () => {
              const headerRows = parseInt(tableHeaderRowsInput.value) || 1;
              const numRows = (p.body || []).length;
              if (headerRows >= 0 && headerRows <= numRows) {
                p.headerRows = headerRows;
              } else {
                p.headerRows = Math.max(0, Math.min(headerRows, numRows));
                tableHeaderRowsInput.value = p.headerRows;
              }
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (tableColsInput || tableRowsInput) {
            const updateTable = () => {
              const cols = parseInt(tableColsInput?.value || 3);
              const dataRows = parseInt(tableRowsInput?.value || 1); // Linhas de dados (sem contar header)
              const totalRows = dataRows + 1; // +1 para o header

              // Preservar estrutura existente se possível
              const currentBody = p.body || [];
              const currentCols = currentBody[0]?.length || cols;

              const newBody = Array(totalRows).fill(null).map((_, i) => {
                if (i === 0) {
                  // Primeira linha = header
                  const existingHeader = currentBody[0] || [];
                  return Array(cols).fill(null).map((_, j) => {
                    // Preservar células existentes se possível, senão criar nova estrutura
                    if (existingHeader[j] && typeof existingHeader[j] === 'object' && existingHeader[j].children) {
                      return existingHeader[j];
                    }
                    return { children: [] };
                  });
                } else {
                  // Linhas de dados
                  const existingRow = currentBody[i] || [];
                  return Array(cols).fill(null).map((_, j) => {
                    if (existingRow[j] && typeof existingRow[j] === 'object' && existingRow[j].children) {
                      return existingRow[j];
                    }
                    return { children: [] };
                  });
                }
              });

              p.body = newBody;

              // Atualizar larguras preservando as existentes quando possível
              if (!p.widths || p.widths.length !== cols) {
                const existingWidths = p.widths || [];
                p.widths = Array(cols).fill(null).map((_, i) => {
                  return existingWidths[i] || '*';
                });
              }

              if (typeof renderAll === 'function') {
                renderAll();
              } else if (typeof render === 'function') {
                render();
              }
            };
            if (tableColsInput) tableColsInput.addEventListener('input', updateTable);
            if (tableRowsInput) tableRowsInput.addEventListener('input', updateTable);
          }
          if (tableLayoutSelect) {
            tableLayoutSelect.addEventListener('change', () => {
              p.layout = tableLayoutSelect.value;

              // Mostrar/ocultar opções de layout customizado
              const customLayoutOptions = document.getElementById('tableCustomLayoutOptions');
              if (customLayoutOptions) {
                customLayoutOptions.style.display = (tableLayoutSelect.value === 'custom') ? 'block' : 'none';
              }

              // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              setTimeout(() => {
                if (typeof renderInspector === 'function') renderInspector();
              }, 0);
            });
          }

          // Listeners para layout customizado
          const hLineWidthInput = document.getElementById('insp-tableHLineWidth');
          const hLineColorInput = document.getElementById('insp-tableHLineColor');
          const hLineColorTextInput = document.getElementById('insp-tableHLineColorText');
          const vLineWidthInput = document.getElementById('insp-tableVLineWidth');
          const vLineColorInput = document.getElementById('insp-tableVLineColor');
          const vLineColorTextInput = document.getElementById('insp-tableVLineColorText');
          const paddingLeftInput = document.getElementById('insp-tablePaddingLeft');
          const paddingRightInput = document.getElementById('insp-tablePaddingRight');
          const paddingTopInput = document.getElementById('insp-tablePaddingTop');
          const paddingBottomInput = document.getElementById('insp-tablePaddingBottom');

          const updateCustomLayout = () => {
            if (!p.customLayout) p.customLayout = {};
            // IMPORTANTE: Não processar valores imediatamente para inputs number
            if (hLineWidthInput) {
              const rawValue = hLineWidthInput.value;
              if (rawValue !== '' && !isNaN(rawValue)) {
                p.customLayout.hLineWidth = parseFloat(rawValue) || 1;
              }
            }
            if (hLineColorTextInput && hLineColorTextInput.value) p.customLayout.hLineColor = hLineColorTextInput.value;
            if (vLineWidthInput) {
              const rawValue = vLineWidthInput.value;
              if (rawValue !== '' && !isNaN(rawValue)) {
                p.customLayout.vLineWidth = parseFloat(rawValue) || 1;
              }
            }
            if (vLineColorTextInput && vLineColorTextInput.value) p.customLayout.vLineColor = vLineColorTextInput.value;
            if (paddingLeftInput) {
              const rawValue = paddingLeftInput.value;
              if (rawValue !== '' && !isNaN(rawValue)) {
                p.customLayout.paddingLeft = parseInt(rawValue) || 5;
              }
            }
            if (paddingRightInput) {
              const rawValue = paddingRightInput.value;
              if (rawValue !== '' && !isNaN(rawValue)) {
                p.customLayout.paddingRight = parseInt(rawValue) || 5;
              }
            }
            if (paddingTopInput) {
              const rawValue = paddingTopInput.value;
              if (rawValue !== '' && !isNaN(rawValue)) {
                p.customLayout.paddingTop = parseInt(rawValue) || 5;
              }
            }
            if (paddingBottomInput) {
              const rawValue = paddingBottomInput.value;
              if (rawValue !== '' && !isNaN(rawValue)) {
                p.customLayout.paddingBottom = parseInt(rawValue) || 5;
              }
            }

            updateWithoutLosingFocus(() => {
              // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
            }, 300);
          };

          if (hLineWidthInput) hLineWidthInput.addEventListener('input', updateCustomLayout);
          if (hLineColorInput) {
            hLineColorInput.addEventListener('change', () => {
              if (hLineColorTextInput) hLineColorTextInput.value = hLineColorInput.value;
              updateCustomLayout();
            });
          }
          if (hLineColorTextInput) hLineColorTextInput.addEventListener('input', updateCustomLayout);

          if (vLineWidthInput) vLineWidthInput.addEventListener('input', updateCustomLayout);
          if (vLineColorInput) {
            vLineColorInput.addEventListener('change', () => {
              if (vLineColorTextInput) vLineColorTextInput.value = vLineColorInput.value;
              updateCustomLayout();
            });
          }
          if (vLineColorTextInput) vLineColorTextInput.addEventListener('input', updateCustomLayout);

          if (paddingLeftInput) paddingLeftInput.addEventListener('input', updateCustomLayout);
          if (paddingRightInput) paddingRightInput.addEventListener('input', updateCustomLayout);
          if (paddingTopInput) paddingTopInput.addEventListener('input', updateCustomLayout);
          if (paddingBottomInput) paddingBottomInput.addEventListener('input', updateCustomLayout);

          // Listeners para tabela zebrada
          const zebraEnabledCheck = document.getElementById('insp-tableZebraEnabled');
          const zebraColorInput = document.getElementById('insp-tableZebraColor');
          const zebraColorTextInput = document.getElementById('insp-tableZebraColorText');
          const zebraWithLinesCheck = document.getElementById('insp-tableZebraWithLines');

          if (zebraEnabledCheck) {
            zebraEnabledCheck.addEventListener('change', () => {
              p.zebraEnabled = zebraEnabledCheck.checked;
              // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              setTimeout(() => {
                if (typeof renderInspector === 'function') renderInspector();
              }, 0);
            });
          }

          if (zebraColorInput) {
            zebraColorInput.addEventListener('change', () => {
              if (zebraColorTextInput) zebraColorTextInput.value = zebraColorInput.value;
              p.zebraColor = zebraColorInput.value;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (zebraColorTextInput) {
            zebraColorTextInput.addEventListener('input', () => {
              if (zebraColorInput && zebraColorTextInput.value) zebraColorInput.value = zebraColorTextInput.value;
              p.zebraColor = zebraColorTextInput.value || '#CCCCCC';
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (zebraWithLinesCheck) {
            zebraWithLinesCheck.addEventListener('change', () => {
              p.zebraWithLines = zebraWithLinesCheck.checked;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          const tableDontBreakRowsCheck = document.getElementById('insp-tableDontBreakRows');
          const tableKeepWithHeaderRowsInput = document.getElementById('insp-tableKeepWithHeaderRows');

          if (tableDontBreakRowsCheck) {
            tableDontBreakRowsCheck.addEventListener('change', () => {
              p.dontBreakRows = tableDontBreakRowsCheck.checked;
              // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
            });
          }

          if (tableKeepWithHeaderRowsInput) {
            tableKeepWithHeaderRowsInput.addEventListener('input', () => {
              // IMPORTANTE: Não processar o valor imediatamente para inputs number
              const rawValue = tableKeepWithHeaderRowsInput.value;
              if (rawValue !== '' && !isNaN(rawValue)) {
                p.keepWithHeaderRows = parseInt(rawValue) || 0;
              }
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          // Listeners para estilos das células
          document.querySelectorAll('.table-cell-fill-color').forEach(input => {
            input.addEventListener('change', () => {
              const row = parseInt(input.dataset.row || 0);
              const col = parseInt(input.dataset.col || 0);
              const textInput = document.querySelector(`.table-cell-fill-color-text[data-row="${row}"][data-col="${col}"]`);
              if (textInput) textInput.value = input.value;

              if (!p.body[row] || !p.body[row][col]) return;
              p.body[row][col].fillColor = input.value || undefined;

              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          });

          document.querySelectorAll('.table-cell-fill-color-text').forEach(input => {
            input.addEventListener('input', () => {
              const row = parseInt(input.dataset.row || 0);
              const col = parseInt(input.dataset.col || 0);
              const colorInput = document.querySelector(`.table-cell-fill-color[data-row="${row}"][data-col="${col}"]`);
              if (colorInput && input.value) colorInput.value = input.value;

              if (!p.body[row] || !p.body[row][col]) return;
              p.body[row][col].fillColor = input.value || undefined;

              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          });

          document.querySelectorAll('.table-cell-color').forEach(input => {
            input.addEventListener('change', () => {
              const row = parseInt(input.dataset.row || 0);
              const col = parseInt(input.dataset.col || 0);
              const textInput = document.querySelector(`.table-cell-color-text[data-row="${row}"][data-col="${col}"]`);
              if (textInput) textInput.value = input.value;

              if (!p.body[row] || !p.body[row][col]) return;
              p.body[row][col].color = input.value || undefined;

              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          });

          document.querySelectorAll('.table-cell-color-text').forEach(input => {
            input.addEventListener('input', () => {
              const row = parseInt(input.dataset.row || 0);
              const col = parseInt(input.dataset.col || 0);
              const colorInput = document.querySelector(`.table-cell-color[data-row="${row}"][data-col="${col}"]`);
              if (colorInput && input.value) colorInput.value = input.value;

              if (!p.body[row] || !p.body[row][col]) return;
              p.body[row][col].color = input.value || undefined;

              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          });

          document.querySelectorAll('.table-cell-fill-opacity').forEach(input => {
            input.addEventListener('input', () => {
              const row = parseInt(input.dataset.row || 0);
              const col = parseInt(input.dataset.col || 0);

              if (!p.body[row] || !p.body[row][col]) return;
              // IMPORTANTE: Não processar o valor imediatamente para inputs number
              const rawValue = input.value;
              if (rawValue !== '' && !isNaN(rawValue)) {
                const opacity = parseFloat(rawValue);
                p.body[row][col].fillOpacity = isNaN(opacity) ? 1 : opacity;
              }

              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          });

          // Listeners para rowSpan e colSpan
          document.querySelectorAll('.table-cell-rowspan').forEach(input => {
            input.addEventListener('input', () => {
              const row = parseInt(input.dataset.row || 0);
              const col = parseInt(input.dataset.col || 0);

              if (!p.body[row] || !p.body[row][col]) return;
              // IMPORTANTE: Não processar o valor imediatamente para inputs number
              const rawValue = input.value;
              if (rawValue !== '' && !isNaN(rawValue)) {
                const rowSpan = parseInt(rawValue) || 1;
                p.body[row][col].rowSpan = rowSpan > 1 ? rowSpan : undefined;
              }

              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          });

          document.querySelectorAll('.table-cell-colspan').forEach(input => {
            input.addEventListener('input', () => {
              const row = parseInt(input.dataset.row || 0);
              const col = parseInt(input.dataset.col || 0);

              if (!p.body[row] || !p.body[row][col]) return;
              // IMPORTANTE: Não processar o valor imediatamente para inputs number
              const rawValue = input.value;
              if (rawValue !== '' && !isNaN(rawValue)) {
                const colSpan = parseInt(rawValue) || 1;
                p.body[row][col].colSpan = colSpan > 1 ? colSpan : undefined;
              }

              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          });

          // Listeners para border (checkboxes)
          document.querySelectorAll('.table-cell-border').forEach(checkbox => {
            checkbox.addEventListener('change', () => {
              const row = parseInt(checkbox.dataset.row || 0);
              const col = parseInt(checkbox.dataset.col || 0);
              const side = parseInt(checkbox.dataset.side || 0);

              if (!p.body[row] || !p.body[row][col]) return;

              if (!p.body[row][col].border) {
                p.body[row][col].border = [true, true, true, true];
              }

              p.body[row][col].border[side] = checkbox.checked;

              // Se todas as bordas forem true, pode remover a propriedade (usa padrão)
              if (p.body[row][col].border.every(b => b === true)) {
                p.body[row][col].border = undefined;
              }

              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          });

          // Listeners para borderColor
          document.querySelectorAll('.table-cell-border-color').forEach(input => {
            input.addEventListener('change', () => {
              const row = parseInt(input.dataset.row || 0);
              const col = parseInt(input.dataset.col || 0);
              const side = parseInt(input.dataset.side || 0);

              if (!p.body[row] || !p.body[row][col]) return;

              if (!p.body[row][col].borderColor) {
                p.body[row][col].borderColor = ['', '', '', ''];
              }

              p.body[row][col].borderColor[side] = input.value || '';

              // Se todas as cores forem vazias, pode remover a propriedade
              if (p.body[row][col].borderColor.every(c => !c)) {
                p.body[row][col].borderColor = undefined;
              }

              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          });

          // Listeners para heights
          const heightsTypeSelect = document.getElementById('insp-tableHeightsType');
          const heightsFixedInput = document.getElementById('insp-tableHeightsFixed');

          if (heightsTypeSelect) {
            heightsTypeSelect.addEventListener('change', () => {
              const type = heightsTypeSelect.value;
              const fixedContainer = document.getElementById('table-heights-fixed');

              if (type === 'none') {
                p.heights = undefined;
                if (fixedContainer) fixedContainer.style.display = 'none';
              } else if (type === 'fixed') {
                const fixedValue = heightsFixedInput ? parseFloat(heightsFixedInput.value) || 40 : 40;
                p.heights = fixedValue;
                if (fixedContainer) fixedContainer.style.display = '';
              } else if (type === 'array') {
                const numRows = p.body?.length || 2;
                p.heights = Array(numRows).fill(40);
                if (fixedContainer) fixedContainer.style.display = 'none';
                // Re-renderizar para mostrar os inputs de array
                if (typeof renderInspector === 'function') renderInspector();
                return;
              }

              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (heightsFixedInput) {
            heightsFixedInput.addEventListener('input', () => {
              const value = parseFloat(heightsFixedInput.value) || 40;
              p.heights = value;

              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          // Listeners para alturas por linha (array)
          document.querySelectorAll('.table-row-height').forEach(input => {
            input.addEventListener('input', () => {
              const row = parseInt(input.dataset.row || 0);
              const value = parseFloat(input.value) || 40;

              if (!p.heights || !Array.isArray(p.heights)) {
                const numRows = p.body?.length || 2;
                p.heights = Array(numRows).fill(40);
              }

              p.heights[row] = value;

              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          });

          // Listeners para hLineStyle e vLineStyle
          const hLineStyleCheck = document.getElementById('insp-tableHLineStyle');
          const vLineStyleCheck = document.getElementById('insp-tableVLineStyle');
          const defaultBorderCheck = document.getElementById('insp-tableDefaultBorder');

          if (hLineStyleCheck) {
            hLineStyleCheck.addEventListener('change', () => {
              if (!p.customLayout) p.customLayout = {};
              if (hLineStyleCheck.checked) {
                p.customLayout.hLineStyle = true; // Será convertido para função na geração
              } else {
                p.customLayout.hLineStyle = undefined;
              }

              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (vLineStyleCheck) {
            vLineStyleCheck.addEventListener('change', () => {
              if (!p.customLayout) p.customLayout = {};
              if (vLineStyleCheck.checked) {
                p.customLayout.vLineStyle = true; // Será convertido para função na geração
              } else {
                p.customLayout.vLineStyle = undefined;
              }

              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (defaultBorderCheck) {
            defaultBorderCheck.addEventListener('change', () => {
              if (!p.customLayout) p.customLayout = {};
              p.customLayout.defaultBorder = defaultBorderCheck.checked;

              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          // Listeners para larguras das colunas da tabela
          document.querySelectorAll('.table-col-width-type').forEach(select => {
            select.addEventListener('change', () => {
              const colIndex = parseInt(select.dataset.colIndex || 0);
              const widthType = select.value;
              const valueInput = document.querySelector(`.table-col-width-value[data-col-index="${colIndex}"]`);
              const valueContainer = document.getElementById(`table-col-width-value-${colIndex}`);

              if (!p.widths) {
                const body = p.body || [];
                const numCols = body[0]?.length || 3;
                p.widths = Array(numCols).fill('*');
              }

              if (widthType === 'auto') {
                p.widths[colIndex] = '*';
                if (valueContainer) valueContainer.style.display = 'none';
              } else {
                if (valueContainer) valueContainer.style.display = '';
                const currentValue = valueInput ? parseFloat(valueInput.value) || 0 : 0;
                if (widthType === 'pixels') {
                  p.widths[colIndex] = currentValue || 100;
                } else if (widthType === 'percentage') {
                  p.widths[colIndex] = currentValue ? `${currentValue}%` : '50%';
                }
              }

              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          });

          document.querySelectorAll('.table-col-width-value').forEach(input => {
            input.addEventListener('input', () => {
              const colIndex = parseInt(input.dataset.colIndex || 0);
              const typeSelect = document.querySelector(`.table-col-width-type[data-col-index="${colIndex}"]`);
              const widthType = typeSelect ? typeSelect.value : 'auto';
              const value = parseFloat(input.value) || 0;

              if (!p.widths) {
                const body = p.body || [];
                const numCols = body[0]?.length || 3;
                p.widths = Array(numCols).fill('*');
              }

              if (widthType === 'pixels') {
                p.widths[colIndex] = value || 100;
              } else if (widthType === 'percentage') {
                p.widths[colIndex] = value ? `${value}%` : '50%';
              }

              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          });

          // Listener para deletar coluna da tabela
          document.querySelectorAll('.btn-delete-table-col').forEach(btn => {
            btn.addEventListener('click', () => {
              const colIndex = parseInt(btn.dataset.colIndex || 0);
              const body = p.body || [];
              const numCols = body[0]?.length || 0;

              if (colIndex > 0 && numCols > 1) {
                if (typeof showConfirmModal === 'function') {
                  showConfirmModal(
                    'Deletar Coluna',
                    `Tem certeza que deseja deletar a Coluna ${colIndex + 1}?`,
                    () => {
                      // Remover coluna de todas as linhas
                      body.forEach(row => {
                        if (row && Array.isArray(row) && row[colIndex]) {
                          row.splice(colIndex, 1);
                        }
                      });

                      // Remover largura correspondente
                      if (p.widths && p.widths[colIndex]) {
                        p.widths.splice(colIndex, 1);
                      }

                      // Atualizar número de colunas
                      if (tableColsInput) {
                        tableColsInput.value = numCols - 1;
                      }

                      if (typeof renderAll === 'function') {
                        renderAll();
                      } else if (typeof render === 'function') {
                        render();
                      }
                      setTimeout(() => {
                        if (typeof renderInspector === 'function') renderInspector();
                      }, 0);
                    }
                  );
                }
              }
            });
          });
          break;

        case 'image':
          const imageUrlInput = document.getElementById('insp-imageUrl');
          const imageSizeModeSelect = document.getElementById('insp-imageSizeMode');
          const imageWidthInput = document.getElementById('insp-imageWidth');
          const imageHeightInput = document.getElementById('insp-imageHeight');
          const imageFitWidthInput = document.getElementById('insp-imageFitWidth');
          const imageFitHeightInput = document.getElementById('insp-imageFitHeight');
          const imageCoverWidthInput = document.getElementById('insp-imageCoverWidth');
          const imageCoverHeightInput = document.getElementById('insp-imageCoverHeight');
          const imageCoverAlignSelect = document.getElementById('insp-imageCoverAlign');
          const imageCoverValignSelect = document.getElementById('insp-imageCoverValign');
          const imageBorderRadiusInput = document.getElementById('insp-imageBorderRadius');
          const imageOpacityInput = document.getElementById('insp-imageOpacity');
          const imageAlignmentSelect = document.getElementById('insp-imageAlignment');
          const imagePositionTypeSelect = document.getElementById('insp-imagePositionType');
          const imageAbsoluteXInput = document.getElementById('insp-imageAbsoluteX');
          const imageAbsoluteYInput = document.getElementById('insp-imageAbsoluteY');
          const imageRelativeXInput = document.getElementById('insp-imageRelativeX');
          const imageRelativeYInput = document.getElementById('insp-imageRelativeY');

          // Modo de dimensionamento
          if (imageSizeModeSelect) {
            imageSizeModeSelect.addEventListener('change', () => {
              const mode = imageSizeModeSelect.value;
              // Limpar propriedades não usadas
              if (mode === 'widthHeight') {
                delete p.fit;
                delete p.cover;
              } else if (mode === 'fit') {
                delete p.width;
                delete p.height;
                delete p.cover;
                if (!p.fit) p.fit = [100, 100];
              } else if (mode === 'cover') {
                delete p.width;
                delete p.height;
                delete p.fit;
                if (!p.cover) p.cover = { width: 300, height: 150, align: 'center', valign: 'center' };
              }
              // Atualizar UI
              setTimeout(() => {
                if (typeof renderInspector === 'function') renderInspector();
              }, 0);
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (imageUrlInput) {
            const imageUrlError = document.getElementById('insp-imageUrlError');

            // Função de validação de URL
            const validateImageUrl = (url) => {
              if (!url) {
                if (imageUrlError) {
                  imageUrlError.style.display = 'none';
                }
                return true;
              }

              // Verificar se é URL válida ou data URI
              const isValidUrl = url.startsWith('http://') || url.startsWith('https://') || url.startsWith('data:image/');
              const isValidFormat = /\.(jpg|jpeg|png|gif|webp|svg)(\?.*)?$/i.test(url) || url.startsWith('data:image/');

              if (!isValidUrl && !url.startsWith('data:image/')) {
                if (imageUrlError) {
                  imageUrlError.textContent = '⚠️ URL inválida. Use http://, https:// ou data:image/';
                  imageUrlError.style.display = 'block';
                }
                return false;
              }

              if (imageUrlError) {
                imageUrlError.style.display = 'none';
              }
              return true;
            };

            imageUrlInput.addEventListener('input', async () => {
              const url = imageUrlInput.value.trim();

              // Validar URL
              if (!validateImageUrl(url)) {
                return;
              }

              p.url = url;

              // Converter URL para base64 apenas para preview visual
              if (url && (url.startsWith('http://') || url.startsWith('https://') || url.startsWith('data:'))) {
                try {
                  const base64 = await convertImageUrlToBase64(url);
                  if (base64) {
                    p._base64Preview = base64; // Armazenar base64 apenas para preview
                  } else {
                    delete p._base64Preview;
                  }
                } catch (e) {
                  console.warn('Erro ao converter imagem para base64:', e);
                  delete p._base64Preview;
                }
              } else {
                delete p._base64Preview;
              }

              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          // Width e Height
          if (imageWidthInput) {
            imageWidthInput.addEventListener('input', () => {
              const val = imageWidthInput.value.trim();
              p.width = val ? parseInt(val) : undefined;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (imageHeightInput) {
            imageHeightInput.addEventListener('input', () => {
              const val = imageHeightInput.value.trim();
              p.height = val ? parseInt(val) : undefined;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          // Fit
          if (imageFitWidthInput) {
            imageFitWidthInput.addEventListener('input', () => {
              if (!Array.isArray(p.fit)) p.fit = [100, 100];
              p.fit[0] = parseInt(imageFitWidthInput.value) || 100;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (imageFitHeightInput) {
            imageFitHeightInput.addEventListener('input', () => {
              if (!Array.isArray(p.fit)) p.fit = [100, 100];
              p.fit[1] = parseInt(imageFitHeightInput.value) || 100;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          // Cover
          if (imageCoverWidthInput) {
            imageCoverWidthInput.addEventListener('input', () => {
              if (!p.cover) p.cover = { width: 300, height: 150, align: 'center', valign: 'center' };
              p.cover.width = parseInt(imageCoverWidthInput.value) || 300;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (imageCoverHeightInput) {
            imageCoverHeightInput.addEventListener('input', () => {
              if (!p.cover) p.cover = { width: 300, height: 150, align: 'center', valign: 'center' };
              p.cover.height = parseInt(imageCoverHeightInput.value) || 150;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (imageCoverAlignSelect) {
            imageCoverAlignSelect.addEventListener('change', () => {
              if (!p.cover) p.cover = { width: 300, height: 150, align: 'center', valign: 'center' };
              p.cover.align = imageCoverAlignSelect.value;
              // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
            });
          }
          if (imageCoverValignSelect) {
            imageCoverValignSelect.addEventListener('change', () => {
              if (!p.cover) p.cover = { width: 300, height: 150, align: 'center', valign: 'center' };
              p.cover.valign = imageCoverValignSelect.value;
              // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
            });
          }

          if (imageBorderRadiusInput) {
            imageBorderRadiusInput.addEventListener('input', () => {
              p.borderRadius = parseInt(imageBorderRadiusInput.value) || 0;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (imageOpacityInput) {
            imageOpacityInput.addEventListener('input', () => {
              const val = imageOpacityInput.value.trim();
              p.opacity = val ? parseFloat(val) : undefined;
              if (p.opacity !== undefined) {
                p.opacity = Math.max(0, Math.min(1, p.opacity)); // Clamp entre 0 e 1
              }
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (imageAlignmentSelect) {
            imageAlignmentSelect.addEventListener('change', () => {
              p.alignment = imageAlignmentSelect.value;
              // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
            });
          }

          // Tipo de posicionamento
          if (imagePositionTypeSelect) {
            imagePositionTypeSelect.addEventListener('change', () => {
              const posType = imagePositionTypeSelect.value;
              if (posType === 'none') {
                delete p.absolutePosition;
                delete p.relativePosition;
              } else if (posType === 'absolute') {
                delete p.relativePosition;
                if (!p.absolutePosition) p.absolutePosition = { x: 0, y: 0 };
              } else if (posType === 'relative') {
                delete p.absolutePosition;
                if (!p.relativePosition) p.relativePosition = { x: 0, y: 0 };
              }
              // Atualizar UI
              setTimeout(() => {
                if (typeof renderInspector === 'function') renderInspector();
              }, 0);
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          // Posição absoluta
          if (imageAbsoluteXInput) {
            imageAbsoluteXInput.addEventListener('input', () => {
              if (!p.absolutePosition) p.absolutePosition = { x: 0, y: 0 };
              p.absolutePosition.x = parseInt(imageAbsoluteXInput.value) || 0;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (imageAbsoluteYInput) {
            imageAbsoluteYInput.addEventListener('input', () => {
              if (!p.absolutePosition) p.absolutePosition = { x: 0, y: 0 };
              p.absolutePosition.y = parseInt(imageAbsoluteYInput.value) || 0;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          // Posição relativa
          if (imageRelativeXInput) {
            imageRelativeXInput.addEventListener('input', () => {
              if (!p.relativePosition) p.relativePosition = { x: 0, y: 0 };
              p.relativePosition.x = parseInt(imageRelativeXInput.value) || 0;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (imageRelativeYInput) {
            imageRelativeYInput.addEventListener('input', () => {
              if (!p.relativePosition) p.relativePosition = { x: 0, y: 0 };
              p.relativePosition.y = parseInt(imageRelativeYInput.value) || 0;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          break;

        case 'margin':
          const marginLeftInput = document.getElementById('insp-marginLeft');
          const marginTopInput = document.getElementById('insp-marginTop');
          const marginRightInput = document.getElementById('insp-marginRight');
          const marginBottomInput = document.getElementById('insp-marginBottom');

          const updateMargin = () => {
            const left = parseInt(marginLeftInput?.value || 0) || 0;
            const top = parseInt(marginTopInput?.value || 0) || 0;
            const right = parseInt(marginRightInput?.value || 0) || 0;
            const bottom = parseInt(marginBottomInput?.value || 0) || 0;
            p.margin = [left, top, right, bottom];
            // Manter compatibilidade com o formato antigo (size)
            if (top > 0 && left === 0 && right === 0 && bottom === 0) {
              p.size = top;
            }
            updateWithoutLosingFocus(() => {
              // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
            }, 300);
          };

          if (marginLeftInput) marginLeftInput.addEventListener('input', updateMargin);
          if (marginTopInput) marginTopInput.addEventListener('input', updateMargin);
          if (marginRightInput) marginRightInput.addEventListener('input', updateMargin);
          if (marginBottomInput) marginBottomInput.addEventListener('input', updateMargin);
          break;

        case 'group':
          const groupOrientationSelect = document.getElementById('insp-groupOrientation');
          const groupAlignmentSelect = document.getElementById('insp-groupAlignment');
          const groupGapInput = document.getElementById('insp-groupGap');

          if (groupOrientationSelect) {
            groupOrientationSelect.addEventListener('change', () => {
              p.orientation = groupOrientationSelect.value;
              // Recalcular larguras quando orientação muda
              if (typeof updateGroupChildrenWidths === 'function') {
                updateGroupChildrenWidths(element);
              }
              if (typeof updateGroupDimensions === 'function') {
                updateGroupDimensions(element);
              }
              if (typeof renderAll === 'function') {
                renderAll();
              } else if (typeof render === 'function') {
                render();
              }
            });
          }
          if (groupAlignmentSelect) groupAlignmentSelect.addEventListener('change', () => {
            p.alignment = groupAlignmentSelect.value;
            // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
            if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
          });
          if (groupGapInput) {
            groupGapInput.addEventListener('input', () => {
              p.gap = parseInt(groupGapInput.value) || 10;
              if (typeof updateGroupDimensions === 'function') updateGroupDimensions(element);
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          // Padding sempre 0 (removido conforme solicitado)
          p.padding = 0;
          break;

        case 'qr':
          const qrTextInput = document.getElementById('insp-qrText');
          const qrFitInput = document.getElementById('insp-qrFit');
          const qrEccLevelSelect = document.getElementById('insp-qrEccLevel');
          const qrForegroundInput = document.getElementById('insp-qrForeground');
          const qrForegroundTextInput = document.getElementById('insp-qrForegroundText');
          const qrBackgroundInput = document.getElementById('insp-qrBackground');
          const qrBackgroundTextInput = document.getElementById('insp-qrBackgroundText');
          const qrAlignmentSelect = document.getElementById('insp-qrAlignment');

          if (qrTextInput) {
            qrTextInput.addEventListener('input', () => {
              p.text = qrTextInput.value;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (qrFitInput) {
            qrFitInput.addEventListener('input', () => {
              p.fit = parseInt(qrFitInput.value) || 100;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (qrEccLevelSelect) {
            qrEccLevelSelect.addEventListener('change', () => {
              p.eccLevel = qrEccLevelSelect.value;
              // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
            });
          }
          if (qrForegroundInput && qrForegroundTextInput) {
            qrForegroundInput.addEventListener('input', () => {
              qrForegroundTextInput.value = qrForegroundInput.value;
              p.foreground = qrForegroundInput.value;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
            qrForegroundTextInput.addEventListener('input', () => {
              if (/^#[0-9A-F]{6}$/i.test(qrForegroundTextInput.value)) {
                qrForegroundInput.value = qrForegroundTextInput.value;
                p.foreground = qrForegroundTextInput.value;
                updateWithoutLosingFocus(() => {
                  // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                  if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
                }, 300);
              }
            });
          }
          if (qrBackgroundInput && qrBackgroundTextInput) {
            qrBackgroundInput.addEventListener('input', () => {
              qrBackgroundTextInput.value = qrBackgroundInput.value;
              p.background = qrBackgroundInput.value;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
            qrBackgroundTextInput.addEventListener('input', () => {
              if (/^#[0-9A-F]{6}$/i.test(qrBackgroundTextInput.value)) {
                qrBackgroundInput.value = qrBackgroundTextInput.value;
                p.background = qrBackgroundTextInput.value;
                updateWithoutLosingFocus(() => {
                  // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                  if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
                }, 300);
              }
            });
          }
          if (qrAlignmentSelect) {
            qrAlignmentSelect.addEventListener('change', () => {
              p.alignment = qrAlignmentSelect.value;
              // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
            });
          }
          break;

        case 'svg':
          const svgCodeInput = document.getElementById('insp-svgCode');
          const svgWidthInput = document.getElementById('insp-svgWidth');
          const svgHeightInput = document.getElementById('insp-svgHeight');
          const svgColorInput = document.getElementById('insp-svgColor');
          const svgColorTextInput = document.getElementById('insp-svgColorText');
          const svgAlignmentSelect = document.getElementById('insp-svgAlignment');

          if (svgCodeInput) {
            svgCodeInput.addEventListener('input', () => {
              p.svg = svgCodeInput.value;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (svgWidthInput) {
            svgWidthInput.addEventListener('input', () => {
              p.width = parseInt(svgWidthInput.value) || 100;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (svgHeightInput) {
            svgHeightInput.addEventListener('input', () => {
              p.height = parseInt(svgHeightInput.value) || 100;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (svgColorInput && svgColorTextInput) {
            svgColorInput.addEventListener('input', () => {
              svgColorTextInput.value = svgColorInput.value;
              p.color = svgColorInput.value;
              updateWithoutLosingFocus(() => {
                // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
            svgColorTextInput.addEventListener('input', () => {
              if (/^#[0-9A-F]{6}$/i.test(svgColorTextInput.value)) {
                svgColorInput.value = svgColorTextInput.value;
                p.color = svgColorTextInput.value;
                updateWithoutLosingFocus(() => {
                  // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
                  if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
                }, 300);
              }
            });
          }
          if (svgAlignmentSelect) {
            svgAlignmentSelect.addEventListener('change', () => {
              p.alignment = svgAlignmentSelect.value;
              // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
            });
          }
          break;

        case 'barcode':
          const barcodeValueInput = document.getElementById('insp-barcodeValue');
          const barcodeFormatSelect = document.getElementById('insp-barcodeFormat');
          const barcodeLineWidthInput = document.getElementById('insp-barcodeLineWidth');
          const barcodeHeightInput = document.getElementById('insp-barcodeHeight');
          const barcodeDisplayValueCheck = document.getElementById('insp-barcodeDisplayValue');
          const barcodeFontSizeInput = document.getElementById('insp-barcodeFontSize');
          const barcodeMarginInput = document.getElementById('insp-barcodeMargin');
          const barcodeFitWInput = document.getElementById('insp-barcodeFitW');
          const barcodeFitHInput = document.getElementById('insp-barcodeFitH');
          const barcodeAlignmentSelect = document.getElementById('insp-barcodeAlignment');

          if (barcodeValueInput) {
            barcodeValueInput.addEventListener('input', () => {
              p.barcodeValue = barcodeValueInput.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (barcodeFormatSelect) {
            barcodeFormatSelect.addEventListener('change', () => {
              p.format = barcodeFormatSelect.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (barcodeLineWidthInput) {
            barcodeLineWidthInput.addEventListener('input', () => {
              const rawValue = barcodeLineWidthInput.value;
              if (rawValue !== '' && !isNaN(rawValue)) {
                p.lineWidth = parseFloat(rawValue) || 1.5;
              }
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (barcodeHeightInput) {
            barcodeHeightInput.addEventListener('input', () => {
              const rawValue = barcodeHeightInput.value;
              if (rawValue !== '' && !isNaN(rawValue)) {
                p.barHeight = parseInt(rawValue) || 30;
              }
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (barcodeDisplayValueCheck) {
            barcodeDisplayValueCheck.addEventListener('change', () => {
              p.displayValue = barcodeDisplayValueCheck.checked;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (barcodeFontSizeInput) {
            barcodeFontSizeInput.addEventListener('input', () => {
              const rawValue = barcodeFontSizeInput.value;
              if (rawValue !== '' && !isNaN(rawValue)) {
                p.fontSize = parseInt(rawValue) || 10;
              }
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (barcodeMarginInput) {
            barcodeMarginInput.addEventListener('input', () => {
              const rawValue = barcodeMarginInput.value;
              if (rawValue !== '' && !isNaN(rawValue)) {
                p.margin = parseInt(rawValue) || 0;
              }
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (barcodeFitWInput) {
            barcodeFitWInput.addEventListener('input', () => {
              const rawValue = barcodeFitWInput.value;
              if (rawValue !== '' && !isNaN(rawValue)) {
                if (!p.fit) p.fit = [201, 42];
                p.fit[0] = parseInt(rawValue) || 201;
              }
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (barcodeFitHInput) {
            barcodeFitHInput.addEventListener('input', () => {
              const rawValue = barcodeFitHInput.value;
              if (rawValue !== '' && !isNaN(rawValue)) {
                if (!p.fit) p.fit = [201, 42];
                p.fit[1] = parseInt(rawValue) || 42;
              }
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          if (barcodeAlignmentSelect) {
            barcodeAlignmentSelect.addEventListener('change', () => {
              p.alignment = barcodeAlignmentSelect.value;
              if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
            });
          }
          break;

        case 'stamp':
          const stampSourceTypeSelect = document.getElementById('insp-stampSourceType');
          const stampValueInput = document.getElementById('insp-stampValue');
          const stampValueField = document.getElementById('insp-stampValueField');
          const stampValueLabel = document.getElementById('insp-stampValueLabel');
          const stampFitWInput = document.getElementById('insp-stampFitW');
          const stampFitHInput = document.getElementById('insp-stampFitH');
          const stampAlignmentSelect = document.getElementById('insp-stampAlignment');
          const stampOpacityInput = document.getElementById('insp-stampOpacity');

          if (stampSourceTypeSelect) {
            stampSourceTypeSelect.addEventListener('change', () => {
              p.sourceType = stampSourceTypeSelect.value;
              // Atualizar campo de valor baseado no tipo
              if (stampValueField && stampValueLabel) {
                if (p.sourceType === 'svg') {
                  stampValueLabel.textContent = 'Código SVG';
                  stampValueField.innerHTML = `<textarea id="insp-stampValue" rows="6" placeholder="<svg>...</svg>">${escapeHtml(p.value || '')}</textarea>`;
                } else {
                  stampValueLabel.textContent = 'URL ou DataURL';
                  stampValueField.innerHTML = `<input type="text" id="insp-stampValue" value="${escapeHtml(p.value || '')}" placeholder="https://exemplo.com/imagem.png ou data:image/...">`;
                }
                // Re-attach listener
                const newInput = document.getElementById('insp-stampValue');
                if (newInput) {
                  newInput.addEventListener('input', () => {
                    p.value = newInput.value;
                    updateWithoutLosingFocus(() => {
                      if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
                    }, 300);
                  });
                }
              }
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (stampValueInput) {
            stampValueInput.addEventListener('input', () => {
              p.value = stampValueInput.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (stampFitWInput) {
            stampFitWInput.addEventListener('input', () => {
              if (!Array.isArray(p.fit)) p.fit = [120, 120];
              p.fit[0] = parseInt(stampFitWInput.value) || 120;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (stampFitHInput) {
            stampFitHInput.addEventListener('input', () => {
              if (!Array.isArray(p.fit)) p.fit = [120, 120];
              p.fit[1] = parseInt(stampFitHInput.value) || 120;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (stampAlignmentSelect) {
            stampAlignmentSelect.addEventListener('change', () => {
              p.alignment = stampAlignmentSelect.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (stampOpacityInput) {
            stampOpacityInput.addEventListener('input', () => {
              p.opacity = parseFloat(stampOpacityInput.value) || 1;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          break;

        case 'checkbox':
        case 'radio':
          const choiceTextInput = document.getElementById('insp-choiceText');
          const choiceChecked = document.getElementById('insp-choiceChecked');
          const choiceIconPositionSelect = document.getElementById('insp-choiceIconPosition');
          const choiceIconSizeInput = document.getElementById('insp-choiceIconSize');
          const choiceGapInput = document.getElementById('insp-choiceGap');
          const choiceAlignmentSelect = document.getElementById('insp-choiceAlignment');

          // Garantir que choiceType está definido
          if (!p.choiceType) {
            p.choiceType = element.type;
          }

          if (choiceTextInput) {
            choiceTextInput.addEventListener('input', () => {
              p.choiceText = choiceTextInput.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (choiceChecked) {
            choiceChecked.addEventListener('change', () => {
              p.choiceChecked = choiceChecked.checked;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (choiceIconPositionSelect) {
            choiceIconPositionSelect.addEventListener('change', () => {
              p.choiceIconPosition = choiceIconPositionSelect.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (choiceIconSizeInput) {
            choiceIconSizeInput.addEventListener('input', () => {
              p.choiceIconSize = parseInt(choiceIconSizeInput.value) || 12;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (choiceGapInput) {
            choiceGapInput.addEventListener('input', () => {
              p.choiceGap = parseInt(choiceGapInput.value) || 8;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (choiceAlignmentSelect) {
            choiceAlignmentSelect.addEventListener('change', () => {
              p.alignment = choiceAlignmentSelect.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          break;

        case 'fillLine':
          const fillLineWidthInput = document.getElementById('insp-fillLineWidth');
          const fillLineThicknessInput = document.getElementById('insp-fillLineThickness');
          const fillLineColorInput = document.getElementById('insp-fillLineColor');
          const fillLineAlignmentSelect = document.getElementById('insp-fillLineAlignment');

          if (fillLineWidthInput) {
            fillLineWidthInput.addEventListener('input', () => {
              p.lineWidth = parseInt(fillLineWidthInput.value) || 200;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (fillLineThicknessInput) {
            fillLineThicknessInput.addEventListener('input', () => {
              p.thickness = parseFloat(fillLineThicknessInput.value) || 0.8;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (fillLineColorInput) {
            fillLineColorInput.addEventListener('input', () => {
              p.color = fillLineColorInput.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (fillLineAlignmentSelect) {
            fillLineAlignmentSelect.addEventListener('change', () => {
              p.alignment = fillLineAlignmentSelect.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          break;

        case 'chart':
          const chartTypeSelect = document.getElementById('insp-chartType');
          const chartWidthInput = document.getElementById('insp-chartWidth');
          const chartHeightInput = document.getElementById('insp-chartHeight');
          const chartFitWInput = document.getElementById('insp-chartFitW');
          const chartFitHInput = document.getElementById('insp-chartFitH');
          const chartBackgroundColorInput = document.getElementById('insp-chartBackgroundColor');
          const chartDevicePixelRatioInput = document.getElementById('insp-chartDevicePixelRatio');
          const chartDataInput = document.getElementById('insp-chartData');
          const chartOptionsInput = document.getElementById('insp-chartOptions');
          const chartAlignmentSelect = document.getElementById('insp-chartAlignment');

          if (chartTypeSelect) {
            chartTypeSelect.addEventListener('change', () => {
              p.chartType = chartTypeSelect.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (chartWidthInput) {
            chartWidthInput.addEventListener('input', () => {
              p.chartWidth = parseInt(chartWidthInput.value) || 400;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (chartHeightInput) {
            chartHeightInput.addEventListener('input', () => {
              p.chartHeight = parseInt(chartHeightInput.value) || 200;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (chartFitWInput) {
            chartFitWInput.addEventListener('input', () => {
              if (!Array.isArray(p.chartFit)) p.chartFit = [400, 200];
              p.chartFit[0] = parseInt(chartFitWInput.value) || 400;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (chartFitHInput) {
            chartFitHInput.addEventListener('input', () => {
              if (!Array.isArray(p.chartFit)) p.chartFit = [400, 200];
              p.chartFit[1] = parseInt(chartFitHInput.value) || 200;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (chartBackgroundColorInput) {
            chartBackgroundColorInput.addEventListener('input', () => {
              p.chartBackgroundColor = chartBackgroundColorInput.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (chartDevicePixelRatioInput) {
            chartDevicePixelRatioInput.addEventListener('input', () => {
              p.chartDevicePixelRatio = parseInt(chartDevicePixelRatioInput.value) || 2;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }

          if (chartDataInput) {
            chartDataInput.addEventListener('input', () => {
              try {
                const parsed = JSON.parse(chartDataInput.value);
                p.chartData = parsed;
              } catch (e) {
                // Ignorar JSON inválido temporariamente
              }
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 500);
            });
          }

          if (chartOptionsInput) {
            chartOptionsInput.addEventListener('input', () => {
              try {
                const parsed = JSON.parse(chartOptionsInput.value);
                // Garantir que animation.duration seja 0
                if (!parsed.animation) parsed.animation = {};
                parsed.animation.duration = 0;
                parsed.responsive = false;
                p.chartOptions = parsed;
              } catch (e) {
                // Ignorar JSON inválido temporariamente
              }
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 500);
            });
          }

          if (chartAlignmentSelect) {
            chartAlignmentSelect.addEventListener('change', () => {
              p.alignment = chartAlignmentSelect.value;
              updateWithoutLosingFocus(() => {
                if (typeof renderAll === 'function') renderAll(false); else if (typeof render === 'function') render();
              }, 300);
            });
          }
          break;
      }
    }

    // -----------------------
    // PDFMake Builder (nested)
    // -----------------------
    function elementToPdfmake(el, context = {}) {
      const p = el.properties || {};
      const { inHeader = false, inFooter = false, inTableCell = false } = context;

      // helper for common props
      const common = {};
      if (Array.isArray(p.margin)) common.margin = p.margin;
      if (p.alignment) common.alignment = p.alignment;
      if (p.style) common.style = p.style;

      if (el.type === 'header') {
        const headerObj = {
          ...common,
          text: p.text || '',
          fontSize: Number(p.fontSize || 18),
          bold: !!p.bold
        };

        // ID do elemento (para linkToDestination)
        if (p.id && p.id.trim()) {
          headerObj.id = p.id.trim();
        }

        // Styling completo
        if (p.color) headerObj.color = p.color;
        if (p.background) headerObj.background = p.background;
        if (p.font) headerObj.font = p.font;
        if (p.decoration) headerObj.decoration = p.decoration;
        if (p.alignment) headerObj.alignment = p.alignment;
        if (p.italics) headerObj.italics = true;
        if (p.lineHeight !== undefined) headerObj.lineHeight = p.lineHeight;
        if (p.characterSpacing !== undefined) headerObj.characterSpacing = p.characterSpacing;
        if (p.decorationStyle) headerObj.decorationStyle = p.decorationStyle;
        if (p.decorationColor) headerObj.decorationColor = p.decorationColor;
        if (p.fontFeatures && Array.isArray(p.fontFeatures) && p.fontFeatures.length > 0) headerObj.fontFeatures = p.fontFeatures;

        // Link
        if (p.link && p.link.trim()) {
          headerObj.link = p.link.trim();
        } else if (p.linkToPage) {
          headerObj.linkToPage = p.linkToPage;
        } else if (p.linkToDestination) {
          headerObj.linkToDestination = p.linkToDestination;
        }

        return headerObj;
      }

      if (el.type === 'text') {
        let textValue = p.text || '';

        // Se o texto estiver dentro de header/footer e contiver placeholders, substituir automaticamente
        // Usar contexto passado ou verificar diretamente
        const isInHeaderFooter = inHeader || inFooter || isElementInHeader(el.id) || isElementInFooter(el.id);

        if (isInHeaderFooter && textValue.includes('{{')) {
          // Substituir placeholders por template literals que serão avaliados na função header/footer
          // O PDFMake espera que isso seja uma string com ${currentPage} e ${pageCount}
          textValue = textValue
            .replace(/\{\{pageNumber\}\}/g, '${currentPage}')
            .replace(/\{\{totalPages\}\}/g, '${pageCount}');
        }

        const textObj = {
          ...common,
          text: textValue,
          fontSize: Number(p.fontSize || 14)
        };

        // ID do elemento (para linkToDestination)
        if (p.id && p.id.trim()) {
          textObj.id = p.id.trim();
        }

        // Styling completo
        if (p.color) textObj.color = p.color;
        if (p.background) textObj.background = p.background;
        if (p.font) textObj.font = p.font;
        if (p.decoration) textObj.decoration = p.decoration;
        if (p.alignment) textObj.alignment = p.alignment;
        if (p.bold) textObj.bold = true;
        if (p.italics) textObj.italics = true;
        if (p.lineHeight !== undefined) textObj.lineHeight = p.lineHeight;
        if (p.characterSpacing !== undefined) textObj.characterSpacing = p.characterSpacing;
        if (p.decorationStyle) textObj.decorationStyle = p.decorationStyle;
        if (p.decorationColor) textObj.decorationColor = p.decorationColor;
        if (p.fontFeatures && Array.isArray(p.fontFeatures) && p.fontFeatures.length > 0) textObj.fontFeatures = p.fontFeatures;

        // Link
        if (p.link && p.link.trim()) {
          textObj.link = p.link.trim();
        } else if (p.linkToPage) {
          textObj.linkToPage = p.linkToPage;
        } else if (p.linkToDestination) {
          textObj.linkToDestination = p.linkToDestination;
        }

        return textObj;
      }

      if (el.type === 'image') {
        const out = {
          ...common,
          image: p.url || ''
        };

        // Dimensionamento: width/height, fit ou cover (mutuamente exclusivos)
        if (p.fit !== undefined) {
          out.fit = Array.isArray(p.fit) ? [Number(p.fit[0]), Number(p.fit[1])] : Number(p.fit);
        } else if (p.cover !== undefined) {
          out.cover = {
            width: Number(p.cover.width || 300),
            height: Number(p.cover.height || 150),
            ...(p.cover.align ? { align: p.cover.align } : {}),
            ...(p.cover.valign ? { valign: p.cover.valign } : {})
          };
        } else {
          if (p.width !== undefined) out.width = Number(p.width);
          if (p.height !== undefined) out.height = Number(p.height);
        }

        // Outras propriedades
        if (p.alignment) out.alignment = p.alignment;
        if (p.opacity !== undefined) out.opacity = Number(p.opacity);
        if (p.borderRadius && p.borderRadius > 0) out.borderRadius = Number(p.borderRadius);
        if (p.absolutePosition) {
          out.absolutePosition = {
            x: Number(p.absolutePosition.x || 0),
            y: Number(p.absolutePosition.y || 0)
          };
        }
        if (p.relativePosition) {
          out.relativePosition = {
            x: Number(p.relativePosition.x || 0),
            y: Number(p.relativePosition.y || 0)
          };
        }

        return out;
      }

      if (el.type === 'margin') {
        // No pdfmake, um "texto vazio" com margin ou um canvas; aqui usamos um texto invisível
        // Suportar tanto o formato antigo (size) quanto o novo (margin array)
        const marginArray = p.margin || (p.size ? [0, p.size, 0, 0] : [0, 20, 0, 0]);
        return { text: ' ', margin: marginArray };
      }

      if (el.type === 'pageBreak') {
        return { text: ' ', pageBreak: 'after' };
      }

      if (el.type === 'qr') {
        const qrObj = {
          ...common,
          qr: p.text || 'https://exemplo.com',
          fit: Number(p.fit || 100)
        };
        if (p.eccLevel) qrObj.eccLevel = p.eccLevel;
        // Sempre aplicar foreground e background (mesmo que sejam os padrões)
        qrObj.foreground = p.foreground || '#000000';
        qrObj.background = p.background || '#ffffff';
        if (p.alignment) qrObj.alignment = p.alignment;
        return qrObj;
      }

      if (el.type === 'svg') {
        const svgObj = {
          ...common,
          svg: p.svg || '<svg></svg>'
        };
        if (p.width) svgObj.width = Number(p.width);
        if (p.height) svgObj.height = Number(p.height);
        if (p.color) svgObj.color = p.color;
        if (p.alignment) svgObj.alignment = p.alignment;
        return svgObj;
      }

      if (el.type === 'stamp') {
        const stampObj = {
          stampType: p.sourceType || 'image',
          stamp: p.value || '',
          fit: Array.isArray(p.fit) ? p.fit : [p.fit || 120, p.fit || 120],
          alignment: p.alignment || 'center',
          margin: Array.isArray(p.margin) ? p.margin : [0, 0, 0, 0]
        };

        if (p.opacity !== undefined) {
          stampObj.opacity = Number(p.opacity);
        }

        return stampObj;
      }

      if (el.type === 'checkbox' || el.type === 'radio') {
        const choiceType = p.choiceType || el.type;
        const choiceText = p.choiceText || 'Texto...';
        const choiceChecked = p.choiceChecked === true;
        const choiceIconPosition = p.choiceIconPosition || 'before';
        const choiceGap = Number(p.choiceGap || 8);
        const choiceIconSize = Number(p.choiceIconSize || 12);
        const alignment = p.alignment || 'left';
        const margin = Array.isArray(p.margin) ? p.margin : [0, 0, 0, 10];

        // Função para gerar SVG do ícone
        function generateChoiceSVG(type, checked, size) {
          if (type === 'checkbox') {
            if (checked) {
              return `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}"><rect x="1" y="1" width="${size - 2}" height="${size - 2}" fill="none" stroke="#000" stroke-width="1"/><path d="M 3 ${size * 0.5} L ${size * 0.4} ${size * 0.7} L ${size * 0.8} ${size * 0.3}" fill="none" stroke="#000" stroke-width="1.3" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
            } else {
              return `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}"><rect x="1" y="1" width="${size - 2}" height="${size - 2}" fill="none" stroke="#000" stroke-width="1"/></svg>`;
            }
          } else if (type === 'radio') {
            if (checked) {
              return `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}"><circle cx="${size / 2}" cy="${size / 2}" r="${size / 2 - 1}" fill="none" stroke="#000" stroke-width="1"/><circle cx="${size / 2}" cy="${size / 2}" r="${size / 4}" fill="#000"/></svg>`;
            } else {
              return `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}"><circle cx="${size / 2}" cy="${size / 2}" r="${size / 2 - 1}" fill="none" stroke="#000" stroke-width="1"/></svg>`;
            }
          }
          return '';
        }

        const svgString = generateChoiceSVG(choiceType, choiceChecked, choiceIconSize);

        // Montar células da tabela
        const iconCell = {
          svg: svgString,
          width: choiceIconSize,
          height: choiceIconSize,
          alignment: 'center',
          margin: choiceIconPosition === 'before' ? [0, 0, choiceGap, 0] : [choiceGap, 0, 0, 0]
        };

        const textCell = {
          text: choiceText,
          fontSize: 10,
          margin: [0, 0, 0, 0]
        };

        // Definir larguras e ordem das colunas baseado na posição do ícone
        let widths, body;
        if (choiceIconPosition === 'before') {
          widths = [choiceIconSize, '*'];
          body = [[iconCell, textCell]];
        } else {
          widths = ['*', choiceIconSize];
          body = [[textCell, iconCell]];
        }

        return {
          alignment: alignment,
          margin: margin,
          table: {
            widths: widths,
            body: body
          },
          layout: 'noBorders'
        };
      }

      if (el.type === 'fillLine') {
        const fillLineObj = {
          fillLine: true,
          lineWidth: Number(p.lineWidth || 200),
          thickness: Number(p.thickness || 0.8),
          color: p.color || '#000000',
          alignment: p.alignment || 'left',
          margin: Array.isArray(p.margin) ? p.margin : [0, 0, 0, 0]
        };

        return fillLineObj;
      }

      if (el.type === 'chart') {
        const chartObj = {
          chart: true,
          chartType: p.chartType || 'bar',
          chartWidth: Number(p.chartWidth || 400),
          chartHeight: Number(p.chartHeight || 200),
          chartFit: Array.isArray(p.chartFit) ? p.chartFit : [p.chartFit || 400, p.chartFit || 200],
          chartBackgroundColor: p.chartBackgroundColor || '#FFFFFF',
          chartDevicePixelRatio: Number(p.chartDevicePixelRatio || 2),
          chartData: p.chartData || { labels: [], datasets: [] },
          chartOptions: p.chartOptions || { responsive: false, animation: { duration: 0 } },
          alignment: p.alignment || 'center',
          margin: Array.isArray(p.margin) ? p.margin : [0, 0, 0, 0]
        };

        return chartObj;
      }

      if (el.type === 'barcode') {
        // Formato obrigatório: { alignment: 'center', verticalAlignment: 'middle', stack: [{ barcode: 'VALOR', fit: [201, 42] }] }
        const barcodeObj = {
          barcode: p.barcodeValue || 'ABC123456789',
          fit: p.fit || [201, 42]
        };

        // Adicionar propriedades extras se necessário (para o script_fixo do Bubble)
        if (p.format) barcodeObj.barcodeFormat = p.format;
        if (p.lineWidth !== undefined) barcodeObj.barcodeWidth = Number(p.lineWidth);
        if (p.barHeight !== undefined) barcodeObj.barcodeHeight = Number(p.barHeight);
        if (p.displayValue !== undefined) barcodeObj.barcodeDisplayValue = p.displayValue;
        if (p.fontSize !== undefined) barcodeObj.barcodeFontSize = Number(p.fontSize);
        if (p.margin !== undefined) barcodeObj.barcodeMargin = Number(p.margin);

        const stackObj = {
          alignment: p.alignment || 'center',
          stack: [barcodeObj]
        };

        // Se estiver dentro de célula de tabela, adicionar verticalAlignment
        if (inTableCell) {
          stackObj.verticalAlignment = p.verticalAlignment || 'middle';
        } else if (p.verticalAlignment) {
          stackObj.verticalAlignment = p.verticalAlignment;
        }

        // Aplicar margin se existir
        if (Array.isArray(p.margin)) {
          stackObj.margin = p.margin;
        }

        return stackObj;
      }

      if (el.type === 'group') {
        // group no editor = stack no PDF
        // Passar contexto para elementos filhos (se estiver em header/footer, manter contexto)
        const kids = (p.children || []).map(ch => elementToPdfmake(ch, context));
        return kids.length <= 1 ? (kids[0] || { text: '' }) : { stack: kids };
      }

      if (el.type === 'columns') {
        const cols = (p.columns || []).map(col => {
          // Passar contexto para elementos filhos
          const kids = (col.children || []).map(ch => elementToPdfmake(ch, context));
          const contentNode = kids.length <= 1 ? (kids[0] || { text: '' }) : { stack: kids };

          // Processar width: pode ser '*', número, ou string com '%'
          let width = col.width || '*';
          if (typeof width === 'string' && width.endsWith('%')) {
            // Manter como string com % para PDFMake
            width = width;
          } else if (typeof width === 'number') {
            // Número = pixels
            width = width;
          } else {
            // '*' ou 'auto' = automático
            width = '*';
          }

          return { width, ...contentNode };
        });

        return {
          ...common,
          columnGap: Number(p.gap || 10),
          columns: cols
        };
      }

      if (el.type === 'list') {
        const items = (p.items || []).map(it => {
          if (!it) return '';
          if (it.kind === 'text') return it.text || '';
          if (it.kind === 'node' && it.node) return elementToPdfmake(it.node, context);
          return '';
        });
        const listType = p.listType === 'ol' ? 'ol' : 'ul';
        const listObj = {
          ...common,
          [listType]: items
        };

        // Adicionar propriedades extras para listas ordenadas
        if (listType === 'ol') {
          if (p.start && p.start !== 1) listObj.start = p.start;
          if (p.reversed) listObj.reversed = true;
          if (p.type) listObj.type = p.type;
        } else {
          // Para listas não ordenadas, apenas type e markerColor
          if (p.type) listObj.type = p.type;
          if (p.markerColor) listObj.markerColor = p.markerColor;
        }

        return listObj;
      }

      if (el.type === 'table') {
        // Primeiro, processar o body e identificar células com rowSpan/colSpan
        const processedBody = [];
        const originalBody = p.body || [];

        // Rastrear células cobertas por spans
        const coveredCells = new Set();

        for (let r = 0; r < originalBody.length; r++) {
          const processedRow = [];

          for (let c = 0; c < originalBody[r].length; c++) {
            // Pular células já cobertas
            if (coveredCells.has(`${r}-${c}`)) {
              processedRow.push({}); // Célula vazia para PDFMake
              continue;
            }

            const cell = originalBody[r][c];

            // Se a célula é null ou string vazia, manter como objeto vazio
            if (!cell || (typeof cell === 'string' && cell === '')) {
              processedRow.push({});
              continue;
            }

            // Processar conteúdo da célula
            // Passar contexto para elementos filhos (se estiver em header/footer, manter contexto)
            // Adicionar flag inTableCell para barcode aplicar verticalAlignment
            const kids = (cell.children || []).map(ch => elementToPdfmake(ch, { ...context, inTableCell: true }));
            const cellContent = (kids.length <= 1) ? (kids[0] || '') : { stack: kids };

            // Aplicar estilos da célula
            // Se a célula tem um estilo definido, usar referência ao estilo
            // Caso contrário, aplicar propriedades inline
            const cellObj = typeof cellContent === 'string' ? { text: cellContent } : cellContent;

            // Se a célula tem um nome de estilo, usar referência ao estilo
            // Propriedades que podem estar no estilo: fontSize, alignment, margin, color (texto), bold, italics
            if (cell._styleName) {
              cellObj.style = cell._styleName;
            } else {
              // Aplicar propriedades inline (fallback se não houver estilo)
              if (cell.fontSize !== undefined) cellObj.fontSize = cell.fontSize;
              if (cell.alignment) cellObj.alignment = cell.alignment;
              if (cell.margin && Array.isArray(cell.margin)) cellObj.margin = cell.margin;
              if (cell.color) cellObj.color = cell.color; // Cor do texto
              if (cell.bold !== undefined) cellObj.bold = cell.bold;
              if (cell.italics !== undefined) cellObj.italics = cell.italics;
            }

            // Propriedades específicas da célula (nunca devem ser estilos)
            // fillColor = cor de fundo da célula (diferente de color = cor do texto)
            // Só aplicar fillColor individual se zebra não estiver ativado
            if (!p.zebraEnabled && cell.fillColor) cellObj.fillColor = cell.fillColor;
            if (cell.fillOpacity !== undefined) cellObj.fillOpacity = Number(cell.fillOpacity);

            // rowSpan e colSpan - IMPORTANTE: marcar células cobertas
            if (cell.rowSpan && cell.rowSpan > 1) {
              cellObj.rowSpan = cell.rowSpan;
              // Marcar células abaixo como cobertas
              for (let sr = 1; sr < cell.rowSpan; sr++) {
                if (r + sr < originalBody.length) {
                  coveredCells.add(`${r + sr}-${c}`);
                }
              }
            }
            if (cell.colSpan && cell.colSpan > 1) {
              cellObj.colSpan = cell.colSpan;
              // Marcar células à direita como cobertas
              for (let sc = 1; sc < cell.colSpan; sc++) {
                if (c + sc < originalBody[r].length) {
                  coveredCells.add(`${r}-${c + sc}`);
                }
              }
            }

            // border (array de 4 booleanos [left, top, right, bottom])
            if (cell.border && Array.isArray(cell.border)) {
              // Sempre adicionar o array de border, mesmo se for [true, true, true, true]
              // O PDFMake usa isso para controlar quais bordas mostrar
              cellObj.border = cell.border.map(b => Boolean(b));
            }

            // borderColor (array de 4 cores)
            if (cell.borderColor && Array.isArray(cell.borderColor)) {
              // Só adicionar se houver pelo menos uma cor definida
              if (cell.borderColor.some(c => c && c.trim())) {
                cellObj.borderColor = cell.borderColor.map(c => c || '');
              }
            }

            // verticalAlignment (deve estar na célula, não no texto)
            if (cell.verticalAlignment) {
              cellObj.verticalAlignment = cell.verticalAlignment;
            }

            processedRow.push(cellObj);
          }

          processedBody.push(processedRow);
        }

        const body = processedBody;

        const tableObj = {
          ...common,
          table: {
            widths: (p.widths || (body[0] ? body[0].map(() => '*') : ['*'])),
            body
          }
        };

        // heights (pode ser número, array ou função)
        if (p.heights !== undefined) {
          if (typeof p.heights === 'number') {
            tableObj.table.heights = p.heights;
          } else if (Array.isArray(p.heights)) {
            tableObj.table.heights = p.heights.map(h => Number(h) || 40);
          }
          // Função será tratada separadamente se necessário
        }

        // Tabela zebrada tem prioridade - se ativada, sempre criar layout como objeto
        // IMPORTANTE: layout deve ficar no mesmo nível que table, não dentro de table
        if (p.zebraEnabled && p.zebraColor) {
          // Criar layout como objeto (não string) - mesmo nível que table
          tableObj.layout = {};

          // Usar a cor diretamente como string no código da função
          // Criar função usando Function constructor para que a cor seja string literal no código fonte
          const zebraColorStr = p.zebraColor;
          // Criar função que quando serializada já terá a cor como string literal
          tableObj.layout.fillColor = new Function('i', 'node',
            `return (i % 2 === 0) ? '${zebraColorStr}' : null;`
          );
          // Armazenar a cor como propriedade também para backup na serialização
          tableObj.layout.fillColor._zebraColor = zebraColorStr;

          // Se zebraWithLines estiver ativado, adicionar linhas horizontais (seguindo o exemplo)
          // IMPORTANTE: Usar new Function() para que valores sejam literais no código gerado
          if (p.zebraWithLines !== false) {
            tableObj.layout.hLineWidth = new Function('i', 'node',
              `if (i === 0 || i === node.table.body.length) {
                return 0;
              }
              return (i === node.table.headerRows) ? 2 : 1;`
            );
            tableObj.layout.hLineColor = new Function('i',
              `return i === 1 ? 'black' : '#aaa';`
            );
            tableObj.layout.vLineWidth = new Function('i',
              `return 0;`
            );
          } else {
            // Sem linhas horizontais
            tableObj.layout.hLineWidth = new Function('i', 'node',
              `return 0;`
            );
            tableObj.layout.vLineWidth = new Function('i',
              `return 0;`
            );
          }

          // Padding padrão (se não houver customLayout)
          // IMPORTANTE: Usar new Function() para que valores sejam literais no código gerado
          if (!p.customLayout || !p.customLayout.paddingLeft) {
            tableObj.layout.paddingLeft = new Function('i',
              `return i === 0 ? 0 : 8;`
            );
          }
          if (!p.customLayout || !p.customLayout.paddingRight) {
            tableObj.layout.paddingRight = new Function('i', 'node',
              `return (i === node.table.widths.length - 1) ? 0 : 8;`
            );
          }

          // Se houver customLayout, aplicar suas configurações de padding
          // IMPORTANTE: Usar new Function() para que valores sejam literais no código gerado
          if (p.customLayout) {
            if (p.customLayout.paddingLeft !== undefined) {
              const paddingLeft = Number(p.customLayout.paddingLeft);
              tableObj.layout.paddingLeft = new Function('i',
                `return i === 0 ? 0 : ${paddingLeft};`
              );
            }
            if (p.customLayout.paddingRight !== undefined) {
              const paddingRight = Number(p.customLayout.paddingRight);
              tableObj.layout.paddingRight = new Function('i', 'node',
                `return (i === node.table.widths.length - 1) ? 0 : ${paddingRight};`
              );
            }
            if (p.customLayout.paddingTop !== undefined) {
              const paddingTop = Number(p.customLayout.paddingTop);
              tableObj.layout.paddingTop = new Function('i',
                `return ${paddingTop};`
              );
            }
            if (p.customLayout.paddingBottom !== undefined) {
              const paddingBottom = Number(p.customLayout.paddingBottom);
              tableObj.layout.paddingBottom = new Function('i',
                `return ${paddingBottom};`
              );
            }
          }
        } else if (p.layout === 'custom' && p.customLayout) {
          // Layout customizado (sem zebra)
          const customLayout = {};

          // Linhas horizontais
          // IMPORTANTE: Usar new Function() para que valores sejam literais no código gerado
          if (p.customLayout.hLineWidth !== undefined) {
            const hLineWidth = Number(p.customLayout.hLineWidth || 1);
            customLayout.hLineWidth = new Function('i', 'node',
              `return ${hLineWidth};`
            );
          }
          if (p.customLayout.hLineColor) {
            const hLineColor = p.customLayout.hLineColor;
            customLayout.hLineColor = new Function('i', 'node',
              `return '${hLineColor}';`
            );
          }

          // Linhas verticais
          if (p.customLayout.vLineWidth !== undefined) {
            const vLineWidth = Number(p.customLayout.vLineWidth || 1);
            customLayout.vLineWidth = new Function('i', 'node',
              `return ${vLineWidth};`
            );
          }
          if (p.customLayout.vLineColor) {
            const vLineColor = p.customLayout.vLineColor;
            customLayout.vLineColor = new Function('i', 'node',
              `return '${vLineColor}';`
            );
          }

          // Padding (deve ser função, não valor fixo)
          // Template oficial: funções simples que retornam valores fixos
          if (p.customLayout.paddingLeft !== undefined) {
            const paddingLeft = Number(p.customLayout.paddingLeft);
            // Template padrão: função simples sem condições
            customLayout.paddingLeft = new Function('i',
              `return ${paddingLeft};`
            );
          }
          if (p.customLayout.paddingRight !== undefined) {
            const paddingRight = Number(p.customLayout.paddingRight);
            // Template padrão: função simples sem condições
            customLayout.paddingRight = new Function('i', 'node',
              `return ${paddingRight};`
            );
          }
          if (p.customLayout.paddingTop !== undefined) {
            const paddingTop = Number(p.customLayout.paddingTop);
            customLayout.paddingTop = new Function('i',
              `return ${paddingTop};`
            );
          }
          if (p.customLayout.paddingBottom !== undefined) {
            const paddingBottom = Number(p.customLayout.paddingBottom);
            customLayout.paddingBottom = new Function('i',
              `return ${paddingBottom};`
            );
          }

          // hLineStyle e vLineStyle (dashed)
          // IMPORTANTE: Usar new Function() para que valores sejam literais no código gerado
          if (p.customLayout.hLineStyle) {
            customLayout.hLineStyle = new Function('i', 'node',
              `if (i === 0 || i === node.table.body.length) {
            return null;
        }
              return { dash: { length: 10, space: 4 } };`
            );
          }
          if (p.customLayout.vLineStyle) {
            customLayout.vLineStyle = new Function('i', 'node',
              `if (i === 0 || i === node.table.widths.length) {
                return null;
              }
              return { dash: { length: 4 } };`
            );
          }

          // defaultBorder
          if (p.customLayout.defaultBorder !== undefined) {
            customLayout.defaultBorder = p.customLayout.defaultBorder;
          }

          // fillColor para template padrão (quando fillColor é true, significa usar template)
          if (p.customLayout.fillColor === true) {
            // Template oficial: fillColor(rowIndex) com cinza #EDEDED somente no header (rowIndex === 0)
            customLayout.fillColor = new Function('rowIndex',
              `return rowIndex === 0 ? '#EDEDED' : null;`
            );
          }

          if (Object.keys(customLayout).length > 0) {
            // Layout deve ficar no mesmo nível que table, não dentro de table
            tableObj.layout = customLayout;
          }
        } else if (p.layout && p.layout !== 'custom') {
          // Layout padrão (string) - também no mesmo nível que table
          tableObj.layout = p.layout;
        }

        // Adicionar propriedades extras da tabela
        // dontBreakRows e keepWithHeaderRows devem estar dentro de table, não no objeto principal
        if (p.dontBreakRows) tableObj.table.dontBreakRows = true;
        if (p.keepWithHeaderRows) tableObj.table.keepWithHeaderRows = p.keepWithHeaderRows;

        // headerRows deve ser definido conforme propriedade da tabela ou padrão 1
        if (p.headerRows !== undefined) {
          tableObj.table.headerRows = p.headerRows;
        } else if (body.length > 0) {
          tableObj.table.headerRows = 1;
        }

        return tableObj;
      }

      return { ...common, text: '' };
    }

    // Processar variáveis dinâmicas em header/footer
    function processHeaderFooterText(text, currentPage, totalPages) {
      if (!text) return '';
      return text
        .replace(/\{\{pageNumber\}\}/g, currentPage.toString())
        .replace(/\{\{totalPages\}\}/g, totalPages.toString());
    }

    function buildDocDefinition() {
      const root = getRootGroup();

      // Primeiro, coletar estilos das células ANTES de converter para PDFMake
      const cellStylesMap = new Map();
      let styleCounter = 0;

      function collectTableCellStyles(element) {
        if (!element || element.type !== 'table') return;
        const p = element.properties || {};
        const body = p.body || [];

        body.forEach(row => {
          if (Array.isArray(row)) {
            row.forEach(cell => {
              if (cell && typeof cell === 'object' && cell.children) {
                // Coletar propriedades de estilo da célula
                const styleProps = {};
                // Verificar propriedades que podem ser estilos
                // Nota: fillColor, color, fillOpacity são específicos da célula e não devem ser estilos
                // Mas fontSize, alignment, margin, bold podem ser estilos

                // Coletar do objeto cell diretamente (propriedades da célula)
                // Essas propriedades vêm do editor de células
                const cellStyleKey = JSON.stringify({
                  fontSize: cell.fontSize,
                  alignment: cell.alignment,
                  margin: cell.margin,
                  color: cell.color,
                  bold: cell.bold,
                  italics: cell.italics
                });

                if (!cellStylesMap.has(cellStyleKey) && cell.fontSize) {
                  const styleName = `tableCellStyle${++styleCounter}`;
                  const styleObj = {};
                  if (cell.fontSize) styleObj.fontSize = cell.fontSize;
                  if (cell.alignment) styleObj.alignment = cell.alignment;
                  if (cell.margin && Array.isArray(cell.margin)) styleObj.margin = cell.margin;
                  if (cell.color) styleObj.color = cell.color;
                  if (cell.bold !== undefined) styleObj.bold = cell.bold;
                  if (cell.italics !== undefined) styleObj.italics = cell.italics;

                  cellStylesMap.set(cellStyleKey, { name: styleName, props: styleObj });
                  // Armazenar o nome do estilo na célula para uso posterior
                  cell._styleName = styleName;
                } else if (cellStylesMap.has(cellStyleKey)) {
                  cell._styleName = cellStylesMap.get(cellStyleKey).name;
                }
              }
            });
          }
        });
      }

      // Coletar estilos recursivamente de todas as tabelas
      function traverseElements(el) {
        if (!el) return;
        if (el.type === 'table') {
          collectTableCellStyles(el);
        }
        if (el.properties && el.properties.children) {
          el.properties.children.forEach(traverseElements);
        }
      }
      traverseElements(root);

      // Agora converter para PDFMake (os estilos já estão marcados nas células)
      const content = root ? [elementToPdfmake(root)] : [];

      const docDef = {
        pageSize,
        pageOrientation: orientation,
        pageMargins,
        content
      };

      // Adicionar estilos coletados ao docDef
      if (cellStylesMap.size > 0) {
        docDef.styles = {};
        cellStylesMap.forEach(({ name, props }) => {
          docDef.styles[name] = props;
        });
      }

      // Adicionar header se configurado (usando container visual)
      if (documentHeader && documentHeader.enabled && documentHeader.root) {
        const headerChildren = documentHeader.root.properties.children || [];
        if (headerChildren.length > 0) {
          // Converter elementos do header para PDFMake
          // Passar contexto para processar placeholders corretamente
          const headerContent = headerChildren.map(el => elementToPdfmake(el, { inHeader: true }));

          // Criar função que retorna o array de conteúdo
          docDef.header = function (currentPage, pageCount, pageSize) {
            return headerContent;
          };
          // Armazenar conteúdo serializado para uso na geração de código
          docDef.header._content = headerContent;
        }
      }

      // Adicionar footer se configurado (usando container visual)
      if (documentFooter && documentFooter.enabled && documentFooter.root) {
        const footerChildren = documentFooter.root.properties.children || [];
        if (footerChildren.length > 0) {
          // Converter elementos do footer para PDFMake
          // Passar contexto para processar placeholders corretamente
          const footerContent = footerChildren.map(el => elementToPdfmake(el, { inFooter: true }));

          // Criar função que retorna o array de conteúdo
          docDef.footer = function (currentPage, pageCount, pageSize) {
            return footerContent;
          };
          // Armazenar conteúdo serializado para uso na geração de código
          docDef.footer._content = footerContent;
        }
      }

      // Adicionar watermark se configurado (apenas texto - PDFMake não suporta imagens)
      if (documentWatermark && documentWatermark.text && documentWatermark.text.trim()) {
        docDef.watermark = {
          text: documentWatermark.text,
          fontSize: documentWatermark.fontSize || 48,
          color: documentWatermark.color || '#cccccc',
          opacity: documentWatermark.opacity !== undefined ? documentWatermark.opacity : 0.3,
          angle: documentWatermark.angle !== undefined ? documentWatermark.angle : -45
        };
      }

      // Adicionar TOC se configurado
      if (documentTOC && documentTOC.enabled) {
        // O TOC será adicionado no início do content
        const tocItem = {
          toc: {
            title: { text: documentTOC.title || 'Índice', ...(documentTOC.titleStyle || {}) },
            textStyle: documentTOC.textStyle || {},
            numberStyle: documentTOC.numberStyle || {},
            margin: documentTOC.margin || [0, 0, 0, 20]
          }
        };
        docDef.content.unshift(tocItem);
      }

      // Adicionar Security se configurado
      if (documentSecurity && documentSecurity.enabled && documentSecurity.userPassword) {
        docDef.userPassword = documentSecurity.userPassword;
        if (documentSecurity.ownerPassword) {
          docDef.ownerPassword = documentSecurity.ownerPassword;
        }
        if (documentSecurity.permissions) {
          docDef.permissions = {
            printing: documentSecurity.permissions.printing !== false ? 'highResolution' : false,
            modifying: documentSecurity.permissions.modifying !== false,
            copying: documentSecurity.permissions.copying !== false,
            annotating: documentSecurity.permissions.annotating !== false
          };
        }
      }

      // Adicionar Info (Metadados) se configurado
      if (documentPageInfo && (documentPageInfo.author || documentPageInfo.title || documentPageInfo.subject || documentPageInfo.keywords)) {
        docDef.info = {};
        if (documentPageInfo.author) docDef.info.author = documentPageInfo.author;
        if (documentPageInfo.title) docDef.info.title = documentPageInfo.title;
        if (documentPageInfo.subject) docDef.info.subject = documentPageInfo.subject;
        if (documentPageInfo.keywords) docDef.info.keywords = documentPageInfo.keywords;
      }

      // Adicionar Compress se configurado
      if (documentCompress) {
        docDef.compress = true;
      }

      return docDef;
    }


    // -----------------------
    // Confirm Modal Helpers
    // -----------------------
    let confirmModalCallback = null;

    function showConfirmModal(title, message, callback) {
      const modal = document.getElementById('confirmModal');
      const titleEl = document.getElementById('confirmModalTitle');
      const messageEl = document.getElementById('confirmModalMessage');

      if (!modal || !titleEl || !messageEl) {
        console.error('Modal de confirmação não encontrado');
        return;
      }

      titleEl.textContent = title || 'Confirmar ação';
      messageEl.textContent = message || 'Tem certeza que deseja realizar esta ação?';
      confirmModalCallback = callback;

      modal.classList.add('active');
    }
    window.showConfirmModal = showConfirmModal; // Tornar global

    function confirmModalAction() {
      if (confirmModalCallback) {
        confirmModalCallback();
      }
      closeConfirmModal();
    }
    window.confirmModalAction = confirmModalAction; // Tornar global para uso no onclick

    function closeConfirmModal() {
      const modal = document.getElementById('confirmModal');
      if (modal) {
        modal.classList.remove('active');
      }
      confirmModalCallback = null;
    }
    window.closeConfirmModal = closeConfirmModal; // Tornar global para uso no onclick

    // -----------------------
    // Alert Modal Helpers
    // -----------------------
    function showAlertModal(title, message) {
      const modal = document.getElementById('alertModal');
      const titleEl = modal.querySelector('.custom-modal-header h3');
      const messageEl = document.getElementById('alertModalMessage');

      if (titleEl) titleEl.textContent = title || 'Aviso';
      if (messageEl) messageEl.textContent = message || 'Mensagem de alerta';

      if (modal) {
        modal.classList.add('active');
      }
    }
    window.showAlertModal = showAlertModal; // Tornar global

    function closeAlertModal() {
      const modal = document.getElementById('alertModal');
      if (modal) {
        modal.classList.remove('active');
      }
    }
    window.closeAlertModal = closeAlertModal; // Tornar global para uso no onclick

    // Fechar modal de preview do PDF
    function closePreviewModal() {
      const modal = document.getElementById('previewModal');
      const iframe = document.getElementById('previewIframe');

      if (modal) {
        modal.classList.remove('active');
      }

      // Limpar o src do iframe para liberar memória
      if (iframe && iframe.src) {
        URL.revokeObjectURL(iframe.src);
        iframe.src = '';
      }
    }
    window.closePreviewModal = closePreviewModal; // Tornar global para uso no onclick

    function closeBubbleTestModal() {
      const modal = document.getElementById('bubbleTestModal');
      const iframe = document.getElementById('bubbleTestIframe');

      if (modal) {
        modal.classList.remove('active');
      }

      // Limpar o src do iframe
      if (iframe) {
        iframe.src = '';
      }
    }
    window.closeBubbleTestModal = closeBubbleTestModal; // Tornar global para uso no onclick

    // Fechar modais com ESC
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeConfirmModal();
        closePreviewModal();
        closeBubbleTestModal();
      }
    });

    // -----------------------
    // Code tab
    // -----------------------
    
    // Função para coletar apenas as configurações dos elementos (sem gerar código)
    function getElementConfigurations() {
      const root = getRootGroup();
      
      // Coletar configurações de elementos (deep clone para evitar referências)
      const cleanedElements = cleanElementsForStorage(elements);
      
      return {
        elements: cleanedElements,
        pageSize: pageSize,
        orientation: orientation,
        pageMargins: pageMargins,
        documentHeader: documentHeader ? JSON.parse(JSON.stringify(documentHeader)) : null,
        documentFooter: documentFooter ? JSON.parse(JSON.stringify(documentFooter)) : null,
        documentWatermark: documentWatermark ? JSON.parse(JSON.stringify(documentWatermark)) : null,
        documentTOC: documentTOC ? JSON.parse(JSON.stringify(documentTOC)) : null,
        documentSecurity: documentSecurity ? JSON.parse(JSON.stringify(documentSecurity)) : null,
        documentPageInfo: documentPageInfo ? JSON.parse(JSON.stringify(documentPageInfo)) : null,
        documentCompress: documentCompress
      };
    }

    // Função para construir objeto dd sem funções (apenas dados serializáveis)
    function buildDocDefinitionForSerialization() {
      const dd = buildDocDefinition();
      
      // Converter funções em objetos serializáveis
      // Para header/footer, usar _content se disponível
      if (dd.header && typeof dd.header === 'function' && dd.header._content) {
        dd.header = { _isFunction: true, _content: dd.header._content };
      }
      if (dd.footer && typeof dd.footer === 'function' && dd.footer._content) {
        dd.footer = { _isFunction: true, _content: dd.footer._content };
      }
      
      // Para funções em layouts de tabela, precisamos extrair os valores
      // Isso será feito na Edge Function
      
      return dd;
    }

    // Função para gerar código via Edge Function
    async function generateCodeViaEdgeFunction() {
      const codeEditor = document.getElementById('codeEditor');
      if (!codeEditor) return;

      // Mostrar loading
      codeEditor.textContent = 'Gerando código... Aguarde.';
      
      try {
        // Construir objeto dd (sem funções, apenas dados)
        const dd = buildDocDefinitionForSerialization();
        
        // Usar fetch direto para garantir que os headers sejam enviados corretamente
        const response = await fetch(`${SUPABASE_URL}/functions/v1/generate-pdf-code`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
            'apikey': SUPABASE_ANON_KEY
          },
          body: JSON.stringify({ dd: dd })
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`Erro ${response.status}: ${errorText || response.statusText}`);
        }

        const result = await response.json();

        if (result && result.code) {
          // Exibir código gerado
          codeEditor.textContent = result.code;
          
          // Salvar código gerado no localStorage
          try {
            localStorage.setItem(STORAGE_CODE_KEY, result.code);
          } catch (e) {
            console.warn('Erro ao salvar código no localStorage:', e);
          }
        } else {
          throw new Error('Resposta inválida da Edge Function: código não encontrado');
        }
      } catch (error) {
        console.error('Erro ao gerar código:', error);
        const errorMessage = error.message || 'Erro desconhecido';
        codeEditor.textContent = `// Erro ao gerar código: ${errorMessage}\n\nPor favor, verifique:\n1. Se a Edge Function está configurada e deployada corretamente\n2. Se a URL da Edge Function está correta\n3. Se há elementos no canvas\n4. Verifique o console para mais detalhes`;
      }
    }

    // Função updateCode refatorada - agora chama a Edge Function
    async function updateCode() {
      // Verificar se há elementos para gerar código
      const root = getRootGroup();
      if (!root || !root.properties || !root.properties.children || root.properties.children.length === 0) {
        const codeEditor = document.getElementById('codeEditor');
        if (codeEditor) {
          codeEditor.textContent = '// Adicione elementos para gerar o código';
        }
        return;
      }

      // Chamar Edge Function para gerar código
      await generateCodeViaEdgeFunction();
    }

    // Função antiga mantida para referência (será removida após migração completa)
    // Esta função contém toda a lógica de serialização que será movida para a Edge Function
    function updateCode_OLD() {
      const dd = buildDocDefinition();

      // Mapear funções para seus valores de variáveis locais (para substituição)
      const functionVariableMap = new Map();

      // Coletar informações sobre funções e suas variáveis locais
      // Esta função coleta valores de variáveis usadas em funções para substituição na serialização
      function collectFunctionVariables(obj, path = '') {
        if (!obj || typeof obj !== 'object') return;

        if (Array.isArray(obj)) {
          obj.forEach((item, idx) => {
            collectFunctionVariables(item, `${path}[${idx}]`);
          });
        } else {
          // Verificar se é uma tabela com layout
          if (obj.table && obj.layout && typeof obj.layout === 'object') {
            const layout = obj.layout;
            Object.keys(layout).forEach(key => {
              if (typeof layout[key] === 'function') {
                const funcStr = layout[key].toString();
                const currentPath = `${path}.layout.${key}`;

                // Tentar executar a função para obter valores de retorno
                try {
                  // Para fillColor, testar com linha par
                  if (key === 'fillColor') {
                    const testResult = layout[key](2, { table: { body: [[], [], []] } });
                    if (testResult && typeof testResult === 'string') {
                      functionVariableMap.set(currentPath, {
                        type: 'fillColor',
                        color: testResult
                      });
                    }
                  }
                  // Para padding, testar com diferentes índices
                  else if (key.startsWith('padding')) {
                    const testResult = layout[key](1, { table: { widths: ['*', '*'] } });
                    if (typeof testResult === 'number') {
                      functionVariableMap.set(currentPath, {
                        type: 'padding',
                        value: testResult
                      });
                    }
                  }
                  // Para hLineWidth, vLineWidth
                  else if (key.includes('LineWidth')) {
                    const testResult = layout[key](1, { table: { body: [[], []], widths: ['*', '*'] } });
                    if (typeof testResult === 'number') {
                      functionVariableMap.set(currentPath, {
                        type: 'lineWidth',
                        value: testResult
                      });
                    }
                  }
                  // Para hLineColor, vLineColor
                  else if (key.includes('LineColor')) {
                    const testResult = layout[key](1, {});
                    if (typeof testResult === 'string') {
                      functionVariableMap.set(currentPath, {
                        type: 'lineColor',
                        color: testResult
                      });
                    }
                  }
                } catch (e) {
                  // Se falhar, tentar usar propriedades armazenadas
                  if (layout[key]._zebraColor) {
                    functionVariableMap.set(currentPath, {
                      type: 'fillColor',
                      color: layout[key]._zebraColor
                    });
                  }
                }
              }
            });
          }

          Object.keys(obj).forEach(key => {
            if (key !== 'header' && key !== 'footer') {
              collectFunctionVariables(obj[key], path ? `${path}.${key}` : key);
            }
          });
        }
      }
      collectFunctionVariables(dd);

      // Função recursiva para serializar objeto incluindo funções inline
      function serializeObject(obj, indent = 0, isInArray = false, currentPath = '') {
        const indentStr = '  '.repeat(indent);
        const nextIndent = indent + 1;
        const nextIndentStr = '  '.repeat(nextIndent);

        if (obj === null) return 'null';
        if (obj === undefined) return 'undefined';

        // Remover propriedades internas do PDFMake
        if (typeof obj === 'object' && !Array.isArray(obj) && obj !== null) {
          const filtered = {};
          Object.keys(obj).forEach(key => {
            if (!key.startsWith('_')) {
              filtered[key] = obj[key];
            }
          });
          obj = filtered;
        }

        if (Array.isArray(obj)) {
          if (obj.length === 0) return '[]';
          let result = '[\n';
          obj.forEach((item, idx) => {
            result += nextIndentStr + serializeObject(item, nextIndent, true, `${currentPath}[${idx}]`);
            if (idx < obj.length - 1) result += ',';
            result += '\n';
          });
          result += indentStr + ']';
          return result;
        }

        if (typeof obj === 'function') {
          // Para header/footer, usar conteúdo serializado armazenado em _content
          if (obj._content && Array.isArray(obj._content)) {
            // Serializar o conteúdo como array literal dentro da função
            // IMPORTANTE: Serializar cada item recursivamente para garantir valores literais
            let contentStr = '';
            if (obj._content.length === 0) {
              contentStr = '[]';
            } else {
              const items = [];
              obj._content.forEach((item, idx) => {
                const itemStr = serializeObject(item, nextIndent + 1, true, `${currentPath}._content[${idx}]`);
                items.push(itemStr);
              });
              // Formatar array com indentação correta
              if (items.length === 1 && !items[0].includes('\n')) {
                // Array de um item simples - uma linha
                contentStr = `[${items[0]}]`;
              } else {
                // Array multi-linha
                contentStr = '[\n';
                items.forEach((itemStr, idx) => {
                  // Adicionar indentação extra para cada item
                  const lines = itemStr.split('\n');
                  lines.forEach((line, lineIdx) => {
                    if (lineIdx === 0) {
                      contentStr += nextIndentStr + '  ' + line;
                    } else {
                      contentStr += '\n' + nextIndentStr + '  ' + line;
                    }
                  });
                  if (idx < items.length - 1) contentStr += ',';
                  contentStr += '\n';
                });
                contentStr += nextIndentStr + ']';
              }
            }
            return `function(currentPage, pageCount, pageSize) {\n${nextIndentStr}return ${contentStr};\n${indentStr}}`;
          }

          // Serializar função como string de código formatada
          let funcStr = obj.toString();

          // Obter informações da variável mapeada
          const varInfo = functionVariableMap.get(currentPath);

          // Substituir variáveis conhecidas por valores literais
          // 1. Se a função tem propriedade _zebraColor, usar diretamente
          if (obj._zebraColor) {
            funcStr = funcStr.replace(/\bzebraColorStr\b|\bzebraColor\b|\bbaseColor\b/g, `'${obj._zebraColor}'`);
          }
          // 2. Se temos informação do mapeamento, usar
          else if (varInfo) {
            if (varInfo.type === 'fillColor' && varInfo.color) {
              funcStr = funcStr.replace(/\bzebraColorStr\b|\bzebraColor\b|\bbaseColor\b/g, `'${varInfo.color}'`);
            } else if (varInfo.type === 'padding' && typeof varInfo.value === 'number') {
              // Substituir variáveis de padding (paddingLeft, paddingRight, paddingTop, paddingBottom)
              funcStr = funcStr.replace(/\bpaddingLeft\b|\bpaddingRight\b|\bpaddingTop\b|\bpaddingBottom\b/g, varInfo.value.toString());
            } else if (varInfo.type === 'lineWidth' && typeof varInfo.value === 'number') {
              // Substituir variáveis de lineWidth
              funcStr = funcStr.replace(/\bhLineWidth\b|\bvLineWidth\b/g, varInfo.value.toString());
            } else if (varInfo.type === 'lineColor' && varInfo.color) {
              // Substituir variáveis de lineColor
              funcStr = funcStr.replace(/\bhLineColor\b|\bvLineColor\b/g, `'${varInfo.color}'`);
            }
          }
          // 3. Tentar executar a função para obter valores
          else {
            try {
              // Para fillColor
              if (funcStr.includes('fillColor') || funcStr.includes('zebraColor') || funcStr.includes('baseColor')) {
                const testResult = obj(2, { table: { body: [[], [], []] } });
                if (testResult && typeof testResult === 'string' && testResult.match(/^#[0-9A-Fa-f]{6}$/)) {
                  funcStr = funcStr.replace(/\bzebraColorStr\b|\bzebraColor\b|\bbaseColor\b/g, `'${testResult}'`);
                }
              }
              // Para padding
              else if (funcStr.includes('padding')) {
                const testResult = obj(1, { table: { widths: ['*', '*'] } });
                if (typeof testResult === 'number') {
                  // Encontrar o nome da variável de padding no código
                  const paddingMatch = funcStr.match(/\b(paddingLeft|paddingRight|paddingTop|paddingBottom)\b/);
                  if (paddingMatch) {
                    funcStr = funcStr.replace(new RegExp(`\\b${paddingMatch[1]}\\b`, 'g'), testResult.toString());
                  }
                }
              }
              // Para lineWidth
              else if (funcStr.includes('LineWidth')) {
                const testResult = obj(1, { table: { body: [[], []], widths: ['*', '*'] } });
                if (typeof testResult === 'number') {
                  const lineWidthMatch = funcStr.match(/\b(hLineWidth|vLineWidth)\b/);
                  if (lineWidthMatch) {
                    funcStr = funcStr.replace(new RegExp(`\\b${lineWidthMatch[1]}\\b`, 'g'), testResult.toString());
                  }
                }
              }
              // Para lineColor
              else if (funcStr.includes('LineColor')) {
                const testResult = obj(1, {});
                if (typeof testResult === 'string') {
                  const lineColorMatch = funcStr.match(/\b(hLineColor|vLineColor)\b/);
                  if (lineColorMatch) {
                    funcStr = funcStr.replace(new RegExp(`\\b${lineColorMatch[1]}\\b`, 'g'), `'${testResult}'`);
                  }
                }
              }
            } catch (e) {
              // Ignorar erro - função pode não ser executável neste contexto
            }
          }

          // Substituição final: procurar padrões comuns de variáveis
          // Padrão: return (i % 2 === 0) ? zebraColorStr : null;
          const returnMatch = funcStr.match(/return\s*\([^)]+\)\s*\?\s*(\w+)\s*:/);
          if (returnMatch) {
            const varName = returnMatch[1];
            // Se ainda não foi substituído, tentar obter do mapeamento ou propriedade
            if (funcStr.includes(varName)) {
              const value = obj._zebraColor || functionVariableMap.get(currentPath)?.color || functionVariableMap.get(currentPath)?.value;
              if (value !== undefined) {
                const replacement = typeof value === 'string' ? `'${value}'` : value.toString();
                funcStr = funcStr.replace(new RegExp(`\\b${varName}\\b`, 'g'), replacement);
              }
            }
          }

          // Remover quebras de linha extras e formatar com indentação correta
          // Se a função foi criada com new Function(), ela já tem o formato correto
          // Se foi criada com function(), precisa ser formatada
          const lines = funcStr.split('\n').filter(line => line.trim() !== '');
          if (lines.length > 1) {
            // Função multi-linha - formatar com indentação
            let formatted = lines[0].trim() + '\n';
            for (let i = 1; i < lines.length - 1; i++) {
              const line = lines[i].trim();
              // Adicionar indentação extra para o corpo da função
              formatted += nextIndentStr + '  ' + line + '\n';
            }
            if (lines.length > 1) {
              formatted += nextIndentStr + lines[lines.length - 1].trim();
            }
            return formatted;
          }
          // Função de uma linha - manter como está
          return funcStr;
        }

        if (typeof obj === 'string') {
          // Escapar caracteres especiais e usar template literals se necessário
          if (obj.includes('${') || obj.includes('`')) {
            // Usar template literal
            const escaped = obj.replace(/\\/g, '\\\\').replace(/`/g, '\\`');
            return '`' + escaped + '`';
          }
          // Usar string normal
          const escaped = obj
            .replace(/\\/g, '\\\\')
            .replace(/'/g, "\\'")
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\t/g, '\\t');
          return `'${escaped}'`;
        }

        if (typeof obj === 'object' && obj !== null) {
          const keys = Object.keys(obj);
          if (keys.length === 0) return '{}';

          let result = '{\n';
          let validKeys = keys.filter(key => {
            // Filtrar propriedades internas e undefined
            if (key.startsWith('_')) return false;
            const value = obj[key];
            // Não incluir propriedades undefined (mas incluir null)
            if (value === undefined) return false;
            return true;
          });

          validKeys.forEach((key, idx) => {
            const value = obj[key];

            // Validar nome da chave (não pode começar com número ou ter caracteres especiais problemáticos)
            const safeKey = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : JSON.stringify(key);

            // Limpar widths se for array
            if (key === 'widths' && Array.isArray(value)) {
              const cleanedWidths = value.map(w => {
                if (typeof w === 'object' && w !== null) {
                  if (w.width !== undefined) return w.width;
                  return '*';
                }
                return w;
              });
              result += nextIndentStr + `${safeKey}: ${JSON.stringify(cleanedWidths)}`;
            } else {
              const newPath = currentPath ? `${currentPath}.${key}` : key;
              const serialized = serializeObject(value, nextIndent, false, newPath);
              result += nextIndentStr + `${safeKey}: ${serialized}`;
            }

            if (idx < validKeys.length - 1) result += ',';
            result += '\n';
          });
          result += indentStr + '}';
          return result;
        }

        // Números, booleanos, etc.
        return JSON.stringify(obj);
      }

      // Construir código completo com tudo dentro do objeto dd
      let code = 'const dd = ' + serializeObject(dd, 0, false, 'dd') + ';\n';

      codeEditor.textContent = code;

      // Salvar código gerado no localStorage
      try {
        localStorage.setItem(STORAGE_CODE_KEY, code);
      } catch (e) {
        console.warn('Erro ao salvar código no localStorage:', e);
      }
    }

    function copyCode() {
      const text = codeEditor.textContent || '';
      navigator.clipboard.writeText(text).then(() => {
        if (!copyBtn) return;
        copyBtn.classList.add('copied');
        copyBtn.textContent = '✅ Copiado';
        setTimeout(() => {
          copyBtn.classList.remove('copied');
          copyBtn.textContent = '📋 Copiar';
        }, 1200);
      });
    }
    window.copyCode = copyCode;

    // -----------------------
    // Tabs (editor/code) - already in layout
    // -----------------------
    function switchTab(tab) {
      const tabEditorBtn = document.getElementById('tabEditor');
      const tabPageBtn = document.getElementById('tabPage');
      const tabCodeBtn = document.getElementById('tabCode');
      const contentEditor = document.getElementById('tabContentEditor');
      const contentPage = document.getElementById('tabContentPage');
      const contentCode = document.getElementById('tabContentCode');

      // If trying to switch to 'code' tab and no elements exist, prevent it
      if (tab === 'code' && !hasAnyValidElements()) {
        showAlertModal('Aviso', 'Adicione pelo menos um elemento ao canvas para visualizar o código.');
        return; // Prevent tab switch
      }

      // Remover active de todos
      [tabEditorBtn, tabPageBtn, tabCodeBtn].forEach(btn => btn?.classList.remove('active'));
      [contentEditor, contentPage, contentCode].forEach(content => content?.classList.remove('active'));

      if (tab === 'code') {
        tabCodeBtn.classList.add('active');
        contentCode.classList.add('active');
        updateCode();
      } else if (tab === 'page') {
        tabPageBtn.classList.add('active');
        contentPage.classList.add('active');
        renderPageInspector();
      } else {
        tabEditorBtn.classList.add('active');
        contentEditor.classList.add('active');
      }
    }

    // Renderizar Page Inspector (combina TOC, Header/Footer e Watermark)
    function renderPageInspector() {
      const inspector = document.getElementById('pageInspector');
      if (!inspector) return;

      // Combinar os 3 conteúdos em uma única página
      inspector.innerHTML = `
        <!-- Seção 1: Índice (TOC) -->
        <div style="margin-bottom: 2rem;">
          <h3 style="margin-bottom: 1rem; font-size: 1.125rem; font-weight: 600; color: #2563eb;">📑 Índice (Table of Contents)</h3>
          <div class="inspector-field">
            <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
              <input type="checkbox" id="tocEnabled" ${documentTOC?.enabled ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
              <span>Habilitar Índice</span>
            </label>
            <div class="smallNote">Marque elementos como "TOC" no editor para incluí-los no índice</div>
          </div>
          <div id="tocOptions" style="${documentTOC?.enabled ? '' : 'display: none;'}">
            <div class="inspector-field">
              <label>Título do Índice</label>
              <input type="text" id="tocTitle" value="${escapeHtml(documentTOC?.title || 'Índice')}">
            </div>
            <div class="inspector-field">
              <div class="smallNote" style="padding: 0.75rem; background: #dbeafe; border-left: 3px solid #2563eb; margin-bottom: 1rem; border-radius: 0.25rem; color: #1e40af;">
                <strong>💡 Como usar:</strong><br>
                • Selecione um elemento (text, header) no canvas<br>
                • No editor, marque a opção "Incluir no Índice"<br>
                • O elemento aparecerá automaticamente no índice
              </div>
            </div>
          </div>
        </div>
        
        <!-- Separador -->
        <div style="margin: 2rem 0; border-top: 1px solid #e5e7eb;"></div>
        
        <!-- Seção 2: Header/Footer -->
        <div style="margin-bottom: 2rem;">
          <h3 style="margin-bottom: 1rem; font-size: 1.125rem; font-weight: 600; color: #2563eb;">📄 Cabeçalho e Rodapé</h3>
          
          <!-- Header Toggle -->
          <div class="inspector-field">
            <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
              <input type="checkbox" id="headerEnabled" ${documentHeader?.enabled ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
              <span>Ativar Cabeçalho</span>
            </label>
            <div class="smallNote">Quando ativado, uma área de cabeçalho aparecerá no topo do canvas. Arraste elementos para dentro dela.</div>
          </div>
          
          <div id="headerOptions" style="${documentHeader?.enabled ? '' : 'display: none;'}">
            <div class="inspector-field">
              <label class="smallNote">Altura Estimada (px)</label>
              <input type="number" id="headerHeight" value="${documentHeader?.height || 60}" min="20" max="200">
              <div class="smallNote">Usado para calcular as margens da página automaticamente</div>
            </div>
            <div class="inspector-field">
              <div class="smallNote" style="padding: 0.75rem; background: #dbeafe; border-left: 3px solid #2563eb; margin-bottom: 1rem; border-radius: 0.25rem; color: #1e40af;">
                <strong>💡 Dica:</strong> Arraste um elemento de texto para o cabeçalho e use <code>{{pageNumber}}</code> para número da página atual e <code>{{totalPages}}</code> para total de páginas. Exemplo: "Página {{pageNumber}} de {{totalPages}}"
              </div>
            </div>
            <div class="inspector-field">
              <button type="button" onclick="clearHeader()" style="width: 100%; padding: 0.75rem; background: #ef4444; color: white; border: none; border-radius: 0.375rem; cursor: pointer;">
                🗑️ Limpar Cabeçalho
              </button>
            </div>
          </div>
          
          <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid #e5e7eb;">
            <!-- Footer Toggle -->
            <div class="inspector-field">
              <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
                <input type="checkbox" id="footerEnabled" ${documentFooter?.enabled ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
                <span>Ativar Rodapé</span>
              </label>
              <div class="smallNote">Quando ativado, uma área de rodapé aparecerá na parte inferior do canvas. Arraste elementos para dentro dela.</div>
            </div>
            
            <div id="footerOptions" style="${documentFooter?.enabled ? '' : 'display: none;'}">
              <div class="inspector-field">
                <label class="smallNote">Altura Estimada (px)</label>
                <input type="number" id="footerHeight" value="${documentFooter?.height || 60}" min="20" max="200">
                <div class="smallNote">Usado para calcular as margens da página automaticamente</div>
              </div>
              <div class="inspector-field">
                <div class="smallNote" style="padding: 0.75rem; background: #dbeafe; border-left: 3px solid #2563eb; margin-bottom: 1rem; border-radius: 0.25rem; color: #1e40af;">
                  <strong>💡 Dica:</strong> Arraste um elemento de texto para o rodapé e use <code>{{pageNumber}}</code> para número da página atual e <code>{{totalPages}}</code> para total de páginas. Exemplo: "Página {{pageNumber}} de {{totalPages}}"
                </div>
              </div>
              <div class="inspector-field">
                <button type="button" onclick="clearFooter()" style="width: 100%; padding: 0.75rem; background: #ef4444; color: white; border: none; border-radius: 0.375rem; cursor: pointer;">
                  🗑️ Limpar Rodapé
                </button>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Separador -->
        <div style="margin: 2rem 0; border-top: 1px solid #e5e7eb;"></div>
        
        <!-- Seção 3: Watermark -->
        <div>
          <h3 style="margin-bottom: 1rem; font-size: 1.125rem; font-weight: 600; color: #2563eb;">💧 Marca d'Água (Watermark)</h3>
          <div class="inspector-field">
            <label>Texto da Marca d'Água</label>
            <input type="text" id="watermarkText" value="${escapeHtml(documentWatermark?.text || '')}" placeholder="Ex: CONFIDENCIAL">
            <div class="smallNote">Deixe vazio para desabilitar a marca d'água</div>
          </div>
          <div class="inspector-field">
            <div class="row">
              <div>
                <label class="smallNote">Tamanho da Fonte</label>
                <input type="number" id="watermarkFontSize" value="${documentWatermark?.fontSize || 48}" min="12" max="200">
              </div>
              <div>
                <label class="smallNote">Cor</label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <input type="color" id="watermarkColor" value="${documentWatermark?.color || '#cccccc'}" style="width: 50px; height: 32px; cursor: pointer;">
                  <input type="text" id="watermarkColorText" value="${documentWatermark?.color || '#cccccc'}" placeholder="#cccccc" style="flex: 1; font-size: 0.875rem;">
                </div>
              </div>
            </div>
          </div>
          <div class="inspector-field">
            <div class="row">
              <div>
                <label class="smallNote">Opacidade (0.0 - 1.0)</label>
                <input type="number" id="watermarkOpacity" value="${documentWatermark?.opacity || 0.3}" min="0" max="1" step="0.1">
              </div>
              <div>
                <label class="smallNote">Ângulo (graus)</label>
                <input type="number" id="watermarkAngle" value="${documentWatermark?.angle || -45}" min="-180" max="180" step="1">
              </div>
            </div>
          </div>
          <div class="inspector-field">
            <button type="button" onclick="clearWatermark()" style="width: 100%; padding: 0.75rem; background: #ef4444; color: white; border: none; border-radius: 0.375rem; cursor: pointer;">
              🗑️ Remover Marca d'Água
            </button>
          </div>
        </div>
        
        <!-- Separador -->
        <div style="margin: 2rem 0; border-top: 1px solid #e5e7eb;"></div>
        
        <!-- Seção 4: Security -->
        <div>
          <h3 style="margin-bottom: 1rem; font-size: 1.125rem; font-weight: 600; color: #2563eb;">🔒 Segurança do PDF</h3>
          <div class="inspector-field">
            <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
              <input type="checkbox" id="securityEnabled" ${documentSecurity?.enabled ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
              <span>Habilitar Proteção por Senha</span>
            </label>
            <div class="smallNote">Adicione senhas e permissões para proteger o PDF</div>
          </div>
          <div id="securityOptions" style="${documentSecurity?.enabled ? '' : 'display: none;'}">
            <div class="inspector-field">
              <label>Senha do Usuário</label>
              <input type="password" id="securityUserPassword" value="${escapeHtml(documentSecurity?.userPassword || '')}" placeholder="Senha para abrir o PDF">
              <div class="smallNote">Senha necessária para abrir e visualizar o PDF</div>
            </div>
            <div class="inspector-field">
              <label>Senha do Proprietário</label>
              <input type="password" id="securityOwnerPassword" value="${escapeHtml(documentSecurity?.ownerPassword || '')}" placeholder="Senha para modificar permissões">
              <div class="smallNote">Senha para modificar permissões (deixe vazio para usar a mesma senha do usuário)</div>
            </div>
            <div class="inspector-field">
              <label style="margin-bottom: 0.75rem; display: block; font-weight: 500;">Permissões</label>
              <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
                  <input type="checkbox" id="securityPrinting" ${documentSecurity?.permissions?.printing !== false ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
                  <span>Permitir Impressão</span>
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
                  <input type="checkbox" id="securityModifying" ${documentSecurity?.permissions?.modifying !== false ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
                  <span>Permitir Modificação</span>
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
                  <input type="checkbox" id="securityCopying" ${documentSecurity?.permissions?.copying !== false ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
                  <span>Permitir Cópia</span>
                </label>
                <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
                  <input type="checkbox" id="securityAnnotating" ${documentSecurity?.permissions?.annotating !== false ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
                  <span>Permitir Anotações</span>
                </label>
              </div>
            </div>
            <div class="inspector-field">
              <div class="smallNote" style="padding: 0.75rem; background: #fef3c7; border-left: 3px solid #f59e0b; margin-bottom: 1rem; border-radius: 0.25rem; color: #92400e;">
                <strong>⚠️ Aviso:</strong> As senhas não podem ser recuperadas. Certifique-se de guardá-las em local seguro.
              </div>
            </div>
          </div>
        </div>
        
        <!-- Separador -->
        <div style="margin: 2rem 0; border-top: 1px solid #e5e7eb;"></div>
        
        <!-- Seção 5: Metadados e Compressão -->
        <div>
          <h3 style="margin-bottom: 1rem; font-size: 1.125rem; font-weight: 600; color: #2563eb;">📋 Metadados do PDF</h3>
          <div class="inspector-field">
            <label>Autor</label>
            <input type="text" id="pageInfoAuthor" value="${escapeHtml(documentPageInfo?.author || '')}" placeholder="Nome do autor">
          </div>
          <div class="inspector-field">
            <label>Título</label>
            <input type="text" id="pageInfoTitle" value="${escapeHtml(documentPageInfo?.title || '')}" placeholder="Título do documento">
          </div>
          <div class="inspector-field">
            <label>Assunto</label>
            <input type="text" id="pageInfoSubject" value="${escapeHtml(documentPageInfo?.subject || '')}" placeholder="Assunto do documento">
          </div>
          <div class="inspector-field">
            <label>Palavras-chave</label>
            <input type="text" id="pageInfoKeywords" value="${escapeHtml(documentPageInfo?.keywords || '')}" placeholder="palavra1, palavra2, palavra3">
            <div class="smallNote">Separe múltiplas palavras-chave com vírgulas</div>
          </div>
          
          <div style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid #e5e7eb;">
            <h4 style="margin-bottom: 0.75rem; font-size: 1rem; font-weight: 500; color: #374151;">Compressão</h4>
            <div class="inspector-field">
              <label style="display: flex; align-items: center; gap: 0.5rem; font-weight: 500;">
                <input type="checkbox" id="pageCompress" ${documentCompress ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
                <span>Comprimir PDF</span>
              </label>
              <div class="smallNote">Reduz o tamanho do arquivo PDF gerado (pode aumentar o tempo de geração)</div>
            </div>
          </div>
        </div>
      `;

      // Attach todos os listeners
      attachTOCListeners();
      attachHeaderFooterListeners();
      attachWatermarkListeners();
      attachSecurityListeners();
      attachPageInfoListeners();
    }

    // Attach listeners para TOC
    function attachTOCListeners() {
      const tocEnabled = document.getElementById('tocEnabled');
      const tocTitle = document.getElementById('tocTitle');
      const tocOptions = document.getElementById('tocOptions');

      if (tocEnabled) {
        tocEnabled.addEventListener('change', () => {
          if (!documentTOC) documentTOC = {};
          documentTOC.enabled = tocEnabled.checked;
          if (tocOptions) tocOptions.style.display = documentTOC.enabled ? '' : 'none';
        });
      }

      if (tocTitle) {
        tocTitle.addEventListener('input', () => {
          if (!documentTOC) documentTOC = {};
          documentTOC.title = tocTitle.value.trim() || 'Índice';
        });
      }
    }

    // Attach listeners para Watermark (apenas texto)
    function attachWatermarkListeners() {
      const watermarkText = document.getElementById('watermarkText');
      const watermarkFontSize = document.getElementById('watermarkFontSize');
      const watermarkColor = document.getElementById('watermarkColor');
      const watermarkColorText = document.getElementById('watermarkColorText');
      const watermarkOpacity = document.getElementById('watermarkOpacity');
      const watermarkAngle = document.getElementById('watermarkAngle');

      if (watermarkText) {
        watermarkText.addEventListener('input', () => {
          const text = watermarkText.value.trim();
          if (text) {
            if (!documentWatermark) documentWatermark = {};
            documentWatermark.text = text;
          } else {
            documentWatermark = null;
          }
        });
      }

      if (watermarkFontSize) {
        watermarkFontSize.addEventListener('input', () => {
          if (!documentWatermark) documentWatermark = {};
          documentWatermark.fontSize = parseInt(watermarkFontSize.value) || 48;
        });
      }

      if (watermarkColor && watermarkColorText) {
        watermarkColor.addEventListener('input', () => {
          watermarkColorText.value = watermarkColor.value;
          if (!documentWatermark) documentWatermark = {};
          documentWatermark.color = watermarkColor.value;
        });
        watermarkColorText.addEventListener('input', () => {
          if (/^#[0-9A-F]{6}$/i.test(watermarkColorText.value)) {
            watermarkColor.value = watermarkColorText.value;
            if (!documentWatermark) documentWatermark = {};
            documentWatermark.color = watermarkColorText.value;
          }
        });
      }

      if (watermarkOpacity) {
        watermarkOpacity.addEventListener('input', () => {
          if (!documentWatermark) documentWatermark = {};
          documentWatermark.opacity = parseFloat(watermarkOpacity.value) || 0.3;
        });
      }

      if (watermarkAngle) {
        watermarkAngle.addEventListener('input', () => {
          if (!documentWatermark) documentWatermark = {};
          documentWatermark.angle = parseInt(watermarkAngle.value) || -45;
        });
      }
    }

    function clearWatermark() {
      documentWatermark = null;
      renderPageInspector();
    }
    window.clearWatermark = clearWatermark;

    // Attach listeners para Security
    function attachSecurityListeners() {
      const securityEnabled = document.getElementById('securityEnabled');
      const securityUserPassword = document.getElementById('securityUserPassword');
      const securityOwnerPassword = document.getElementById('securityOwnerPassword');
      const securityPrinting = document.getElementById('securityPrinting');
      const securityModifying = document.getElementById('securityModifying');
      const securityCopying = document.getElementById('securityCopying');
      const securityAnnotating = document.getElementById('securityAnnotating');
      const securityOptions = document.getElementById('securityOptions');

      if (securityEnabled) {
        securityEnabled.addEventListener('change', () => {
          if (!documentSecurity) documentSecurity = {};
          documentSecurity.enabled = securityEnabled.checked;
          if (securityOptions) securityOptions.style.display = documentSecurity.enabled ? '' : 'none';
          if (!documentSecurity.enabled) documentSecurity = null;
        });
      }

      if (securityUserPassword) {
        securityUserPassword.addEventListener('input', () => {
          if (!documentSecurity) documentSecurity = {};
          documentSecurity.userPassword = securityUserPassword.value;
          if (!documentSecurity.userPassword && !documentSecurity.ownerPassword) documentSecurity = null;
        });
      }

      if (securityOwnerPassword) {
        securityOwnerPassword.addEventListener('input', () => {
          if (!documentSecurity) documentSecurity = {};
          documentSecurity.ownerPassword = securityOwnerPassword.value;
        });
      }

      if (securityPrinting) {
        securityPrinting.addEventListener('change', () => {
          if (!documentSecurity) documentSecurity = {};
          if (!documentSecurity.permissions) documentSecurity.permissions = {};
          documentSecurity.permissions.printing = securityPrinting.checked;
        });
      }

      if (securityModifying) {
        securityModifying.addEventListener('change', () => {
          if (!documentSecurity) documentSecurity = {};
          if (!documentSecurity.permissions) documentSecurity.permissions = {};
          documentSecurity.permissions.modifying = securityModifying.checked;
        });
      }

      if (securityCopying) {
        securityCopying.addEventListener('change', () => {
          if (!documentSecurity) documentSecurity = {};
          if (!documentSecurity.permissions) documentSecurity.permissions = {};
          documentSecurity.permissions.copying = securityCopying.checked;
        });
      }

      if (securityAnnotating) {
        securityAnnotating.addEventListener('change', () => {
          if (!documentSecurity) documentSecurity = {};
          if (!documentSecurity.permissions) documentSecurity.permissions = {};
          documentSecurity.permissions.annotating = securityAnnotating.checked;
        });
      }
    }

    // Attach listeners para Page Info (Metadados) e Compress
    function attachPageInfoListeners() {
      const pageInfoAuthor = document.getElementById('pageInfoAuthor');
      const pageInfoTitle = document.getElementById('pageInfoTitle');
      const pageInfoSubject = document.getElementById('pageInfoSubject');
      const pageInfoKeywords = document.getElementById('pageInfoKeywords');
      const pageCompress = document.getElementById('pageCompress');

      if (pageInfoAuthor) {
        pageInfoAuthor.addEventListener('input', () => {
          if (!documentPageInfo) documentPageInfo = {};
          documentPageInfo.author = pageInfoAuthor.value.trim();
          if (!documentPageInfo.author && !documentPageInfo.title && !documentPageInfo.subject && !documentPageInfo.keywords) {
            documentPageInfo = null;
          }
        });
      }

      if (pageInfoTitle) {
        pageInfoTitle.addEventListener('input', () => {
          if (!documentPageInfo) documentPageInfo = {};
          documentPageInfo.title = pageInfoTitle.value.trim();
          if (!documentPageInfo.author && !documentPageInfo.title && !documentPageInfo.subject && !documentPageInfo.keywords) {
            documentPageInfo = null;
          }
        });
      }

      if (pageInfoSubject) {
        pageInfoSubject.addEventListener('input', () => {
          if (!documentPageInfo) documentPageInfo = {};
          documentPageInfo.subject = pageInfoSubject.value.trim();
          if (!documentPageInfo.author && !documentPageInfo.title && !documentPageInfo.subject && !documentPageInfo.keywords) {
            documentPageInfo = null;
          }
        });
      }

      if (pageInfoKeywords) {
        pageInfoKeywords.addEventListener('input', () => {
          if (!documentPageInfo) documentPageInfo = {};
          documentPageInfo.keywords = pageInfoKeywords.value.trim();
          if (!documentPageInfo.author && !documentPageInfo.title && !documentPageInfo.subject && !documentPageInfo.keywords) {
            documentPageInfo = null;
          }
        });
      }

      if (pageCompress) {
        pageCompress.addEventListener('change', () => {
          documentCompress = pageCompress.checked;
        });
      }
    }

    // Função antiga mantida para compatibilidade (não será mais usada)
    function renderHeaderFooterInspector() {
      const inspector = document.getElementById('headerFooterInspector');
      if (!inspector) return;

      inspector.innerHTML = `
        <h3 style="margin-bottom: 1rem; font-size: 1.125rem; font-weight: 600; color: #111827;">Cabeçalho da Página</h3>
        <div class="inspector-field">
          <label>Texto do Cabeçalho</label>
          <textarea id="headerText" placeholder="Ex: Título do Documento ou deixe vazio para desabilitar" style="min-height: 60px;">${escapeHtml(documentHeader?.text || '')}</textarea>
          <div class="smallNote">Use {{pageNumber}} para número da página atual e {{totalPages}} para total de páginas</div>
              </div>
        <div class="inspector-field">
          <div class="row">
            <div>
              <label class="smallNote">Tamanho da Fonte</label>
              <input type="number" id="headerFontSize" value="${documentHeader?.fontSize || 10}" min="6" max="24">
            </div>
            <div>
              <label class="smallNote">Alinhamento</label>
              <select id="headerAlignment">
                <option value="left" ${documentHeader?.alignment === 'left' ? 'selected' : ''}>Esquerda</option>
                <option value="center" ${documentHeader?.alignment === 'center' || !documentHeader ? 'selected' : ''}>Centro</option>
                <option value="right" ${documentHeader?.alignment === 'right' ? 'selected' : ''}>Direita</option>
              </select>
            </div>
          </div>
        </div>
        <div class="inspector-field">
          <label class="smallNote">Cor do Texto</label>
          <div style="display: flex; gap: 0.5rem; align-items: center;">
            <input type="color" id="headerColor" value="${documentHeader?.color || '#000000'}" style="width: 60px; height: 38px; cursor: pointer;">
            <input type="text" id="headerColorText" value="${documentHeader?.color || '#000000'}" placeholder="#000000" style="flex: 1;">
          </div>
        </div>
        
        <div style="margin-top: 2rem; padding-top: 1.5rem; border-top: 1px solid #e5e7eb;">
          <h3 style="margin-bottom: 1rem; font-size: 1.125rem; font-weight: 600; color: #111827;">Rodapé da Página</h3>
          <div class="inspector-field">
            <label>Texto do Rodapé</label>
            <textarea id="footerText" placeholder="Ex: Página {{pageNumber}} de {{totalPages}} ou deixe vazio para desabilitar" style="min-height: 60px;">${escapeHtml(documentFooter?.text || '')}</textarea>
            <div class="smallNote">Use {{pageNumber}} para número da página atual e {{totalPages}} para total de páginas</div>
          </div>
          <div class="inspector-field">
            <div class="row">
              <div>
                <label class="smallNote">Tamanho da Fonte</label>
                <input type="number" id="footerFontSize" value="${documentFooter?.fontSize || 10}" min="6" max="24">
              </div>
              <div>
                <label class="smallNote">Alinhamento</label>
                <select id="footerAlignment">
                  <option value="left" ${documentFooter?.alignment === 'left' ? 'selected' : ''}>Esquerda</option>
                  <option value="center" ${documentFooter?.alignment === 'center' || !documentFooter ? 'selected' : ''}>Centro</option>
                  <option value="right" ${documentFooter?.alignment === 'right' ? 'selected' : ''}>Direita</option>
                </select>
              </div>
            </div>
          </div>
          <div class="inspector-field">
            <label class="smallNote">Cor do Texto</label>
            <div style="display: flex; gap: 0.5rem; align-items: center;">
              <input type="color" id="footerColor" value="${documentFooter?.color || '#000000'}" style="width: 60px; height: 38px; cursor: pointer;">
              <input type="text" id="footerColorText" value="${documentFooter?.color || '#000000'}" placeholder="#000000" style="flex: 1;">
            </div>
              </div>
            </div>
          `;

      // Attach listeners após renderizar
      attachHeaderFooterListeners();
    }

    // Attach listeners para Header/Footer
    function attachHeaderFooterListeners() {
      // Header Toggle
      const headerEnabled = document.getElementById('headerEnabled');
      const headerHeight = document.getElementById('headerHeight');
      const headerOptions = document.getElementById('headerOptions');

      if (headerEnabled) {
        headerEnabled.addEventListener('change', () => {
          documentHeader.enabled = headerEnabled.checked;
          if (!documentHeader.root) {
            documentHeader.root = createHeaderFooterRoot();
          }
          if (headerOptions) {
            headerOptions.style.display = documentHeader.enabled ? '' : 'none';
          }
          adjustPageMargins();
          renderAll();
          saveState();
        });
      }

      if (headerHeight) {
        headerHeight.addEventListener('input', () => {
          documentHeader.height = parseInt(headerHeight.value) || 60;
          adjustPageMargins();
        });
      }

      // Footer Toggle
      const footerEnabled = document.getElementById('footerEnabled');
      const footerHeight = document.getElementById('footerHeight');
      const footerOptions = document.getElementById('footerOptions');

      if (footerEnabled) {
        footerEnabled.addEventListener('change', () => {
          documentFooter.enabled = footerEnabled.checked;
          if (!documentFooter.root) {
            documentFooter.root = createHeaderFooterRoot();
          }
          if (footerOptions) {
            footerOptions.style.display = documentFooter.enabled ? '' : 'none';
          }
          adjustPageMargins();
          renderAll();
          saveState();
        });
      }

      if (footerHeight) {
        footerHeight.addEventListener('input', () => {
          documentFooter.height = parseInt(footerHeight.value) || 60;
          adjustPageMargins();
        });
      }
    }

    // Funções para limpar header/footer
    function clearHeader() {
      showConfirmModal(
        'Limpar Cabeçalho',
        'Tem certeza que deseja limpar todo o conteúdo do cabeçalho?',
        () => {
          documentHeader.root = createHeaderFooterRoot();
          renderAll();
          saveState();
        }
      );
    }
    window.clearHeader = clearHeader;

    function clearFooter() {
      showConfirmModal(
        'Limpar Rodapé',
        'Tem certeza que deseja limpar todo o conteúdo do rodapé?',
        () => {
          documentFooter.root = createHeaderFooterRoot();
          renderAll();
          saveState();
        }
      );
    }
    window.clearFooter = clearFooter;

    // Ajustar pageMargins baseado na altura do header/footer
    function adjustPageMargins() {
      const minTopMargin = documentHeader.enabled ? documentHeader.height + 20 : 60;
      const minBottomMargin = documentFooter.enabled ? documentFooter.height + 20 : 60;

      // Ajustar apenas se necessário
      if (pageMargins[1] < minTopMargin) {
        pageMargins[1] = minTopMargin;
        if (mT) mT.value = minTopMargin;
      }
      if (pageMargins[3] < minBottomMargin) {
        pageMargins[3] = minBottomMargin;
        if (mB) mB.value = minBottomMargin;
      }
    }
    window.switchTab = switchTab;

    // -----------------------
    // UI bindings
    // -----------------------
    // Função para contar elementos válidos (grupos vazios não contam, mas grupos com elementos dentro contam)
    function countValidElements(el) {
      if (!el) return 0;

      // Se não é grupo, conta como 1 elemento válido
      if (el.type !== 'group') {
        return 1;
      }

      // Se é grupo, verifica se tem filhos válidos
      const children = el.properties?.children || [];
      if (children.length === 0) {
        return 0; // Grupo vazio não conta
      }

      // Conta elementos válidos dentro do grupo
      let count = 0;
      for (const child of children) {
        count += countValidElements(child);
      }

      return count;
    }

    // NEW FUNCTION: Check if any valid element exists in the canvas (main, header, or footer)
    function hasAnyValidElements() {
      const rootGroup = getRootGroup();
      let totalValidElements = 0;

      // Contar elementos do grupo raiz
      if (rootGroup) {
        totalValidElements += countValidElements(rootGroup);
      }

      // Contar elementos do header (apenas se estiver habilitado)
      if (documentHeader.enabled && documentHeader.root) {
        const headerChildren = documentHeader.root.properties?.children || [];
        for (const child of headerChildren) {
          totalValidElements += countValidElements(child);
        }
      }

      // Contar elementos do footer (apenas se estiver habilitado)
      if (documentFooter.enabled && documentFooter.root) {
        const footerChildren = documentFooter.root.properties?.children || [];
        for (const child of footerChildren) {
          totalValidElements += countValidElements(child);
        }
      }

      return totalValidElements > 0;
    }

    // Função para atualizar visibilidade do botão de pré-visualizar
    function updatePreviewButtonVisibility() {
      const bubbleTestBtn = document.getElementById('bubbleTestBtn');
      if (!bubbleTestBtn) return;

      if (hasAnyValidElements()) {
        bubbleTestBtn.style.display = 'inline-flex';
        bubbleTestBtn.style.alignItems = 'center';
        bubbleTestBtn.style.justifyContent = 'center';
        bubbleTestBtn.style.gap = '0.5rem';
      } else {
        bubbleTestBtn.style.display = 'none';
      }
    }

    // Função para atualizar visibilidade da aba de código
    function updateCodeTabVisibility() {
      const tabCodeBtn = document.getElementById('tabCode');
      const tabContentCode = document.getElementById('tabContentCode');
      if (!tabCodeBtn || !tabContentCode) return;

      const hasElements = hasAnyValidElements();
      
      tabCodeBtn.style.display = hasElements ? 'flex' : 'none';
      // Se a aba de código estiver ativa e não houver elementos, mudar para a aba Editor
      if (!hasElements && tabCodeBtn.classList.contains('active')) {
        switchTab('editor'); // Force switch to editor if no elements
      }
    }

    // Função para atualizar visibilidade dos botões "Salvar Template" e "Limpar"
    function updateSaveTemplateButtonVisibility() {
      const hasElements = hasAnyValidElements();

      if (saveTemplateBtn) {
        saveTemplateBtn.style.display = hasElements ? 'block' : 'none';
      }
      if (clearBtn) {
        clearBtn.style.display = hasElements ? 'block' : 'none';
      }

      // Atualizar também o botão de pré-visualizar
      updatePreviewButtonVisibility();
      // NEW: Update code tab visibility
      updateCodeTabVisibility();
    }

    function renderAll(shouldAdjustSize = true) {
      // mantém selected id válido
      if (selectedElementId && !findNodeById(selectedElementId)) {
        selectedElementId = getRootGroup() ? getRootGroup().id : null;
      }
      // IMPORTANTE: Não ajustar tamanho do canvas durante edições de propriedades
      // Isso evita crescimento infinito ao editar elementos
      renderCanvas(shouldAdjustSize);
      renderInspector();
      // Código será gerado apenas quando usuário solicitar na aba de código
      // Atualizar visibilidade dos botões
      updateSaveTemplateButtonVisibility();
      // Salvar estado automaticamente após renderizar
      saveState();
    }

    function clearAll() {
      // Limpar elementos principais
      elements = [];
      // Atualizar visibilidade dos botões
      updatePreviewButtonVisibility();
      // Atualizar visibilidade da aba de código
      updateCodeTabVisibility();
      selectedElementId = null;

      // Limpar header/footer
      if (documentHeader.root) {
        documentHeader.root.properties.children = [];
      }
      if (documentFooter.root) {
        documentFooter.root.properties.children = [];
      }
      documentHeader.enabled = false;
      documentFooter.enabled = false;

      // Resetar template atual (ao limpar, não há mais template carregado)
      currentTemplateId = null;

      // Limpar estado salvo também
      clearSavedState();

      // Atualizar UI
      if (pageSizeSel) pageSizeSel.value = 'A4';
      if (orientationSel) orientationSel.value = 'portrait';
      if (mL) mL.value = 40;
      if (mT) mT.value = 60;
      if (mR) mR.value = 40;
      if (mB) mB.value = 60;
      pageSize = 'A4';
      orientation = 'portrait';
      pageMargins = [40, 60, 40, 60];

      renderAll();
    }

    // Page settings binds
    pageSizeSel.addEventListener('change', () => { pageSize = pageSizeSel.value; renderAll(); });
    orientationSel.addEventListener('change', () => { orientation = orientationSel.value; renderAll(); });

    function updateMargins() {
      pageMargins = [
        Number(mL.value || 0),
        Number(mT.value || 0),
        Number(mR.value || 0),
        Number(mB.value || 0),
      ];
      renderAll();
    }
    [mL, mT, mR, mB].forEach(inp => inp.addEventListener('input', updateMargins));

    // zoom
    zoomRange.addEventListener('input', () => {
      const val = Number(zoomRange.value || 100);
      zoomLabel.textContent = val + '%';
      zoom = val / 100;
      applyZoom();
    });

    // Botões de zoom (+ e -)
    const zoomDecrease = document.getElementById('zoomDecrease');
    const zoomIncrease = document.getElementById('zoomIncrease');

    function updateZoom(value) {
      const clampedValue = Math.max(55, Math.min(140, value));
      zoomRange.value = clampedValue;
      zoomLabel.textContent = clampedValue + '%';
      zoom = clampedValue / 100;
      applyZoom();
    }

    if (zoomDecrease) {
      zoomDecrease.addEventListener('click', () => {
        const currentVal = Number(zoomRange.value || 100);
        updateZoom(currentVal - 5); // Diminuir em 5%
      });
    }

    if (zoomIncrease) {
      zoomIncrease.addEventListener('click', () => {
        const currentVal = Number(zoomRange.value || 100);
        updateZoom(currentVal + 5); // Aumentar em 5%
      });
    }

    /*

    previewBtn.addEventListener('click', () => {
      const dd = buildDocDefinition();
      const pdfDoc = pdfMake.createPdf(dd);
      
      // Gerar PDF como blob e exibir no modal
      pdfDoc.getBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const previewModal = document.getElementById('previewModal');
        const previewIframe = document.getElementById('previewIframe');
        
        if (previewIframe) {
          previewIframe.src = url;
        }
        
        if (previewModal) {
          previewModal.classList.add('active');
        }
      });
    }); */

    const BUBBLE_URL = "https://mentions-20237.bubbleapps.io/version-test/preview_pdf";

    function getCodToSend() {
      return (codeEditor.value ?? codeEditor.textContent ?? "").trim();
    }

    bubbleTestBtn.addEventListener("click", () => {
      const bubbleIframe = document.getElementById("bubbleTestIframe");
      const bubbleModal = document.getElementById("bubbleTestModal");

      bubbleModal.classList.add("active");
      bubbleIframe.src = BUBBLE_URL;

      bubbleIframe.onload = () => {
        const cod = getCodToSend();
        const origin = new URL(bubbleIframe.src).origin;

        bubbleIframe.contentWindow.postMessage({ type: "SET_COD", cod }, origin);
      };
    });


    clearBtn.addEventListener('click', () => {
      clearAll();
    });

    // Sistema de Templates
    const TEMPLATE_STORAGE_KEY = 'pdf_editor_templates';

    function saveTemplate() {
      // Se há um template carregado, atualizar diretamente sem mostrar modal
      if (currentTemplateId) {
        // Buscar nome do template atual para usar na atualização
        confirmSaveTemplate();
        return;
      }

      // Caso contrário, mostrar modal para criar novo template
      const modal = document.getElementById('saveTemplateModal');
      const input = document.getElementById('saveTemplateNameInput');
      const errorDiv = document.getElementById('saveTemplateError');

      if (modal && input) {
        input.value = '';
        errorDiv.style.display = 'none';
        modal.classList.add('active');
        input.focus();

        // Permitir salvar com Enter
        input.addEventListener('keypress', function (e) {
          if (e.key === 'Enter') {
            confirmSaveTemplate();
          }
        });
      }
    }
    window.saveTemplate = saveTemplate;

    async function confirmSaveTemplate() {
      const input = document.getElementById('saveTemplateNameInput');
      const errorDiv = document.getElementById('saveTemplateError');
      let templateName;

      // Verificar se usuário está autenticado
      if (!currentUser || !currentProfile || !currentInstallation) {
        if (errorDiv) {
          errorDiv.textContent = 'Você precisa estar logado para salvar templates.';
          errorDiv.style.display = 'block';
        }
        return;
      }

      if (currentTemplateId) {
        // Atualizar template existente - buscar nome atual do template
        try {
          const { data: template, error: fetchError } = await supabaseClient
            .from('template')
            .select('name')
            .eq('id', currentTemplateId)
            .eq('id_profile', currentProfile.id)
            .eq('id_installation', currentInstallation.id)
            .single();

          if (fetchError) {
            throw fetchError;
          }

          templateName = template.name;
        } catch (e) {
          console.error('Erro ao buscar template:', e);
          if (errorDiv) {
            errorDiv.textContent = 'Erro ao buscar template: ' + (e.message || e);
            errorDiv.style.display = 'block';
          }
          return;
        }
      } else {
        // Criar novo template - precisa do nome do input
        templateName = input?.value.trim();
        if (!templateName) {
          if (errorDiv) {
            errorDiv.textContent = 'Por favor, digite um nome para o template.';
            errorDiv.style.display = 'block';
          }
          return;
        }
      }

      try {
        const rootGroup = getRootGroup();
        const templateData = {
          name: templateName,
          rootGroup: rootGroup ? JSON.parse(JSON.stringify(rootGroup)) : null,
          documentHeader: documentHeader ? JSON.parse(JSON.stringify(documentHeader)) : null,
          documentFooter: documentFooter ? JSON.parse(JSON.stringify(documentFooter)) : null,
          documentWatermark: documentWatermark ? JSON.parse(JSON.stringify(documentWatermark)) : null,
          documentTOC: documentTOC ? JSON.parse(JSON.stringify(documentTOC)) : null,
          documentSecurity: documentSecurity ? JSON.parse(JSON.stringify(documentSecurity)) : null,
          documentPageInfo: documentPageInfo ? JSON.parse(JSON.stringify(documentPageInfo)) : null,
          documentCompress: documentCompress,
          pageSize: pageSizeSel?.value || 'A4',
          orientation: document.getElementById('orientation')?.value || 'portrait',
          margins: [
            parseInt(document.getElementById('mL')?.value || 40),
            parseInt(document.getElementById('mT')?.value || 60),
            parseInt(document.getElementById('mR')?.value || 40),
            parseInt(document.getElementById('mB')?.value || 60)
          ]
        };

        // Converter template para JSON string (campo cod no Supabase)
        const cod = JSON.stringify(templateData);

        if (currentTemplateId) {
          // Atualizar template existente
          const { data, error } = await supabaseClient
            .from('template')
            .update({
              cod: cod,
              updated_at: new Date().toISOString()
            })
            .eq('id', currentTemplateId)
            .eq('id_profile', currentProfile.id)
            .eq('id_installation', currentInstallation.id);

          if (error) {
            throw error;
          }

          closeSaveTemplateModal();

          if (typeof showAlertModal === 'function') {
            showAlertModal('Sucesso', `Template "${templateName}" atualizado com sucesso!`);
          }
        } else {
          // Criar novo template
          const { data, error } = await supabaseClient
            .from('template')
            .insert({
              id_profile: currentProfile.id,
              id_installation: currentInstallation.id,
              name: templateName,
              cod: cod
            })
            .select()
            .single();

          if (error) {
            throw error;
          }

          // Salvar ID do template criado
          currentTemplateId = data.id;

          closeSaveTemplateModal();

          if (typeof showAlertModal === 'function') {
            showAlertModal('Sucesso', `Template "${templateName}" salvo com sucesso!`);
          }
        }
      } catch (e) {
        console.error('Erro ao salvar template:', e);
        if (errorDiv) {
          errorDiv.textContent = 'Erro ao salvar template: ' + (e.message || e);
          errorDiv.style.display = 'block';
        }
      }
    }
    window.confirmSaveTemplate = confirmSaveTemplate;

    function closeSaveTemplateModal() {
      const modal = document.getElementById('saveTemplateModal');
      if (modal) {
        modal.classList.remove('active');
      }
    }
    window.closeSaveTemplateModal = closeSaveTemplateModal;

    async function loadTemplate() {
      const modal = document.getElementById('loadTemplateModal');
      const listDiv = document.getElementById('loadTemplateList');
      const emptyDiv = document.getElementById('loadTemplateEmpty');

      if (!modal || !listDiv) return;

      // Verificar se usuário está autenticado
      if (!currentUser || !currentProfile || !currentInstallation) {
        if (typeof showAlertModal === 'function') {
          showAlertModal('Erro', 'Você precisa estar logado para carregar templates.');
        }
        return;
      }

      try {
        // Buscar templates do Supabase
        const { data: templates, error } = await supabaseClient
          .from('template')
          .select('*')
          .eq('id_profile', currentProfile.id)
          .eq('id_installation', currentInstallation.id)
          .order('updated_at', { ascending: false });

        if (error) {
          throw error;
        }

        if (!templates || templates.length === 0) {
          if (emptyDiv) emptyDiv.style.display = 'block';
          if (listDiv) listDiv.style.display = 'none';
          modal.classList.add('active');
          return;
        }

        // Criar lista de templates
        listDiv.innerHTML = '';
        templates.forEach((template) => {
          const templateItem = document.createElement('div');
          templateItem.style.cssText = 'padding: 1rem; margin-bottom: 0.5rem; border: 1px solid #e5e7eb; border-radius: 0.5rem; cursor: pointer; transition: background 0.2s;';
          templateItem.onmouseenter = () => templateItem.style.background = '#f3f4f6';
          templateItem.onmouseleave = () => templateItem.style.background = 'white';

          const nameDiv = document.createElement('div');
          nameDiv.style.cssText = 'font-weight: 600; color: #111827; margin-bottom: 0.25rem;';
          nameDiv.textContent = template.name;

          const dateDiv = document.createElement('div');
          dateDiv.style.cssText = 'font-size: 0.875rem; color: #6b7280; margin-bottom: 0.5rem;';
          dateDiv.textContent = `Atualizado em: ${new Date(template.updated_at).toLocaleString('pt-BR')}`;

          const buttonDiv = document.createElement('div');
          buttonDiv.style.cssText = 'display: flex; gap: 0.5rem;';

          const loadBtn = document.createElement('button');
          loadBtn.textContent = '📂 Carregar';
          loadBtn.style.cssText = 'flex: 1; padding: 0.5rem; background: #2563eb; color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-size: 0.875rem;';
          loadBtn.onclick = (e) => {
            e.stopPropagation();
            loadTemplateConfirm(template);
          };

          const deleteBtn = document.createElement('button');
          deleteBtn.textContent = '🗑️ Deletar';
          deleteBtn.style.cssText = 'flex: 1; padding: 0.5rem; background: #ef4444; color: white; border: none; border-radius: 0.375rem; cursor: pointer; font-size: 0.875rem;';
          deleteBtn.onclick = (e) => {
            e.stopPropagation();
            e.preventDefault();
            if (typeof deleteTemplate === 'function') {
              deleteTemplate(template.id, template.name);
            } else {
              console.error('deleteTemplate não está disponível');
            }
          };

          buttonDiv.appendChild(loadBtn);
          buttonDiv.appendChild(deleteBtn);

          templateItem.appendChild(nameDiv);
          templateItem.appendChild(dateDiv);
          templateItem.appendChild(buttonDiv);

          listDiv.appendChild(templateItem);
        });

        if (emptyDiv) emptyDiv.style.display = 'none';
        if (listDiv) listDiv.style.display = 'block';
        modal.classList.add('active');
      } catch (e) {
        console.error('Erro ao carregar templates:', e);
        if (typeof showAlertModal === 'function') {
          showAlertModal('Erro', 'Erro ao carregar templates: ' + e.message);
        }
      }
    }
    window.loadTemplate = loadTemplate;

    function loadTemplateConfirm(template) {
      // Fechar modal de templates primeiro
      closeLoadTemplateModal();

      // Salvar ID do template carregado para atualização posterior
      currentTemplateId = template.id;

      // Função para carregar o template
      const doLoadTemplate = () => {
        try {
          // Parsear o campo cod que contém o JSON do template
          let templateData;
          if (typeof template.cod === 'string') {
            templateData = JSON.parse(template.cod);
          } else {
            templateData = template.cod || {};
          }

          // Carregar template - fazer deep copy para evitar referências
          if (templateData.rootGroup) {
            const rootGroupCopy = JSON.parse(JSON.stringify(templateData.rootGroup));
            elements = [rootGroupCopy];
          } else {
            elements = [];
          }

          // Fazer deep copy de todos os objetos para evitar referências
          if (templateData.documentHeader) {
            documentHeader = JSON.parse(JSON.stringify(templateData.documentHeader));
            if (!documentHeader.root) {
              documentHeader.root = createHeaderFooterRoot();
            }
          } else {
            documentHeader = { enabled: false, root: createHeaderFooterRoot() };
          }

          if (templateData.documentFooter) {
            documentFooter = JSON.parse(JSON.stringify(templateData.documentFooter));
            if (!documentFooter.root) {
              documentFooter.root = createHeaderFooterRoot();
            }
          } else {
            documentFooter = { enabled: false, root: createHeaderFooterRoot() };
          }

          documentWatermark = templateData.documentWatermark ? JSON.parse(JSON.stringify(templateData.documentWatermark)) : null;
          documentTOC = templateData.documentTOC ? JSON.parse(JSON.stringify(templateData.documentTOC)) : null;
          documentSecurity = templateData.documentSecurity ? JSON.parse(JSON.stringify(templateData.documentSecurity)) : null;
          documentPageInfo = templateData.documentPageInfo ? JSON.parse(JSON.stringify(templateData.documentPageInfo)) : null;
          documentCompress = templateData.documentCompress || false;

          // Atualizar UI
          if (pageSizeSel && templateData.pageSize) {
            pageSizeSel.value = templateData.pageSize;
          }
          const orientationSel = document.getElementById('orientation');
          if (orientationSel && templateData.orientation) {
            orientationSel.value = templateData.orientation;
          }
          if (templateData.margins && Array.isArray(templateData.margins)) {
            const mL = document.getElementById('mL');
            const mT = document.getElementById('mT');
            const mR = document.getElementById('mR');
            const mB = document.getElementById('mB');
            if (mL) mL.value = templateData.margins[0] || 40;
            if (mT) mT.value = templateData.margins[1] || 60;
            if (mR) mR.value = templateData.margins[2] || 40;
            if (mB) mB.value = templateData.margins[3] || 60;
          }

          selectedElementId = null;

          // Atualizar renderização após um pequeno delay para garantir que o DOM está pronto
          setTimeout(() => {
            if (typeof renderAll === 'function') {
              renderAll();
            }
            if (typeof renderInspector === 'function') {
              renderInspector();
            }
            if (typeof renderPageInspector === 'function') {
              renderPageInspector();
            }
            // Código será gerado apenas quando usuário solicitar na aba de código
            if (typeof saveState === 'function') {
              saveState();
            }

            if (typeof showAlertModal === 'function') {
              showAlertModal('Sucesso', `Template "${template.name}" carregado com sucesso!`);
            }
            // Atualizar visibilidade do botão "Salvar Template"
            if (typeof updateSaveTemplateButtonVisibility === 'function') {
              updateSaveTemplateButtonVisibility();
            }
          }, 100);
        } catch (e) {
          console.error('Erro ao carregar template:', e);
          if (typeof showAlertModal === 'function') {
            showAlertModal('Erro', 'Erro ao carregar template: ' + e.message);
          }
        }
      };

      if (typeof showConfirmModal === 'function') {
        showConfirmModal(
          'Carregar Template',
          `Carregar template "${template.name}"? Isso substituirá o conteúdo atual.`,
          doLoadTemplate
        );
      } else {
        // Se não houver modal de confirmação, carregar diretamente
        doLoadTemplate();
      }
    }

    async function deleteTemplate(templateId, templateName) {
      try {
        // Verificar se usuário está autenticado
        if (!currentUser || !currentProfile || !currentInstallation) {
          if (typeof showAlertModal === 'function') {
            showAlertModal('Erro', 'Você precisa estar logado para deletar templates.');
          }
          return;
        }

        // Fechar o modal de templates antes de abrir o modal de confirmação
        if (typeof closeLoadTemplateModal === 'function') {
          closeLoadTemplateModal();
        }

        if (typeof showConfirmModal === 'function') {
          // Pequeno delay para garantir que o modal anterior foi fechado
          setTimeout(() => {
            showConfirmModal(
              'Deletar Template',
              `Tem certeza que deseja deletar o template "${templateName}"?`,
              async () => {
                try {
                  // Deletar do Supabase
                  const { error } = await supabaseClient
                    .from('template')
                    .delete()
                    .eq('id', templateId)
                    .eq('id_profile', currentProfile.id)
                    .eq('id_installation', currentInstallation.id);

                  if (error) {
                    throw error;
                  }

                  // Se o template deletado era o atual, limpar currentTemplateId
                  if (currentTemplateId === templateId) {
                    currentTemplateId = null;
                  }

                  // Recarregar lista
                  await loadTemplate();

                  if (typeof showAlertModal === 'function') {
                    showAlertModal('Sucesso', `Template "${templateName}" deletado com sucesso!`);
                  }
                } catch (e) {
                  console.error('Erro ao deletar template:', e);
                  if (typeof showAlertModal === 'function') {
                    showAlertModal('Erro', 'Erro ao deletar template: ' + (e.message || e));
                  }
                }
              }
            );
          }, 100);
        } else {
          // Fallback se showConfirmModal não estiver disponível
          if (confirm(`Tem certeza que deseja deletar o template "${templateName}"?`)) {
            try {
              // Deletar do Supabase
              const { error } = await supabaseClient
                .from('template')
                .delete()
                .eq('id', templateId)
                .eq('id_profile', currentProfile.id)
                .eq('id_installation', currentInstallation.id);

              if (error) {
                throw error;
              }

              // Se o template deletado era o atual, limpar currentTemplateId
              if (currentTemplateId === templateId) {
                currentTemplateId = null;
              }

              // Recarregar lista
              await loadTemplate();

              if (typeof showAlertModal === 'function') {
                showAlertModal('Sucesso', `Template "${templateName}" deletado com sucesso!`);
              }
            } catch (e) {
              console.error('Erro ao deletar template:', e);
              if (typeof showAlertModal === 'function') {
                showAlertModal('Erro', 'Erro ao deletar template: ' + (e.message || e));
              }
            }
          }
        }
      } catch (e) {
        console.error('Erro ao deletar template:', e);
        if (typeof showAlertModal === 'function') {
          showAlertModal('Erro', 'Erro ao deletar template: ' + (e.message || e));
        }
      }
    }
    window.deleteTemplate = deleteTemplate; // Tornar global

    function closeLoadTemplateModal() {
      const modal = document.getElementById('loadTemplateModal');
      if (modal) {
        modal.classList.remove('active');
      }
    }
    window.closeLoadTemplateModal = closeLoadTemplateModal;

    const loadTemplateBtn = document.getElementById('loadTemplateBtn');
    if (saveTemplateBtn) {
      saveTemplateBtn.addEventListener('click', saveTemplate);
    }
    if (loadTemplateBtn) {
      loadTemplateBtn.addEventListener('click', loadTemplate);
    }

    // copy in code tab
    if (copyBtn) copyBtn.addEventListener('click', copyCode);

    // Canvas click to deselect
    canvas.addEventListener('click', (e) => {
      if (e.target === canvas || e.target === elementsList || e.target === canvasEmpty) {
        const rootGroup = getRootGroup();
        const newSelectedId = rootGroup ? rootGroup.id : null;

        // Evitar re-renderização desnecessária se já está selecionado
        if (selectedElementId === newSelectedId) {
          return;
        }

        // IMPORTANTE: Usar selectElement() que não recria o DOM, apenas atualiza seleção visual
        // Isso evita crescimento infinito ao clicar no canvas
        if (newSelectedId) {
          selectElement(newSelectedId);
        } else {
          // Desselecionar tudo sem recriar DOM
          const prevSelected = selectedElementId ? document.querySelector(`[data-id="${selectedElementId}"]`) : null;
          if (prevSelected) {
            prevSelected.classList.remove('selected');
          }
          selectedElementId = null;
          renderInspector();
          // Código será gerado apenas quando usuário solicitar na aba de código
        }
      }
    });

    // -----------------------
    // Funções de Autenticação Supabase
    // -----------------------

    async function checkAuth() {
      if (!supabaseClient) {
        initSupabase();
        return;
      }

      try {
        const { data: { session }, error } = await supabaseClient.auth.getSession();

        if (error) {
          console.error('Erro ao verificar sessão:', error);
          showLoginModal();
          return;
        }

        if (session && session.user) {
          currentUser = session.user;
          await loadUserProfile();
          hideLoginModal();
        } else {
          showLoginModal();
        }
      } catch (error) {
        console.error('Erro ao verificar autenticação:', error);
        showLoginModal();
      }
    }

    async function loadUserProfile() {
      if (!currentUser) return;

      try {
        // Buscar ou criar profile
        let { data: profile, error } = await supabaseClient
          .from('profile')
          .select('*')
          .eq('user_id', currentUser.id)
          .single();

        if (error && error.code === 'PGRST116') {
          // Profile não existe, criar um novo
          const { data: newProfile, error: createError } = await supabaseClient
            .from('profile')
            .insert({
              user_id: currentUser.id,
              email: currentUser.email,
              full_name: currentUser.email?.split('@')[0] || 'Usuário'
            })
            .select()
            .single();

          if (createError) {
            console.error('Erro ao criar profile:', createError);
            return;
          }

          currentProfile = newProfile;
        } else if (error) {
          console.error('Erro ao carregar profile:', error);
          return;
        } else {
          currentProfile = profile;
        }

        // Buscar ou criar installation (usando app_id padrão por enquanto)
        // Você pode ajustar isso conforme necessário
        const appId = 'default_app';
        let { data: installation, error: instError } = await supabaseClient
          .from('installation')
          .select('*')
          .eq('id_profile', currentProfile.id)
          .eq('app_id', appId)
          .eq('status', 'active')
          .single();

        if (instError && instError.code === 'PGRST116') {
          // Installation não existe, criar uma nova
          const { data: newInstallation, error: createInstError } = await supabaseClient
            .from('installation')
            .insert({
              id_profile: currentProfile.id,
              app_id: appId,
              access_token: 'default_token', // Você pode ajustar isso
              status: 'active'
            })
            .select()
            .single();

          if (createInstError) {
            console.error('Erro ao criar installation:', createInstError);
            return;
          }

          currentInstallation = newInstallation;
        } else if (instError) {
          console.error('Erro ao carregar installation:', instError);
          return;
        } else {
          currentInstallation = installation;
        }
      } catch (error) {
        console.error('Erro ao carregar dados do usuário:', error);
      }
    }

    function showLoginModal() {
      const modal = document.getElementById('loginModal');
      if (modal) {
        modal.classList.add('active');
        const emailInput = document.getElementById('loginEmailInput');
        if (emailInput) emailInput.focus();
      }
    }

    function hideLoginModal() {
      const modal = document.getElementById('loginModal');
      if (modal) {
        modal.classList.remove('active');
      }
    }

    async function handleLogin() {
      const emailInput = document.getElementById('loginEmailInput');
      const passwordInput = document.getElementById('loginPasswordInput');
      const errorDiv = document.getElementById('loginError');

      const email = emailInput?.value.trim();
      const password = passwordInput?.value;

      if (!email || !password) {
        if (errorDiv) {
          errorDiv.textContent = 'Por favor, preencha e-mail e senha.';
          errorDiv.style.display = 'block';
        }
        return;
      }

      if (!supabaseClient) {
        if (errorDiv) {
          errorDiv.textContent = 'Erro: Supabase não inicializado.';
          errorDiv.style.display = 'block';
        }
        return;
      }

      try {
        const { data, error } = await supabaseClient.auth.signInWithPassword({
          email: email,
          password: password
        });

        if (error) {
          throw error;
        }

        if (data && data.user) {
          currentUser = data.user;
          await loadUserProfile();
          hideLoginModal();

          // Limpar campos
          if (emailInput) emailInput.value = '';
          if (passwordInput) passwordInput.value = '';
          if (errorDiv) errorDiv.style.display = 'none';
        }
      } catch (error) {
        console.error('Erro ao fazer login:', error);
        if (errorDiv) {
          errorDiv.textContent = error.message || 'Erro ao fazer login. Verifique suas credenciais.';
          errorDiv.style.display = 'block';
        }
      }
    }

    window.handleLogin = handleLogin;

    // Permitir login com Enter
    // Dark Mode Toggle
    function initDarkMode() {
      const darkModeToggle = document.getElementById('darkModeToggle');
      const savedTheme = localStorage.getItem('theme') || 'light';

      // Aplicar tema salvo
      document.documentElement.setAttribute('data-theme', savedTheme);

      if (darkModeToggle) {
        darkModeToggle.addEventListener('click', () => {
          const currentTheme = document.documentElement.getAttribute('data-theme');
          const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

          document.documentElement.setAttribute('data-theme', newTheme);
          localStorage.setItem('theme', newTheme);
        });
      }
    }

    // Função para tornar o painel direito arrastável
    function initDraggablePanel() {
      const panel = document.getElementById('codePanel');
      const header = document.getElementById('codePanelHeader');
      const headerElement = document.querySelector('.header');

      if (!panel || !header) return;

      let isDragging = false;
      let currentX = 0;
      let currentY = 0;
      let initialX = 0;
      let initialY = 0;
      let headerHeight = headerElement ? headerElement.offsetHeight : 0;

      // Carregar posição salva
      const savedPosition = localStorage.getItem('codePanelPosition');
      if (savedPosition) {
        try {
          const pos = JSON.parse(savedPosition);
          panel.style.right = pos.right + 'px';
          panel.style.top = pos.top + 'px';
          panel.style.bottom = pos.bottom + 'px';
          updateCanvasMargin(pos.right);
        } catch (e) {
          // Ignorar erro ao carregar posição
        }
      }

      function updateCanvasMargin(right) {
        // Função mantida para compatibilidade, mas não precisa fazer nada
        // pois o painel agora é flutuante (position: fixed) e não afeta o layout do canvas
        // O canvas sempre terá margin-right: 0
      }

      function dragStart(e) {
        if (e.target.closest('.tab-btn') || e.target.closest('.close-panel-btn')) {
          // Não iniciar drag se clicar nos botões de tab ou fechar
          return;
        }

        // Parar propagação do evento para não afetar o canvas
        e.stopPropagation();
        e.stopImmediatePropagation();
        e.preventDefault();

        initialX = e.clientX;
        initialY = e.clientY;

        const rect = panel.getBoundingClientRect();
        currentX = window.innerWidth - rect.right;
        currentY = rect.top;

        isDragging = true;
        panel.classList.add('dragging');
        document.body.classList.add('panel-dragging');

        // Prevenir eventos de scroll e outros durante o arraste
        document.body.style.overflow = 'hidden';

        document.addEventListener('mousemove', drag, { passive: false, capture: true });
        document.addEventListener('mouseup', dragEnd, { passive: false, capture: true });
      }

      function drag(e) {
        if (!isDragging) return;

        e.stopPropagation();
        e.stopImmediatePropagation();
        e.preventDefault();

        const deltaX = initialX - e.clientX;
        const deltaY = e.clientY - initialY;

        let newRight = currentX + deltaX;
        let newTop = currentY + deltaY;

        // Limitar movimento horizontal (não pode ir além da borda esquerda)
        // Considerar largura mínima do painel (300px) ou largura atual se maior
        const panelWidth = panel.offsetWidth || 300;
        const maxRight = window.innerWidth - panelWidth;
        newRight = Math.max(0, Math.min(newRight, maxRight));

        // Limitar movimento vertical (não pode ir acima do header)
        newTop = Math.max(headerHeight, newTop);

        // Limitar movimento vertical inferior
        const maxTop = window.innerHeight - 200; // Altura mínima do painel
        newTop = Math.min(newTop, maxTop);

        // Usar transform para melhor performance
        panel.style.right = newRight + 'px';
        panel.style.top = newTop + 'px';
        panel.style.bottom = 'auto';

        updateCanvasMargin(newRight);
      }

      function dragEnd(e) {
        if (!isDragging) return;

        e.stopPropagation();
        e.stopImmediatePropagation();

        isDragging = false;
        panel.classList.remove('dragging');
        document.body.classList.remove('panel-dragging');
        document.body.style.overflow = '';

        const rect = panel.getBoundingClientRect();
        const position = {
          right: window.innerWidth - rect.right,
          top: rect.top,
          bottom: window.innerHeight - rect.bottom
        };

        // Salvar posição
        localStorage.setItem('codePanelPosition', JSON.stringify(position));

        document.removeEventListener('mousemove', drag, { capture: true });
        document.removeEventListener('mouseup', dragEnd, { capture: true });
      }

      header.addEventListener('mousedown', dragStart);

      // Atualizar altura do header quando a janela redimensionar
      window.addEventListener('resize', () => {
        headerHeight = headerElement ? headerElement.offsetHeight : 0;
      });
    }

    document.addEventListener('DOMContentLoaded', () => {
      // Inicializar dark mode
      initDarkMode();

      // Inicializar painel arrastável
      initDraggablePanel();

      // Inicializar visibilidade do botão de pré-visualizar
      if (typeof updatePreviewButtonVisibility === 'function') {
        updatePreviewButtonVisibility();
      }

      // Inicializar visibilidade da aba de código
      if (typeof updateCodeTabVisibility === 'function') {
        updateCodeTabVisibility();
      }

      const emailInput = document.getElementById('loginEmailInput');
      const passwordInput = document.getElementById('loginPasswordInput');

      if (emailInput) {
        emailInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            passwordInput?.focus();
          }
        });
      }

      if (passwordInput) {
        passwordInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            handleLogin();
          }
        });
      }
    });

    // init
    function closeModal() { const m = document.getElementById('modal'); if (m) m.classList.remove('active'); }
    function openModal() { const m = document.getElementById('modal'); if (m) m.classList.add('active'); }

    function init() {
      // Tentar carregar estado salvo do localStorage
      const loaded = loadState();

      // Se não houver estado salvo, usar defaults
      if (!loaded) {
        pageSizeSel.value = pageSize;
        orientationSel.value = orientation;
        mL.value = pageMargins[0];
        mT.value = pageMargins[1];
        mR.value = pageMargins[2];
        mB.value = pageMargins[3];
        zoomRange.value = 100;
        zoomLabel.textContent = '100%';
        zoom = 1;
      } else {
        // Estado carregado - os valores já foram restaurados em loadState()
        // Apenas garantir que os inputs do DOM estão sincronizados
        if (pageSizeSel) pageSizeSel.value = pageSize;
        if (orientationSel) orientationSel.value = orientation;
        if (mL) mL.value = pageMargins[0];
        if (mT) mT.value = pageMargins[1];
        if (mR) mR.value = pageMargins[2];
        if (mB) mB.value = pageMargins[3];
        if (zoomRange) {
          zoomRange.value = Math.round(zoom * 100);
          if (zoomLabel) zoomLabel.textContent = Math.round(zoom * 100) + '%';
        }

        // Restaurar código gerado se existir
        try {
          const savedCode = localStorage.getItem(STORAGE_CODE_KEY);
          if (savedCode && codeEditor) {
            codeEditor.textContent = savedCode;
          }
        } catch (e) {
          console.warn('Erro ao restaurar código do localStorage:', e);
        }
      }

      // Renderizar tudo (vai gerar novo código se não houver código salvo)
      renderAll();

      // Atualizar visibilidade do botão "Salvar Template" na inicialização
      updateSaveTemplateButtonVisibility();

      // Aplicar zoom após renderizar
      applyZoom();
    }

    init();

    // -----------------------
    // V1 - Replicação com IA desabilitada
    // -----------------------
    /*
    let selectedPDFFile = null;
    let pdfPageCount = 0;
    let pdfPageCount = 0;
    
    // Abrir modal de replicação com IA
    const aiReplicateBtn = document.getElementById('aiReplicateBtn');
    if (aiReplicateBtn) {
      aiReplicateBtn.addEventListener('click', () => {
        openAIReplicateModal();
      });
    }
    
    function openAIReplicateModal() {
      const modal = document.getElementById('aiReplicateModal');
      const fileInput = document.getElementById('pdfFileInput');
      const fileInfo = document.getElementById('pdfFileInfo');
      const errorDiv = document.getElementById('aiReplicateError');
      const replicateBtn = document.getElementById('replicateBtn');
      
      if (modal) {
        // Resetar estado
        selectedPDFFile = null;
        pdfPageCount = 0;
        if (fileInput) fileInput.value = '';
        if (fileInfo) fileInfo.style.display = 'none';
        if (errorDiv) {
          errorDiv.style.display = 'none';
          errorDiv.textContent = '';
        }
        if (replicateBtn) replicateBtn.disabled = true;
        
        modal.classList.add('active');
        
        // Adicionar listener para mudança de arquivo
        if (fileInput) {
          fileInput.addEventListener('change', handlePDFFileSelect);
        }
      }
    }
    
    function closeAIReplicateModal() {
      const modal = document.getElementById('aiReplicateModal');
      if (modal) {
        modal.classList.remove('active');
      }
    }
    window.closeAIReplicateModal = closeAIReplicateModal;
    
    async function handlePDFFileSelect(event) {
      const file = event.target.files[0];
      const fileInfo = document.getElementById('pdfFileInfo');
      const fileName = document.getElementById('pdfFileName');
      const fileSize = document.getElementById('pdfFileSize');
      const errorDiv = document.getElementById('aiReplicateError');
      const replicateBtn = document.getElementById('replicateBtn');
      
      if (!file) {
        if (fileInfo) fileInfo.style.display = 'none';
        if (replicateBtn) replicateBtn.disabled = true;
        return;
      }
      
      // Validar tipo de arquivo
      if (file.type !== 'application/pdf' && !file.name.toLowerCase().endsWith('.pdf')) {
        if (errorDiv) {
          errorDiv.textContent = 'Por favor, selecione apenas arquivos PDF.';
          errorDiv.style.display = 'block';
        }
        if (fileInfo) fileInfo.style.display = 'none';
        if (replicateBtn) replicateBtn.disabled = true;
        return;
      }
      
      // Validar tamanho (máximo 10MB)
      if (file.size > 10 * 1024 * 1024) {
        if (errorDiv) {
          errorDiv.textContent = 'O arquivo é muito grande. Máximo de 10MB permitido.';
          errorDiv.style.display = 'block';
        }
        if (fileInfo) fileInfo.style.display = 'none';
        if (replicateBtn) replicateBtn.disabled = true;
        return;
      }
      
      // Contar páginas do PDF
      try {
        pdfPageCount = await countPDFPages(file);
        
        if (pdfPageCount > 2) {
          if (errorDiv) {
            errorDiv.textContent = `O PDF possui ${pdfPageCount} páginas. Recomendamos no máximo 2 páginas para melhor resultado.`;
            errorDiv.style.display = 'block';
          }
          // Ainda permite continuar, mas mostra aviso
        } else {
          if (errorDiv) errorDiv.style.display = 'none';
        }
        
        // Mostrar informações do arquivo
        selectedPDFFile = file;
        if (fileInfo) fileInfo.style.display = 'block';
        if (fileName) fileName.textContent = file.name;
        if (fileSize) {
          const sizeMB = (file.size / (1024 * 1024)).toFixed(2);
          fileSize.textContent = `${sizeMB} MB • ${pdfPageCount} página${pdfPageCount !== 1 ? 's' : ''}`;
        }
        if (replicateBtn) replicateBtn.disabled = false;
      } catch (error) {
        console.error('Erro ao processar PDF:', error);
        if (errorDiv) {
          errorDiv.textContent = 'Erro ao processar o arquivo PDF. Por favor, tente novamente.';
          errorDiv.style.display = 'block';
        }
        if (fileInfo) fileInfo.style.display = 'none';
        if (replicateBtn) replicateBtn.disabled = true;
      }
    }
    
    async function countPDFPages(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function(e) {
          const arrayBuffer = e.target.result;
          const uint8Array = new Uint8Array(arrayBuffer);
          const pdfText = new TextDecoder('latin1').decode(uint8Array);
          
          // Contar ocorrências de /Type/Page ou /Count
          const pageMatches = pdfText.match(/\/Type[\s]*\/Page[^s]/g);
          if (pageMatches) {
            resolve(pageMatches.length);
          } else {
            // Tentar método alternativo
            const countMatch = pdfText.match(/\/Count[\s]+(\d+)/);
            if (countMatch) {
              resolve(parseInt(countMatch[1]));
            } else {
              resolve(1); // Default para 1 página se não conseguir contar
            }
          }
        };
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
      });
    }
    
    async function handleAIReplicate() {
      if (!selectedPDFFile) {
        return;
      }
      
      const errorDiv = document.getElementById('aiReplicateError');
      const loadingDiv = document.getElementById('aiReplicateLoading');
      const replicateBtn = document.getElementById('replicateBtn');
      const modal = document.getElementById('aiReplicateModal');
      
      // Mostrar loading
      if (loadingDiv) loadingDiv.style.display = 'block';
      if (errorDiv) errorDiv.style.display = 'none';
      if (replicateBtn) replicateBtn.disabled = true;
      
      try {
        // Ler o prompt do agente
        const agentPrompt = `🎯 PROMPT — AGENTE CONVERSOR DE PDF → LAYOUT PDFMAKE
Contexto

Você é um especialista sênior em engenharia de layout PDF, com domínio profundo de pdfMake, estrutura de documentos, paginação, headers, tabelas, grids, imagens base64, canvas, SVG e tipografia.

Seu trabalho é analisar um arquivo PDF enviado e reconstruir fielmente o layout desse PDF em código pdfMake, pronto para uso em produção.

Objetivo Principal

Analisar todo o PDF e recriar o layout completo usando pdfMake, retornando apenas o código necessário para gerar aquele PDF novamente.

O resultado final deve ser:
var dd = { ... };

ou, se necessário para organização:
var dd = (function () {
  // ...
  return { ... };
})();

Requisitos Obrigatórios (LEIA COM ATENÇÃO)

1. Fidelidade visual
Você deve:
- Replicar posições, espaçamentos e alinhamentos
- Replicar tabelas, linhas, colunas, bordas
- Replicar títulos, subtítulos, textos legais, observações
- Replicar assinaturas, linhas de assinatura, labels
- Replicar quebras de página
- Replicar hierarquia visual

📌 Não simplifique o layout.
📌 Não invente design.
📌 Não "aproxime".
É para ficar o mais fiel possível ao PDF original.

2. Header e Footer
❗ NÃO utilize dd.header ou dd.footer como funções.

Sempre que existir um header visual:
- Ele deve ser renderizado dentro do content
- Preferencialmente como uma função pageHeader() que retorna blocos do content

Exemplo aceitável:
content.push(...pageHeader());

3. Imagens
Toda imagem deve ser tratada como:
image: "<URL ou data:image/...>"

❗ Nunca assuma que a imagem já está em base64
❗ Nunca converta imagens dentro do código

4. Tipografia
Utilize fontSize, bold, italics, alignment, lineHeight
Não use fontes externas
Trabalhe apenas com fontes padrão do pdfMake

5. Tabelas
Sempre que visualizar:
- Grades
- Linhas estruturadas
- Colunas alinhadas

Use:
table: {
  widths: [...],
  body: [...]
}

Com:
layout: "noBorders" quando não houver bordas
Layout customizado quando houver linhas visíveis

6. Linhas e separadores
Para linhas horizontais ou campos de preenchimento, use:
canvas: [{
  type: "line",
  x1: 0, y1: 0,
  x2: <largura>,
  y2: 0,
  lineWidth: <espessura>
}]

7. Paginação
Respeite margens
Respeite conteúdo que se repete por página
Caso o conteúdo seja dinâmico, estruture o código para permitir paginação automática

Estrutura Esperada do Retorno

Seu retorno DEVE CONTER APENAS:
- Um breve comentário inicial explicando:
  * Quantas páginas o PDF possui
  * Se existe header visual
  * Se existe footer visual
- O código completo em pdfMake

❌ Não explique pdfMake
❌ Não escreva texto fora do código
❌ Não escreva instruções adicionais
❌ Não pergunte nada

Missão Final
Você deve agir como um engenheiro de layout reverso de PDF, não como um explicador.
📌 Seu único objetivo é recriar o PDF fidelmente em código.`;

        // Converter PDF para base64
        const base64PDF = await fileToBase64(selectedPDFFile);
        
        // Fazer chamada à OpenAI
        const response = await callOpenAIAPI(base64PDF, agentPrompt);
        
        // Processar resposta e converter para o formato do editor
        await processAIResponse(response);
        
        // Fechar modal
        closeAIReplicateModal();
        
        if (typeof showAlertModal === 'function') {
          showAlertModal('Sucesso', 'PDF replicado com sucesso! O layout foi carregado no editor.');
        }
      } catch (error) {
        console.error('Erro ao replicar PDF:', error);
        if (errorDiv) {
          errorDiv.textContent = error.message || 'Erro ao processar PDF com IA. Por favor, tente novamente.';
          errorDiv.style.display = 'block';
        }
      } finally {
        if (loadingDiv) loadingDiv.style.display = 'none';
        if (replicateBtn) replicateBtn.disabled = false;
      }
    }
    
    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          const base64 = reader.result.split(',')[1];
          resolve(base64);
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }
    
    async function callOpenAIAPI(base64PDF, prompt) {
      // ⚠️ IMPORTANTE: CONFIGURAÇÃO DA API KEY DA OPENAI
      // 
      // Para usar esta funcionalidade, você precisa:
      // 1. Obter uma API key da OpenAI em https://platform.openai.com/api-keys
      // 2. Substituir 'YOUR_OPENAI_API_KEY' abaixo pela sua chave
      // 
      // ⚠️ SEGURANÇA: Em produção, NUNCA exponha sua API key no código frontend!
      // Recomenda-se criar um backend/proxy que faça a chamada à API.
      // 
      // Para desenvolvimento local, você pode usar:
       const OPENAI_API_KEY = localStorage.getItem('openai_api_key') || 'YOUR_OPENAI_API_KEY';
      
      // Tentar obter do localStorage primeiro, senão usar a chave padrão
      //let OPENAI_API_KEY = localStorage.getItem('openai_api_key') || 'YOUR_OPENAI_API_KEY';
      
      if (!OPENAI_API_KEY || OPENAI_API_KEY === 'YOUR_OPENAI_API_KEY') {
        throw new Error('API key da OpenAI não configurada. Por favor, defina localStorage.setItem("openai_api_key", "sua-chave-aqui") no console do navegador ou configure diretamente no código.');
      }
      
      // Converter PDF para imagens (páginas) usando pdf.js ou similar
      // Por enquanto, vamos usar uma abordagem alternativa: enviar o PDF como arquivo
      // Nota: A API da OpenAI requer que PDFs sejam convertidos para imagens primeiro
      // ou usar a API de Assistants com file uploads
      
      // Método 1: Usar Assistants API (recomendado para PDFs)
      try {
        // Primeiro, fazer upload do arquivo
        const formData = new FormData();
        formData.append('file', selectedPDFFile);
        formData.append('purpose', 'assistants');
        
        const uploadResponse = await fetch('https://api.openai.com/v1/files', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${OPENAI_API_KEY}`
          },
          body: formData
        });
        
        if (!uploadResponse.ok) {
          throw new Error('Erro ao fazer upload do arquivo');
        }
        
        const fileData = await uploadResponse.json();
        const fileId = fileData.id;
        
        // Agora criar uma thread e usar o Assistants API
        // Por simplicidade, vamos usar chat completions com conversão de PDF para texto
        // Nota: Para produção, considere usar um backend que converta PDF para imagens
        
        // Método alternativo: Converter PDF para texto e enviar descrição
        const pdfText = await extractPDFText(selectedPDFFile);
        
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${OPENAI_API_KEY}`
          },
          body: JSON.stringify({
            model: 'gpt-4o', // ou 'gpt-4-turbo'
            messages: [
              {
                role: 'system',
                content: prompt
              },
              {
                role: 'user',
                content: `Analise este PDF e gere o código pdfMake correspondente. 

Informações extraídas do PDF:
${pdfText.substring(0, 5000)}...`
              }
            ],
            max_tokens: 4000,
            temperature: 0.1
          })
        });
        
        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error?.message || 'Erro ao chamar API da OpenAI');
        }
        
        const data = await response.json();
        return data.choices[0].message.content;
      } catch (error) {
        // Se falhar, tentar método alternativo
        console.warn('Método principal falhou, tentando método alternativo:', error);
        throw error;
      }
    }
    
    async function extractPDFText(file) {
      // Método simples: tentar extrair texto básico do PDF
      // Para produção, use pdf.js ou similar
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = function(e) {
          const arrayBuffer = e.target.result;
          const uint8Array = new Uint8Array(arrayBuffer);
          const pdfText = new TextDecoder('latin1').decode(uint8Array);
          
          // Extrair texto básico (método simples)
          const textMatches = pdfText.match(/\((.*?)\)/g);
          let extractedText = '';
          if (textMatches) {
            extractedText = textMatches.slice(0, 100).join(' '); // Limitar para não exceder tokens
          }
          
          resolve(extractedText || 'PDF processado. Por favor, analise visualmente.');
        };
        reader.readAsArrayBuffer(file);
      });
    }
    
    async function processAIResponse(aiResponse) {
      // Extrair código do pdfMake da resposta
      let code = aiResponse;
      
      // Tentar extrair apenas o código entre var dd = ... ou function()...
      const codeMatch = code.match(/var\s+dd\s*=\s*(\(function\s*\([^)]*\)\s*\{[\s\S]*?\}\s*\)\s*\(\)|[\s\S]*?);/);
      if (codeMatch) {
        code = codeMatch[1];
      }
      
      // Executar o código para obter o objeto dd
      let dd;
      try {
        // Criar função segura para executar o código
        const func = new Function('return ' + code);
        dd = func();
      } catch (error) {
        // Se falhar, tentar executar diretamente
        try {
          eval('var dd = ' + code);
        } catch (e) {
          throw new Error('Erro ao processar código retornado pela IA: ' + e.message);
        }
      }
      
      // Converter objeto dd para formato do editor
      await convertPDFMakeToEditor(dd);
    }
    
    async function convertPDFMakeToEditor(dd) {
      // Limpar canvas atual
      elements = [];
      currentTemplateId = null;
      
      // Atualizar configurações de página
      if (dd.pageSize) {
        pageSize = dd.pageSize;
        const pageSizeSel = document.getElementById('pageSize');
        if (pageSizeSel) pageSizeSel.value = pageSize;
      }
      
      if (dd.pageOrientation) {
        orientation = dd.pageOrientation;
        const orientationSel = document.getElementById('orientation');
        if (orientationSel) orientationSel.value = orientation;
      }
      
      if (dd.pageMargins) {
        pageMargins = dd.pageMargins;
        const mL = document.getElementById('mL');
        const mT = document.getElementById('mT');
        const mR = document.getElementById('mR');
        const mB = document.getElementById('mB');
        if (mL) mL.value = pageMargins[0];
        if (mT) mT.value = pageMargins[1];
        if (mR) mR.value = pageMargins[2];
        if (mB) mB.value = pageMargins[3];
      }
      
      // Converter content para elementos do editor
      if (dd.content && Array.isArray(dd.content)) {
        const rootGroup = {
          id: uid(),
          type: 'group',
          properties: {
            orientation: 'column',
            gap: 10,
            children: []
          }
        };
        
        // Converter cada item do content
        for (const item of dd.content) {
          const element = pdfMakeToEditorElement(item);
          if (element) {
            rootGroup.properties.children.push(element);
          }
        }
        
        elements = [rootGroup];
      }
      
      // Renderizar tudo
      renderAll();
      renderInspector();
      // Código será gerado apenas quando usuário solicitar na aba de código
      updateSaveTemplateButtonVisibility();
      
      if (typeof showAlertModal === 'function') {
        showAlertModal('Sucesso', 'Layout replicado com sucesso!');
      }
    }
    
    function pdfMakeToEditorElement(item) {
      if (!item || typeof item !== 'object') {
        return null;
      }
      
      // Stack = Group
      if (item.stack && Array.isArray(item.stack)) {
        const group = {
          id: uid(),
          type: 'group',
          properties: {
            orientation: 'column',
            gap: 10,
            children: []
          }
        };
        
        for (const child of item.stack) {
          const childElement = pdfMakeToEditorElement(child);
          if (childElement) {
            group.properties.children.push(childElement);
          }
        }
        
        return group;
      }
      
      // Columns
      if (item.columns && Array.isArray(item.columns)) {
        const columns = {
          id: uid(),
          type: 'columns',
          properties: {
            columnsCount: item.columns.length,
            gap: item.columnGap || 10,
            columns: item.columns.map(col => ({
              width: col.width || '*',
              children: []
            }))
          }
        };
        
        // Processar conteúdo de cada coluna
        item.columns.forEach((col, index) => {
          if (col.stack) {
            col.stack.forEach(child => {
              const childElement = pdfMakeToEditorElement(child);
              if (childElement) {
                columns.properties.columns[index].children.push(childElement);
              }
            });
          } else {
            const childElement = pdfMakeToEditorElement(col);
            if (childElement) {
              columns.properties.columns[index].children.push(childElement);
            }
          }
        });
        
        return columns;
      }
      
      // Table
      if (item.table && item.table.body) {
        const table = {
          id: uid(),
          type: 'table',
          properties: {
            headerRows: item.table.headerRows || 0,
            widths: item.table.widths || [],
            body: item.table.body.map(row => 
              row.map(cell => {
                if (typeof cell === 'string') {
                  return { text: cell };
                }
                return cell;
              })
            )
          }
        };
        
        return table;
      }
      
      // Text
      if (item.text !== undefined) {
        return {
          id: uid(),
          type: 'text',
          properties: {
            text: item.text,
            fontSize: item.fontSize || 14,
            bold: item.bold || false,
            italics: item.italics || false,
            alignment: item.alignment || 'left',
            color: item.color,
            margin: item.margin || [0, 0, 0, 10]
          }
        };
      }
      
      // Image
      if (item.image) {
        return {
          id: uid(),
          type: 'image',
          properties: {
            url: item.image,
            width: item.width || 200,
            height: item.height || 150,
            margin: item.margin || [0, 0, 0, 10]
          }
        };
      }
      
      // List
      if (item.ul || item.ol) {
        const listType = item.ul ? 'ul' : 'ol';
        const items = item[listType] || [];
        
        return {
          id: uid(),
          type: 'list',
          properties: {
            listType: listType,
            items: items.map(it => ({
              kind: 'text',
              text: typeof it === 'string' ? it : it.text || ''
            })),
            margin: item.margin || [0, 0, 0, 10]
          }
        };
      }
      
      return null;
    }
    
    window.handleAIReplicate = handleAIReplicate;
    */

    // Salvar estado antes de fechar/recarregar a página
    window.addEventListener('beforeunload', () => {
      saveState();
    });

    // Salvar periodicamente (a cada 30 segundos) como backup
    setInterval(() => {
      saveState();
    }, 30000);
  </script>


  <!-- Modal de Confirmação -->
  <div id="confirmModal" class="custom-modal" style="z-index: 10002;">
    <div class="custom-modal-overlay" onclick="closeConfirmModal()"></div>
    <div class="custom-modal-content" style="z-index: 10003;">
      <div class="custom-modal-header">
        <h3 id="confirmModalTitle">Confirmar ação</h3>
      </div>
      <div class="custom-modal-body">
        <p id="confirmModalMessage">Tem certeza que deseja realizar esta ação?</p>
      </div>
      <div class="custom-modal-footer">
        <button class="custom-modal-btn custom-modal-btn-cancel" onclick="closeConfirmModal()">Cancelar</button>
        <button class="custom-modal-btn custom-modal-btn-confirm" id="confirmModalOkBtn"
          onclick="confirmModalAction()">OK</button>
      </div>
    </div>
  </div>

  <!-- Modal de Alerta -->
  <div id="alertModal" class="custom-modal">
    <div class="custom-modal-overlay" onclick="closeAlertModal()"></div>
    <div class="custom-modal-content">
      <div class="custom-modal-header">
        <h3>Aviso</h3>
      </div>
      <div class="custom-modal-body">
        <p id="alertModalMessage">Mensagem de alerta</p>
      </div>
      <div class="custom-modal-footer">
        <button class="custom-modal-btn custom-modal-btn-confirm" onclick="closeAlertModal()"
          style="width: 100%;">OK</button>
      </div>
    </div>
  </div>

  <!-- Modal de Preview do PDF -->
  <div id="previewModal" class="custom-modal">
    <div class="custom-modal-overlay" onclick="closePreviewModal()"></div>
    <div class="preview-modal-content">
      <div class="preview-modal-header">
        <h3>Pré-visualização do PDF</h3>
        <button class="preview-modal-close" onclick="closePreviewModal()">Fechar</button>
      </div>
      <div class="preview-modal-body">
        <iframe id="previewIframe" class="preview-modal-iframe" frameborder="0"
          style="overflow:hidden;overflow-x:hidden;overflow-y:hidden;height:100%;width:100%;position:absolute;top:0px;left:0px;right:0px;bottom:0px"
          height="100%" width="100%">
        </iframe>
      </div>
    </div>
  </div>

  <div id="bubbleTestModal" class="custom-modal">
    <div class="custom-modal-overlay" onclick="closeBubbleTestModal()"></div>
    <div class="preview-modal-content">
      <div class="preview-modal-header">
        <h3>Pré-visualização do PDF</h3>
        <button class="preview-modal-close" onclick="closeBubbleTestModal()">Fechar</button>
      </div>
      <div class="preview-modal-body">
        <iframe id="bubbleTestIframe" class="preview-modal-iframe" frameborder="0"
          style="overflow:hidden;overflow-x:hidden;overflow-y:hidden;height:100%;width:100%;position:absolute;top:0px;left:0px;right:0px;bottom:0px"
          height="100%" width="100%">
        </iframe>
      </div>
    </div>
  </div>

  <!-- Modal de Salvar Template -->
  <div id="saveTemplateModal" class="custom-modal">
    <div class="custom-modal-overlay" onclick="closeSaveTemplateModal()"></div>
    <div class="custom-modal-content" style="max-width: 500px;">
      <div class="custom-modal-header">
        <h3>💾 Salvar Template</h3>
      </div>
      <div class="custom-modal-body">
        <p style="margin-bottom: 1rem; color: #6b7280;">Digite um nome para salvar o template atual:</p>
        <input type="text" id="saveTemplateNameInput" placeholder="Nome do template"
          style="width: 100%; padding: 0.75rem; border: 1px solid #d1d5db; border-radius: 0.375rem; font-size: 1rem;"
          autofocus>
        <div id="saveTemplateError"
          style="display: none; margin-top: 0.5rem; padding: 0.5rem; background: #fee2e2; border-left: 3px solid #ef4444; border-radius: 0.25rem; color: #991b1b; font-size: 0.875rem;">
        </div>
      </div>
      <div class="custom-modal-footer">
        <button class="custom-modal-btn custom-modal-btn-cancel" onclick="closeSaveTemplateModal()">Cancelar</button>
        <button class="custom-modal-btn custom-modal-btn-confirm" onclick="confirmSaveTemplate()">Salvar</button>
      </div>
    </div>
  </div>

  <!-- Modal de Carregar Template -->
  <div id="loadTemplateModal" class="custom-modal">
    <div class="custom-modal-overlay" onclick="closeLoadTemplateModal()"></div>
    <div class="custom-modal-content" style="max-width: 600px;">
      <div class="custom-modal-header">
        <h3>📂 Carregar Template</h3>
      </div>
      <div class="custom-modal-body">
        <div id="loadTemplateList" style="max-height: 400px; overflow-y: auto;">
          <!-- Lista de templates será preenchida aqui -->
        </div>
        <div id="loadTemplateEmpty" style="display: none; text-align: center; padding: 2rem; color: #6b7280;">
          <p>Nenhum template salvo encontrado.</p>
        </div>
      </div>
      <div class="custom-modal-footer">
        <button class="custom-modal-btn custom-modal-btn-cancel" onclick="closeLoadTemplateModal()"
          style="width: 100%;">Fechar</button>
      </div>
    </div>
  </div>

  <!-- Modal de Login -->
  <div id="loginModal" class="custom-modal" style="z-index: 10000;">
    <div class="custom-modal-overlay" style="pointer-events: auto;"></div>
    <div class="custom-modal-content" style="max-width: 400px;">
      <div class="custom-modal-header">
        <h3>🔐 Login</h3>
      </div>
      <div class="custom-modal-body">
        <p style="margin-bottom: 1rem; color: #6b7280;">Faça login para continuar:</p>
        <input type="email" id="loginEmailInput" placeholder="E-mail"
          style="width: 100%; padding: 0.75rem; border: 1px solid #d1d5db; border-radius: 0.375rem; font-size: 1rem; margin-bottom: 0.75rem;"
          autofocus>
        <input type="password" id="loginPasswordInput" placeholder="Senha"
          style="width: 100%; padding: 0.75rem; border: 1px solid #d1d5db; border-radius: 0.375rem; font-size: 1rem; margin-bottom: 0.75rem;">
        <div id="loginError"
          style="display: none; margin-top: 0.5rem; padding: 0.5rem; background: #fee2e2; border-left: 3px solid #ef4444; border-radius: 0.25rem; color: #991b1b; font-size: 0.875rem;">
        </div>
      </div>
      <div class="custom-modal-footer">
        <button class="custom-modal-btn custom-modal-btn-confirm" onclick="handleLogin()"
          style="width: 100%;">Entrar</button>
      </div>
    </div>
  </div>

  <!-- V1 - Modal de Replicação com IA desabilitado
  <div id="aiReplicateModal" class="custom-modal">
    <div class="custom-modal-overlay" onclick="closeAIReplicateModal()"></div>
    <div class="custom-modal-content" style="max-width: 600px;">
      <div class="custom-modal-header">
        <svg width="40px" height="40px" viewBox="0 0 10 10" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M2.446 1.367c1.984 0.122 2.88 -0.042 3.505 -0.042 0.581 0 0.855 1.912 0.616 2.476 -0.225 0.532 -4.059 0.554 -4.237 0.343 -0.206 -0.244 -0.087 -1.262 -0.087 -1.612" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M2.458 4.767c-2.725 2.52 0.573 2.07 1.248 2.61" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M2.458 4.767c0.037 0.575 0.071 1.875 0.048 2.055" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M5.208 3.406v-0.321" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M4.432 3.432c-0.007 -0.085 0 -0.279 0 -0.347" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M5.085 6.043c3.717 -0.045 4.287 -0.375 2.728 2.503" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M7.139 8.636c-2.219 -0.09 -3.717 0.72 -2.683 -2.024" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M4.5 8.636c-0.481 -0.352 -1.018 -0.631 -1.484 -1.019" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M5.46 4.754c0.016 0.385 0.03 0.769 0.03 1.154" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M5.46 4.754c0.188 0.297 0.364 0.49 0.585 1.004" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M2.003 2.976c-0.113 0.03 -0.227 0.024 -0.342 0.034" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M1.49 2.737c0.002 0.207 0 0.411 -0.017 0.615" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M6.944 2.891c0.085 -0.009 0.171 -0.02 0.256 -0.034" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M7.285 2.617c0.024 0.136 0.017 0.273 0.017 0.41" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/><path d="M5.644 2.912c-0.56 -0.062 -1.103 -0.032 -1.641 0.053" stroke="#e2574c" stroke-opacity="0.9" stroke-width="0.4" stroke-linecap="round" stroke-linejoin="round"/></svg>
        <h3>Replique o layout do PDF com IA</h3>
      </div>
      <div class="custom-modal-body">
        <p style="margin-bottom: 1.5rem; color: #6b7280; font-size: 0.95rem;">Replique seu arquivo PDF em no máximo 5 minutos</p>
        
        <div style="margin-bottom: 1.5rem;">
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 500; color: #374151;">Selecione o arquivo PDF:</label>
          <input type="file" id="pdfFileInput" accept=".pdf,application/pdf" style="width: 100%; padding: 0.75rem; border: 2px dashed #d1d5db; border-radius: 0.375rem; font-size: 1rem; cursor: pointer; transition: border-color 0.2s;" />
          <p style="margin-top: 0.5rem; font-size: 0.875rem; color: #6b7280;">Apenas arquivos PDF são permitidos. Máximo de 2 páginas recomendado.</p>
        </div>
        
        <div id="pdfFileInfo" style="display: none; padding: 1rem; background: #f3f4f6; border-radius: 0.375rem; margin-bottom: 1rem;">
          <div style="display: flex; align-items: center; gap: 0.75rem;">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M14 2H6C4.9 2 4 2.9 4 4V20C4 21.1 4.9 22 6 22H18C19.1 22 20 21.1 20 20V8L14 2Z" fill="#3b82f6"/>
              <path d="M14 2V8H20" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            <div>
              <p style="font-weight: 600; color: #111827; margin: 0;" id="pdfFileName"></p>
              <p style="font-size: 0.875rem; color: #6b7280; margin: 0.25rem 0 0 0;" id="pdfFileSize"></p>
            </div>
          </div>
        </div>
        
        <div id="aiReplicateError" style="display: none; margin-top: 0.5rem; padding: 0.75rem; background: #fee2e2; border-left: 3px solid #ef4444; border-radius: 0.25rem; color: #991b1b; font-size: 0.875rem;"></div>
        
        <div id="aiReplicateLoading" style="display: none; text-align: center; padding: 1.5rem;">
          <div style="display: inline-block; width: 40px; height: 40px; border: 4px solid #e5e7eb; border-top-color: #2563eb; border-radius: 50%; animation: spin 1s linear infinite;"></div>
          <p style="margin-top: 1rem; color: #6b7280;">Processando PDF com IA...</p>
        </div>
      </div>
      <div class="custom-modal-footer">
        <button class="custom-modal-btn custom-modal-btn-cancel" onclick="closeAIReplicateModal()">Cancelar</button>
        <button class="custom-modal-btn custom-modal-btn-confirm" id="replicateBtn" onclick="handleAIReplicate()" disabled>Replicar com IA</button>
      </div>
    </div>
  </div>
  -->

  <!-- V1 - Estilos da replicação com IA desabilitados
  <style>
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
  -->
</body>

</html>
